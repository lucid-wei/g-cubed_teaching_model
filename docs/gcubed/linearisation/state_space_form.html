<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gcubed.linearisation.state_space_form API documentation</title>
<meta name="description" content="Contains the StateSpaceForm class" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gcubed.linearisation.state_space_form</code></h1>
</header>
<section id="section-intro">
<p>Contains the StateSpaceForm class</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># ------------------------------------------------------------------
# Purpose: Compute the State Space Form for the linearised model.
# Author: Geoff Shuetrim
# ------------------------------------------------------------------
&#34;&#34;&#34;
Contains the StateSpaceForm class
&#34;&#34;&#34;
from concurrent.futures import process
import logging
import copy
import numpy as np
import pandas as pd
from scipy.linalg import lu_factor, lu_solve
import time
from gcubed.linearisation.linear_model import LinearModel
from gcubed.model import Model
from gcubed.base import Base
from gcubed.model_configuration import ModelConfiguration
from gcubed.sym_data import SymData

class StateSpaceForm(Base):
    &#34;&#34;&#34;

    The algebra embodied in this class follows 
    https://www.msgpl.com.au/Manuals2021/GGGv20JManual/softwaremanual/algorithm.pdf
    
    The notation has been extended to also include equations for 
    expected endogenous variables to include exogenous variables.

    This class provides the ability to work with the model equations. It 
    constructs the matrices of constants associated with the 
    state-space form of the linearised model. This involves eliminating
    the endogenous variables from the model via substitution.

    To use this class instantiate it with a linear_model.
    run the generate_state_space_form() method.

    To understanding the naming conventions, the partial 
    derivatives matrix associated with the partials of
    x1l with respect to z1r are stored in a property called x1l_z1r_partials.
    The same naming convention is used for all partials matrices:
    &lt;LHS_vector_name&gt;_&lt;RHS_vector_name&gt;_partials.

    The SSF matrices follow a similar naming convention:
    &lt;LHS_vector_name&gt;_&lt;RHS_vector_name&gt;
    &#34;&#34;&#34;

    def __init__(self, linear_model:LinearModel) -&gt; None:
        &#34;&#34;&#34;
        ### Constructor

        ### Arguments

        linear_model: The linear approximation to the model that will be algebraicly
        manipulated to produce the state-space form of that linear approximation.

        &#34;&#34;&#34;
        assert linear_model is not None
        assert linear_model.linear_model_is_available
        self._linear_model = linear_model

        # Copy across partial derivative matrices as starting point for ssf matrices.
        self._ssf_matrices: dict[tuple[str, str], np.ndarray] = dict()
        for lhs_vector_name in self.sym_data.lhs_vector_names:
            for rhs_vector_name in self.sym_data.rhs_vector_names:
                self._ssf_matrices[(lhs_vector_name, rhs_vector_name)] = copy.deepcopy(
                    linear_model.get_partials(lhs_vector_name, rhs_vector_name))

        self.__compute_state_space_form()

        self.__validate()


    def __validate(self):
        &#34;&#34;&#34;
        Validate the state space form details.
        &#34;&#34;&#34;
        logging.info(&#34;The State Space Form of the linearised model has been obtained.&#34;)

    @property
    def linear_model(self) -&gt; LinearModel:
        &#34;&#34;&#34;
        The linear model underpinning this state-space form.
        &#34;&#34;&#34;
        return self._linear_model
    
    @property
    def model(self) -&gt; Model:
        &#34;&#34;&#34;
        The full, non-linear model that has this state-space form for the
        given linear approximation.
        &#34;&#34;&#34;
        return self.linear_model.model

    @property
    def sym_data(self) -&gt; SymData:
        &#34;&#34;&#34;
        The SYM definition of the model.
        &#34;&#34;&#34;
        return self.model.sym_data

    @property
    def configuration(self) -&gt; ModelConfiguration:
        &#34;&#34;&#34;
        The model configuration details.
        &#34;&#34;&#34;
        return self.model.configuration

    def delta(self, lhs_vector_name, rhs_vector_name) -&gt; np.ndarray:
        &#34;&#34;&#34;
        ### Overview
        Use the name of the LHS vector and the RHS vector to retrieve 
        the matrix for the state-space form.

        ### Arguments

        lhs_vector_name: The name of the LHS vector.

        rhs_vector_name: THe name of the RHS vector

        ### Returns

        The matrix with one row for each equation associated with the LHS vector
        an one column for each variable in the RHS vector.

        &#34;&#34;&#34;
        if self._ssf_matrices is None:
            raise Exception(f&#34;Attempted to access SSF matrix relating {lhs_vector_name} to {rhs_vector_name} before it was created.&#34;)
        key = (lhs_vector_name, rhs_vector_name)
        if key in self._ssf_matrices:
            return self._ssf_matrices[key]
        return None

    def delta_as_dataframe(self, lhs_vector_name, rhs_vector_name) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        ### Arguments

        lhs_vector_name: The name of the LHS vector.

        rhs_vector_name: THe name of the RHS vector

        ### Returns

        The delta matrix as a dataframe labelling rows with LHS variable names 
        and columns with RHS variable names.
        &#34;&#34;&#34;
        if self._ssf_matrices is None:
            raise Exception(f&#34;Attempted to access SSF matrix relating {lhs_vector_name} to {rhs_vector_name} before it was created.&#34;)
        key = (lhs_vector_name, rhs_vector_name)
        if key in self._ssf_matrices:
            result: pd.DataFrame = pd.DataFrame(self._ssf_matrices[key])
            result.index = self.sym_data.vector_variable_names(vector_name=lhs_vector_name)
            result.columns = self.sym_data.vector_variable_names(vector_name=rhs_vector_name)
            return result
        return None

    def __compute_state_space_form(self):
        &#34;&#34;&#34;

        ### Overview

        Use substitution to eliminate LHS variables from the RHS of the model.
        Do this in two steps. 
        
        First solve equation for the RHS variable vector to be eliminated from the RHS.
        This is done using a LU decomposition.

        Second, use the solution to that equation to substitute the
        the LHS for that equation out of the other equations.
        &#34;&#34;&#34;
        # Track which equations we have processed.
        self._RHS_vectors_to_skip: list[str] = [&#34;z1r&#34;]

        # Used to order the ssf intermediary calculation results 
        # when they are written to a CSV file.
        self._counter:int = 1

        self.process(&#34;z1l&#34;)
        self.process(&#34;zel&#34;)
        self.process(&#34;j1l&#34;)
        self.process(&#34;x1l&#34;)

        # Delete the SSF matrices associated with the eliminated RHS vectors.
        for lhs_vector_name in self.sym_data.lhs_vector_names:
            rhs_vector_name:str = self.sym_data.matching_rhs_vector_name(lhs_vector_name)
            del self._ssf_matrices[(lhs_vector_name, rhs_vector_name)]

    def process(self,lhs_vector_name:str):
        &#34;&#34;&#34;

        ### Overview

        Do the SSF algebra for the vector of equations 
        associated with the given LHS vector name.

        ### Arguments

        lhs_vector_name: The name of the LHS vector.

        &#34;&#34;&#34;
        matched_rhs_vector_name: str = self.sym_data.matching_rhs_vector_name(lhs_vector_name)

        square_matrix: np.ndarray = self.delta(lhs_vector_name, matched_rhs_vector_name)

        # If the LHS is not related to itself on the RHS, nothing to do otherwise ...s
        # Solve the set of equations associated with the LHS vector to eliminate that vector from its RHS.
        if np.any(square_matrix):  # square_matrix has some non-zero elements
            I_A: np.ndarray = 0 - square_matrix
            np.fill_diagonal(I_A, 1 + I_A.diagonal())
            (lu, piv) = lu_factor(I_A)
            for rhs_vector_name in self.sym_data.rhs_vector_names:
                if rhs_vector_name in self._RHS_vectors_to_skip:
                    continue
                if rhs_vector_name == matched_rhs_vector_name:
                    continue
                if self.sym_data.vector_length(vector_name=rhs_vector_name) == 0:
                    continue
                self._ssf_matrices[(lhs_vector_name, rhs_vector_name)] = lu_solve(
                    (lu, piv), self.delta(lhs_vector_name, rhs_vector_name))
                self._counter = self._counter + 1

        self._RHS_vectors_to_skip.append(matched_rhs_vector_name)

        # Adjust other vector equations accordingly to eliminate the matching RHS vector from each of them.
        for other_lhs_vector_name in self.sym_data.lhs_vector_names:
            if other_lhs_vector_name == lhs_vector_name:
                continue
            if self.sym_data.vector_length(vector_name=other_lhs_vector_name) == 0:
                continue

            # Avoid matrix operations that have no effect because this matrix is all zeros.
            if not np.any(self.delta(other_lhs_vector_name, matched_rhs_vector_name)):
                continue

            for rhs_vector_name in self.sym_data.rhs_vector_names:
                if rhs_vector_name in self._RHS_vectors_to_skip:
                    continue
                if rhs_vector_name == matched_rhs_vector_name:
                    continue
                if self.sym_data.vector_length(vector_name=rhs_vector_name) == 0:
                    continue

                # Avoid matrix operations that have no effect because this matrix is all zeros.
                if not np.any(self.delta(lhs_vector_name, rhs_vector_name)):
                    continue
                
                self._ssf_matrices[(other_lhs_vector_name, rhs_vector_name)] = \
                    self.delta(other_lhs_vector_name, rhs_vector_name) + \
                    self.delta(other_lhs_vector_name, matched_rhs_vector_name) @ \
                    self.delta(lhs_vector_name, rhs_vector_name)
                self._counter = self._counter + 1</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gcubed.linearisation.state_space_form.StateSpaceForm"><code class="flex name class">
<span>class <span class="ident">StateSpaceForm</span></span>
<span>(</span><span>linear_model: <a title="gcubed.linearisation.linear_model.LinearModel" href="linear_model.html#gcubed.linearisation.linear_model.LinearModel">LinearModel</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>The algebra embodied in this class follows
<a href="https://www.msgpl.com.au/Manuals2021/GGGv20JManual/softwaremanual/algorithm.pdf">https://www.msgpl.com.au/Manuals2021/GGGv20JManual/softwaremanual/algorithm.pdf</a></p>
<p>The notation has been extended to also include equations for
expected endogenous variables to include exogenous variables.</p>
<p>This class provides the ability to work with the model equations. It
constructs the matrices of constants associated with the
state-space form of the linearised model. This involves eliminating
the endogenous variables from the model via substitution.</p>
<p>To use this class instantiate it with a linear_model.
run the generate_state_space_form() method.</p>
<p>To understanding the naming conventions, the partial
derivatives matrix associated with the partials of
x1l with respect to z1r are stored in a property called x1l_z1r_partials.
The same naming convention is used for all partials matrices:
<LHS_vector_name>_<RHS_vector_name>_partials.</p>
<p>The SSF matrices follow a similar naming convention:
<LHS_vector_name>_<RHS_vector_name></p>
<h3 id="constructor">Constructor</h3>
<h3 id="arguments">Arguments</h3>
<p>linear_model: The linear approximation to the model that will be algebraicly
manipulated to produce the state-space form of that linear approximation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StateSpaceForm(Base):
    &#34;&#34;&#34;

    The algebra embodied in this class follows 
    https://www.msgpl.com.au/Manuals2021/GGGv20JManual/softwaremanual/algorithm.pdf
    
    The notation has been extended to also include equations for 
    expected endogenous variables to include exogenous variables.

    This class provides the ability to work with the model equations. It 
    constructs the matrices of constants associated with the 
    state-space form of the linearised model. This involves eliminating
    the endogenous variables from the model via substitution.

    To use this class instantiate it with a linear_model.
    run the generate_state_space_form() method.

    To understanding the naming conventions, the partial 
    derivatives matrix associated with the partials of
    x1l with respect to z1r are stored in a property called x1l_z1r_partials.
    The same naming convention is used for all partials matrices:
    &lt;LHS_vector_name&gt;_&lt;RHS_vector_name&gt;_partials.

    The SSF matrices follow a similar naming convention:
    &lt;LHS_vector_name&gt;_&lt;RHS_vector_name&gt;
    &#34;&#34;&#34;

    def __init__(self, linear_model:LinearModel) -&gt; None:
        &#34;&#34;&#34;
        ### Constructor

        ### Arguments

        linear_model: The linear approximation to the model that will be algebraicly
        manipulated to produce the state-space form of that linear approximation.

        &#34;&#34;&#34;
        assert linear_model is not None
        assert linear_model.linear_model_is_available
        self._linear_model = linear_model

        # Copy across partial derivative matrices as starting point for ssf matrices.
        self._ssf_matrices: dict[tuple[str, str], np.ndarray] = dict()
        for lhs_vector_name in self.sym_data.lhs_vector_names:
            for rhs_vector_name in self.sym_data.rhs_vector_names:
                self._ssf_matrices[(lhs_vector_name, rhs_vector_name)] = copy.deepcopy(
                    linear_model.get_partials(lhs_vector_name, rhs_vector_name))

        self.__compute_state_space_form()

        self.__validate()


    def __validate(self):
        &#34;&#34;&#34;
        Validate the state space form details.
        &#34;&#34;&#34;
        logging.info(&#34;The State Space Form of the linearised model has been obtained.&#34;)

    @property
    def linear_model(self) -&gt; LinearModel:
        &#34;&#34;&#34;
        The linear model underpinning this state-space form.
        &#34;&#34;&#34;
        return self._linear_model
    
    @property
    def model(self) -&gt; Model:
        &#34;&#34;&#34;
        The full, non-linear model that has this state-space form for the
        given linear approximation.
        &#34;&#34;&#34;
        return self.linear_model.model

    @property
    def sym_data(self) -&gt; SymData:
        &#34;&#34;&#34;
        The SYM definition of the model.
        &#34;&#34;&#34;
        return self.model.sym_data

    @property
    def configuration(self) -&gt; ModelConfiguration:
        &#34;&#34;&#34;
        The model configuration details.
        &#34;&#34;&#34;
        return self.model.configuration

    def delta(self, lhs_vector_name, rhs_vector_name) -&gt; np.ndarray:
        &#34;&#34;&#34;
        ### Overview
        Use the name of the LHS vector and the RHS vector to retrieve 
        the matrix for the state-space form.

        ### Arguments

        lhs_vector_name: The name of the LHS vector.

        rhs_vector_name: THe name of the RHS vector

        ### Returns

        The matrix with one row for each equation associated with the LHS vector
        an one column for each variable in the RHS vector.

        &#34;&#34;&#34;
        if self._ssf_matrices is None:
            raise Exception(f&#34;Attempted to access SSF matrix relating {lhs_vector_name} to {rhs_vector_name} before it was created.&#34;)
        key = (lhs_vector_name, rhs_vector_name)
        if key in self._ssf_matrices:
            return self._ssf_matrices[key]
        return None

    def delta_as_dataframe(self, lhs_vector_name, rhs_vector_name) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        ### Arguments

        lhs_vector_name: The name of the LHS vector.

        rhs_vector_name: THe name of the RHS vector

        ### Returns

        The delta matrix as a dataframe labelling rows with LHS variable names 
        and columns with RHS variable names.
        &#34;&#34;&#34;
        if self._ssf_matrices is None:
            raise Exception(f&#34;Attempted to access SSF matrix relating {lhs_vector_name} to {rhs_vector_name} before it was created.&#34;)
        key = (lhs_vector_name, rhs_vector_name)
        if key in self._ssf_matrices:
            result: pd.DataFrame = pd.DataFrame(self._ssf_matrices[key])
            result.index = self.sym_data.vector_variable_names(vector_name=lhs_vector_name)
            result.columns = self.sym_data.vector_variable_names(vector_name=rhs_vector_name)
            return result
        return None

    def __compute_state_space_form(self):
        &#34;&#34;&#34;

        ### Overview

        Use substitution to eliminate LHS variables from the RHS of the model.
        Do this in two steps. 
        
        First solve equation for the RHS variable vector to be eliminated from the RHS.
        This is done using a LU decomposition.

        Second, use the solution to that equation to substitute the
        the LHS for that equation out of the other equations.
        &#34;&#34;&#34;
        # Track which equations we have processed.
        self._RHS_vectors_to_skip: list[str] = [&#34;z1r&#34;]

        # Used to order the ssf intermediary calculation results 
        # when they are written to a CSV file.
        self._counter:int = 1

        self.process(&#34;z1l&#34;)
        self.process(&#34;zel&#34;)
        self.process(&#34;j1l&#34;)
        self.process(&#34;x1l&#34;)

        # Delete the SSF matrices associated with the eliminated RHS vectors.
        for lhs_vector_name in self.sym_data.lhs_vector_names:
            rhs_vector_name:str = self.sym_data.matching_rhs_vector_name(lhs_vector_name)
            del self._ssf_matrices[(lhs_vector_name, rhs_vector_name)]

    def process(self,lhs_vector_name:str):
        &#34;&#34;&#34;

        ### Overview

        Do the SSF algebra for the vector of equations 
        associated with the given LHS vector name.

        ### Arguments

        lhs_vector_name: The name of the LHS vector.

        &#34;&#34;&#34;
        matched_rhs_vector_name: str = self.sym_data.matching_rhs_vector_name(lhs_vector_name)

        square_matrix: np.ndarray = self.delta(lhs_vector_name, matched_rhs_vector_name)

        # If the LHS is not related to itself on the RHS, nothing to do otherwise ...s
        # Solve the set of equations associated with the LHS vector to eliminate that vector from its RHS.
        if np.any(square_matrix):  # square_matrix has some non-zero elements
            I_A: np.ndarray = 0 - square_matrix
            np.fill_diagonal(I_A, 1 + I_A.diagonal())
            (lu, piv) = lu_factor(I_A)
            for rhs_vector_name in self.sym_data.rhs_vector_names:
                if rhs_vector_name in self._RHS_vectors_to_skip:
                    continue
                if rhs_vector_name == matched_rhs_vector_name:
                    continue
                if self.sym_data.vector_length(vector_name=rhs_vector_name) == 0:
                    continue
                self._ssf_matrices[(lhs_vector_name, rhs_vector_name)] = lu_solve(
                    (lu, piv), self.delta(lhs_vector_name, rhs_vector_name))
                self._counter = self._counter + 1

        self._RHS_vectors_to_skip.append(matched_rhs_vector_name)

        # Adjust other vector equations accordingly to eliminate the matching RHS vector from each of them.
        for other_lhs_vector_name in self.sym_data.lhs_vector_names:
            if other_lhs_vector_name == lhs_vector_name:
                continue
            if self.sym_data.vector_length(vector_name=other_lhs_vector_name) == 0:
                continue

            # Avoid matrix operations that have no effect because this matrix is all zeros.
            if not np.any(self.delta(other_lhs_vector_name, matched_rhs_vector_name)):
                continue

            for rhs_vector_name in self.sym_data.rhs_vector_names:
                if rhs_vector_name in self._RHS_vectors_to_skip:
                    continue
                if rhs_vector_name == matched_rhs_vector_name:
                    continue
                if self.sym_data.vector_length(vector_name=rhs_vector_name) == 0:
                    continue

                # Avoid matrix operations that have no effect because this matrix is all zeros.
                if not np.any(self.delta(lhs_vector_name, rhs_vector_name)):
                    continue
                
                self._ssf_matrices[(other_lhs_vector_name, rhs_vector_name)] = \
                    self.delta(other_lhs_vector_name, rhs_vector_name) + \
                    self.delta(other_lhs_vector_name, matched_rhs_vector_name) @ \
                    self.delta(lhs_vector_name, rhs_vector_name)
                self._counter = self._counter + 1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gcubed.base.Base" href="../base.html#gcubed.base.Base">Base</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="gcubed.linearisation.state_space_form.StateSpaceForm.configuration"><code class="name">var <span class="ident">configuration</span> : <a title="gcubed.model_configuration.ModelConfiguration" href="../model_configuration.html#gcubed.model_configuration.ModelConfiguration">ModelConfiguration</a></code></dt>
<dd>
<div class="desc"><p>The model configuration details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def configuration(self) -&gt; ModelConfiguration:
    &#34;&#34;&#34;
    The model configuration details.
    &#34;&#34;&#34;
    return self.model.configuration</code></pre>
</details>
</dd>
<dt id="gcubed.linearisation.state_space_form.StateSpaceForm.linear_model"><code class="name">var <span class="ident">linear_model</span> : <a title="gcubed.linearisation.linear_model.LinearModel" href="linear_model.html#gcubed.linearisation.linear_model.LinearModel">LinearModel</a></code></dt>
<dd>
<div class="desc"><p>The linear model underpinning this state-space form.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def linear_model(self) -&gt; LinearModel:
    &#34;&#34;&#34;
    The linear model underpinning this state-space form.
    &#34;&#34;&#34;
    return self._linear_model</code></pre>
</details>
</dd>
<dt id="gcubed.linearisation.state_space_form.StateSpaceForm.model"><code class="name">var <span class="ident">model</span> : <a title="gcubed.model.Model" href="../model.html#gcubed.model.Model">Model</a></code></dt>
<dd>
<div class="desc"><p>The full, non-linear model that has this state-space form for the
given linear approximation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def model(self) -&gt; Model:
    &#34;&#34;&#34;
    The full, non-linear model that has this state-space form for the
    given linear approximation.
    &#34;&#34;&#34;
    return self.linear_model.model</code></pre>
</details>
</dd>
<dt id="gcubed.linearisation.state_space_form.StateSpaceForm.sym_data"><code class="name">var <span class="ident">sym_data</span> : <a title="gcubed.sym_data.SymData" href="../sym_data.html#gcubed.sym_data.SymData">SymData</a></code></dt>
<dd>
<div class="desc"><p>The SYM definition of the model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sym_data(self) -&gt; SymData:
    &#34;&#34;&#34;
    The SYM definition of the model.
    &#34;&#34;&#34;
    return self.model.sym_data</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="gcubed.linearisation.state_space_form.StateSpaceForm.delta"><code class="name flex">
<span>def <span class="ident">delta</span></span>(<span>self, lhs_vector_name, rhs_vector_name) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><h3 id="overview">Overview</h3>
<p>Use the name of the LHS vector and the RHS vector to retrieve
the matrix for the state-space form.</p>
<h3 id="arguments">Arguments</h3>
<p>lhs_vector_name: The name of the LHS vector.</p>
<p>rhs_vector_name: THe name of the RHS vector</p>
<h3 id="returns">Returns</h3>
<p>The matrix with one row for each equation associated with the LHS vector
an one column for each variable in the RHS vector.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delta(self, lhs_vector_name, rhs_vector_name) -&gt; np.ndarray:
    &#34;&#34;&#34;
    ### Overview
    Use the name of the LHS vector and the RHS vector to retrieve 
    the matrix for the state-space form.

    ### Arguments

    lhs_vector_name: The name of the LHS vector.

    rhs_vector_name: THe name of the RHS vector

    ### Returns

    The matrix with one row for each equation associated with the LHS vector
    an one column for each variable in the RHS vector.

    &#34;&#34;&#34;
    if self._ssf_matrices is None:
        raise Exception(f&#34;Attempted to access SSF matrix relating {lhs_vector_name} to {rhs_vector_name} before it was created.&#34;)
    key = (lhs_vector_name, rhs_vector_name)
    if key in self._ssf_matrices:
        return self._ssf_matrices[key]
    return None</code></pre>
</details>
</dd>
<dt id="gcubed.linearisation.state_space_form.StateSpaceForm.delta_as_dataframe"><code class="name flex">
<span>def <span class="ident">delta_as_dataframe</span></span>(<span>self, lhs_vector_name, rhs_vector_name) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><h3 id="arguments">Arguments</h3>
<p>lhs_vector_name: The name of the LHS vector.</p>
<p>rhs_vector_name: THe name of the RHS vector</p>
<h3 id="returns">Returns</h3>
<p>The delta matrix as a dataframe labelling rows with LHS variable names
and columns with RHS variable names.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delta_as_dataframe(self, lhs_vector_name, rhs_vector_name) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    ### Arguments

    lhs_vector_name: The name of the LHS vector.

    rhs_vector_name: THe name of the RHS vector

    ### Returns

    The delta matrix as a dataframe labelling rows with LHS variable names 
    and columns with RHS variable names.
    &#34;&#34;&#34;
    if self._ssf_matrices is None:
        raise Exception(f&#34;Attempted to access SSF matrix relating {lhs_vector_name} to {rhs_vector_name} before it was created.&#34;)
    key = (lhs_vector_name, rhs_vector_name)
    if key in self._ssf_matrices:
        result: pd.DataFrame = pd.DataFrame(self._ssf_matrices[key])
        result.index = self.sym_data.vector_variable_names(vector_name=lhs_vector_name)
        result.columns = self.sym_data.vector_variable_names(vector_name=rhs_vector_name)
        return result
    return None</code></pre>
</details>
</dd>
<dt id="gcubed.linearisation.state_space_form.StateSpaceForm.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self, lhs_vector_name: str)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="overview">Overview</h3>
<p>Do the SSF algebra for the vector of equations
associated with the given LHS vector name.</p>
<h3 id="arguments">Arguments</h3>
<p>lhs_vector_name: The name of the LHS vector.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self,lhs_vector_name:str):
    &#34;&#34;&#34;

    ### Overview

    Do the SSF algebra for the vector of equations 
    associated with the given LHS vector name.

    ### Arguments

    lhs_vector_name: The name of the LHS vector.

    &#34;&#34;&#34;
    matched_rhs_vector_name: str = self.sym_data.matching_rhs_vector_name(lhs_vector_name)

    square_matrix: np.ndarray = self.delta(lhs_vector_name, matched_rhs_vector_name)

    # If the LHS is not related to itself on the RHS, nothing to do otherwise ...s
    # Solve the set of equations associated with the LHS vector to eliminate that vector from its RHS.
    if np.any(square_matrix):  # square_matrix has some non-zero elements
        I_A: np.ndarray = 0 - square_matrix
        np.fill_diagonal(I_A, 1 + I_A.diagonal())
        (lu, piv) = lu_factor(I_A)
        for rhs_vector_name in self.sym_data.rhs_vector_names:
            if rhs_vector_name in self._RHS_vectors_to_skip:
                continue
            if rhs_vector_name == matched_rhs_vector_name:
                continue
            if self.sym_data.vector_length(vector_name=rhs_vector_name) == 0:
                continue
            self._ssf_matrices[(lhs_vector_name, rhs_vector_name)] = lu_solve(
                (lu, piv), self.delta(lhs_vector_name, rhs_vector_name))
            self._counter = self._counter + 1

    self._RHS_vectors_to_skip.append(matched_rhs_vector_name)

    # Adjust other vector equations accordingly to eliminate the matching RHS vector from each of them.
    for other_lhs_vector_name in self.sym_data.lhs_vector_names:
        if other_lhs_vector_name == lhs_vector_name:
            continue
        if self.sym_data.vector_length(vector_name=other_lhs_vector_name) == 0:
            continue

        # Avoid matrix operations that have no effect because this matrix is all zeros.
        if not np.any(self.delta(other_lhs_vector_name, matched_rhs_vector_name)):
            continue

        for rhs_vector_name in self.sym_data.rhs_vector_names:
            if rhs_vector_name in self._RHS_vectors_to_skip:
                continue
            if rhs_vector_name == matched_rhs_vector_name:
                continue
            if self.sym_data.vector_length(vector_name=rhs_vector_name) == 0:
                continue

            # Avoid matrix operations that have no effect because this matrix is all zeros.
            if not np.any(self.delta(lhs_vector_name, rhs_vector_name)):
                continue
            
            self._ssf_matrices[(other_lhs_vector_name, rhs_vector_name)] = \
                self.delta(other_lhs_vector_name, rhs_vector_name) + \
                self.delta(other_lhs_vector_name, matched_rhs_vector_name) @ \
                self.delta(lhs_vector_name, rhs_vector_name)
            self._counter = self._counter + 1</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gcubed.base.Base" href="../base.html#gcubed.base.Base">Base</a></b></code>:
<ul class="hlist">
<li><code><a title="gcubed.base.Base.get_year_labels" href="../base.html#gcubed.base.Base.get_year_labels">get_year_labels</a></code></li>
<li><code><a title="gcubed.base.Base.load_data" href="../base.html#gcubed.base.Base.load_data">load_data</a></code></li>
<li><code><a title="gcubed.base.Base.zeros" href="../base.html#gcubed.base.Base.zeros">zeros</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gcubed.linearisation" href="index.html">gcubed.linearisation</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gcubed.linearisation.state_space_form.StateSpaceForm" href="#gcubed.linearisation.state_space_form.StateSpaceForm">StateSpaceForm</a></code></h4>
<ul class="two-column">
<li><code><a title="gcubed.linearisation.state_space_form.StateSpaceForm.configuration" href="#gcubed.linearisation.state_space_form.StateSpaceForm.configuration">configuration</a></code></li>
<li><code><a title="gcubed.linearisation.state_space_form.StateSpaceForm.delta" href="#gcubed.linearisation.state_space_form.StateSpaceForm.delta">delta</a></code></li>
<li><code><a title="gcubed.linearisation.state_space_form.StateSpaceForm.delta_as_dataframe" href="#gcubed.linearisation.state_space_form.StateSpaceForm.delta_as_dataframe">delta_as_dataframe</a></code></li>
<li><code><a title="gcubed.linearisation.state_space_form.StateSpaceForm.linear_model" href="#gcubed.linearisation.state_space_form.StateSpaceForm.linear_model">linear_model</a></code></li>
<li><code><a title="gcubed.linearisation.state_space_form.StateSpaceForm.model" href="#gcubed.linearisation.state_space_form.StateSpaceForm.model">model</a></code></li>
<li><code><a title="gcubed.linearisation.state_space_form.StateSpaceForm.process" href="#gcubed.linearisation.state_space_form.StateSpaceForm.process">process</a></code></li>
<li><code><a title="gcubed.linearisation.state_space_form.StateSpaceForm.sym_data" href="#gcubed.linearisation.state_space_form.StateSpaceForm.sym_data">sym_data</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
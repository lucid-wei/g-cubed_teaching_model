<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gcubed.linearisation.linear_model API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gcubed.linearisation.linear_model</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># ------------------------------------------------------------------
# Purpose: Linearise the model to produce the partial derivative
# matrices that embody the model dynamics.
# Author: Geoff Shuetrim
# ------------------------------------------------------------------
import logging
import time
import pandas as pd
import numpy as np
import sys
import importlib
from gcubed.data.gdp_scaled_database import GDPScaledDatabase
from gcubed.model import Model
from gcubed.base import Base
from gcubed.constants import Constants
from gcubed.sym_data import SymData
from gcubed.model_configuration import ModelConfiguration
from gcubed.linearisation.model_solver import ModelSolver


class LinearModel(Base):
    &#34;&#34;&#34;

    ### Overview
    
    The algebra embodied in this class follows 
    https://www.msgpl.com.au/Manuals2021/GGGv20JManual/softwaremanual/algorithm.pdf
    
    The notation has been extended to also include equations for 
    expected endogenous variables to include exogenous variables.

    This class provides the ability to work with the model equations. It:

    1. Computes the partial derivatives of the model equations
    so that an approximation of the model can be expressed as 
    a set of linear equations.
    2. Constructs the matrices of constants associated with the 
    state-space form of the linearised model. This involves eliminating
    the endogenous variables from the model via substitution.

    To use this class:

    1.  instantiate it with a model.
    2.  run the __compute_partial_derivatives() method.

    Once this sequence of steps has been completed without raising an exception,
    the matrices associated with the state space form will be accessible
    as properties of the linear model to support solving the model.

    Instantiation determines the values for the RHS variable vectors
    based upon the model&#39;s database and the year that has been chosen
    to determine the variable values that the model will be linearised 
    around.

    These RHS variable vector values, and the implied LHS variable vector values 
    are exposed as properties of the linear model. The names of these vector 
    properties are 3 character acronyms:

    The linear model supports evaluation of the model equations to obtain
    values for the LHS and RHS vectors of variables defined in sym_data.

    To understanding the naming conventions, the partial 
    derivatives matrix associated with the partials of
    x1l with respect to z1r are stored in a property called x1l_z1r_partials.
    The same naming convention is used for all partials matrices:
    &lt;LHS_vector_name&gt;_&lt;RHS_vector_name&gt;_partials.
    &#34;&#34;&#34;

    def __init__(self, model: Model) -&gt; None:
        &#34;&#34;&#34;
        ### Arguments

        model: The model that is to be linearised with the linearisation
        year specified as part of the model configuration.
        &#34;&#34;&#34;

        # Set this switch to true when the partial derivatives have been computed.
        self._linear_model_is_available: bool = False

        assert model is not None
        self._model = model

        logging.info(f&#34;Linearising the model using data with a base year of {self.configuration.linearisation_year}&#34;)
        self._linearisation_database = GDPScaledDatabase(database=self.model.database, base_year=self.configuration.linearisation_year)

        # Set up the LHS vectors as vectors of zeros.
        self.__configure_lhs_vectors()
        
        # Set up the RHS vectors for the model using data for the linearisation year.
        # First check which linearisation approach to use.
        if not self.model.configuration.linearise_around_strict_model_solution:
            # Do the standard kind of linearisation
            self.__load_rhs_vectors(linearisation_year=self.configuration.linearisation_year)
        else:
            # Do the fancy linearisation where we search for a strict solution to the model first.
            model_solver: ModelSolver = ModelSolver(model=self.model, linearisation_year=self.configuration.linearisation_year)
            if not model_solver.solution_found:
                raise Exception(f&#34;Failed to find a solution to the model for data values near those in the database for linearisation year {self.configuration.linearisation_year}. Linearisation cannot proceed.&#34;)
            for vector_name in self.sym_data.rhs_vector_names:
                rhs_vector:pd.DataFrame = getattr(model_solver, f&#34;_{vector_name}&#34;)
                if rhs_vector is not None:
                    setattr(self, f&#34;_{vector_name}&#34;, rhs_vector)
                else:
                    raise Exception(f&#34;Failed to get RHS vector {vector_name} from the solved model.&#34;)


        # Import the model equations.
        sys.path.append(self.configuration.sym_directory)
        equations_module = importlib.import_module(self.configuration.sym_output_filename_prefix)
        equations_class = getattr(equations_module, &#34;Equations&#34;)
        self._equations = equations_class(x1l=self._x1l,
                                          j1l=self._j1l,
                                          zel=self._zel,
                                          z1l=self._z1l,
                                          x1r=self._x1r,
                                          j1r=self._j1r,
                                          z1r=self._z1r,
                                          zer=self._zer,
                                          yjr=self._yjr,
                                          yxr=self._yxr,
                                          exo=self._exo,
                                          exz=self._exz,
                                          par=self.model.parameters.parameter_values_vector)

        # Solve for LHS vectors using the model equations,
        # the parameters and the RHS vectors. Store the results as benchmark
        # values for calculating partial derivatives.
        self.__compute_benchmark_equation_results()

        # Generate differences in LHS variables from those used on RHS to evaluate equations
        # These two lines of code do not typically need to run but give insight into linearisation.
        # self.__generate_nonlinear_equation_differences()
        # self.nonlinear_equation_differences.to_csv(f&#34;{self.model.configuration.benchmarking_reports_directory}nonlinear equation LHS-RHS differences.csv&#34;)

        # Load the map from RHS variables to model equations to use when computing partial derivatives.
        self.__load_equation_map()

        # Compute the partial derivatives
        self.__compute_partial_derivatives()

        self.__validate()

    def __validate(self):
        &#34;&#34;&#34;
        Validate the linear model details and 
        &#34;&#34;&#34;

        # Check we have all vectors and they are the right lengths.
        for vector_name in self.sym_data.lhs_vector_names:
            vector = self.get_vector_by_name(vector_name=vector_name)
            assert vector is not None
            assert len(vector) == self.sym_data.vector_length(
                vector_name=vector_name)

        if self.linear_model_is_available:
            logging.info(&#34;The model has been linearised.&#34;)
        else:
            logging.error(&#34;The model linearisation failed. Changes are required before proceeding.&#34;)

    @property
    def linearisation_database(self) -&gt; GDPScaledDatabase:
        &#34;&#34;&#34;
        linearisation_database (GDPScaledDatabase): The database 
        containing the values that will be utilised to populate 
        variable values for the linearisation.
        &#34;&#34;&#34;
        return self._linearisation_database

    @property
    def linear_model_is_available(self) -&gt; bool:
        &#34;&#34;&#34;
        linear_model_is_available (bool): True if the model has been linearised 
        successfully and False otherwise (either because linearisation has not
        finished or linearisation was not possible for whatever reason).
        &#34;&#34;&#34;
        return self._linear_model_is_available

    @property
    def equations(self):
        &#34;&#34;&#34;
        (BaseEquations): The equations subclass instance that implements the functions
        for each of the nonlinear equations in the model.
        &#34;&#34;&#34;
        return self._equations

    @property
    def model(self):
        &#34;&#34;&#34;
        (Model): The model being linearised.
        &#34;&#34;&#34;
        return self._model

    @property
    def sym_data(self) -&gt; SymData:
        &#34;&#34;&#34;
        The SYM data for the model being linearised.
        &#34;&#34;&#34;
        return self.model.sym_data

    @property
    def configuration(self) -&gt; ModelConfiguration:
        &#34;&#34;&#34;
        The configuration details for the model 
        being linearised.
        &#34;&#34;&#34;
        return self.model.configuration

    @property
    def equations_map(self) -&gt; dict[tuple[str, int], list[tuple[str, int]]]:
        &#34;&#34;&#34;
        ### Overview

        This is only a public property to assist with unit testing.
        Do not use it directly for other purposes.

        The map is populated from the SYM processor output and is used to make
        the calculation of partial derivatives more efficient, only calculating
        those derivatives that are not zero by definition.

        ### Returns

        The map from each RHS variable in the model to the list of 
        LHS variables (equations) that depend on it.
        &#34;&#34;&#34;
        return self._equations_map

    def get_vector_by_name(self, vector_name) -&gt; np.ndarray:
        &#34;&#34;&#34;
        ### Overview

        Use the name of the vector to retrieve its numpy array value.
        These values have been set using data in the database.

        ### Arguments

        vector_name: The name of the LHS or RHS vector.
        
        ### Returns
        
        The named column vector.
        
        &#34;&#34;&#34;
        if not hasattr(self, &#34;_{}&#34;.format(vector_name)):
            raise Exception(&#34;There is no vector for {}&#34;.format(vector_name))
        return getattr(self, &#34;_{}&#34;.format(vector_name))

    def get_original_lhs_vector_by_name(self, lhs_vector_name:str) -&gt; np.ndarray:
        &#34;&#34;&#34;

        ### Overview

        This function is useful for benchmarking the model&#39;s nonlinear equation evaluations.

        Use the name of the vector to retrieve its numpy array value.
        These values have been set by evaluating the model&#39;s non-linear equations
        using the RHS vector values for the base year chosen for the linearisation.

        ### Arguments

        lhs_vector_name: The name of the LHS vector, e.g. &#39;x1l&#39; or &#39;j1l&#39;.
        
        ### Returns
        
        The named LHS column vector.

        &#34;&#34;&#34;
        if not lhs_vector_name in self._original_lhs_vectors:
            raise Exception(f&#34;The requested vector, {lhs_vector_name}, is not a LHS vector in the model.&#34;)
        return self._original_lhs_vectors[lhs_vector_name]

    def get_partials(self, lhs_vector_name:str, rhs_vector_name:str) -&gt; np.ndarray:
        &#34;&#34;&#34;

        ### Overview

        Use the name of the LHS vector and the RHS vector to retrieve 
        the numpy matrix value for the partial derivatives.

        The matrices of partial derivatives are stored in a dictionary indexed
        by the lhs and rhs vector names.

        ### Arguments

        lhs_vector_name: The name of the LHS vector, e.g. &#39;x1l&#39; or &#39;j1l&#39;.

        rhs_vector_name: The name of the RHS vector, e.g. &#39;yxr&#39; or &#39;j1r&#39;.

        ### Returns
        
        The required partial derivatives as a dataframe 
        with variable names as the row and column labels.

        &#34;&#34;&#34;
        if self._partial_derivatives is None:
            raise Exception(f&#34;Attempted to access partial derivatives {lhs_vector_name} on {rhs_vector_name} before it was created.&#34;)
        key = (lhs_vector_name, rhs_vector_name)
        if key in self._partial_derivatives:
            return self._partial_derivatives[key]
        return None

    def get_partials_as_dataframe(self, lhs_vector_name, rhs_vector_name) -&gt; pd.DataFrame:
        &#34;&#34;&#34;

        ### Arguments

        lhs_vector_name: The name of the LHS vector, e.g. &#39;x1l&#39; or &#39;j1l&#39;.

        rhs_vector_name: The name of the RHS vector, e.g. &#39;yxr&#39; or &#39;j1r&#39;.

        ### Returns
        
        The required partial derivatives as a dataframe 
        with variable names as the row and column labels.

        &#34;&#34;&#34;
        if self._partial_derivatives is None:
            raise Exception(f&#34;Attempted to access partial derivatives {lhs_vector_name} on {rhs_vector_name} before it was created.&#34;)
        key = (lhs_vector_name, rhs_vector_name)
        if key in self._partial_derivatives:
            result: pd.DataFrame = pd.DataFrame(self._partial_derivatives[key])
            result.index = self.sym_data.vector_variable_names(vector_name=lhs_vector_name)
            result.columns = self.sym_data.vector_variable_names(vector_name=rhs_vector_name)
            return result
        return None

    def __configure_lhs_vectors(self):
        &#34;&#34;&#34;
        ### Overview

        Create the LHS vectors that are used by the model equations.
        Initialise LHS vectors with zeros.
        &#34;&#34;&#34;
        for vector_name in self.sym_data.lhs_vector_names:
            setattr(self, &#34;_{}&#34;.format(vector_name), np.zeros(
                shape=(self.sym_data.vector_length(vector_name=vector_name), 1), dtype=float))

    def __load_rhs_vectors(self, linearisation_year: int):
        &#34;&#34;&#34;

        ### Overview

        Create and set values for the RHS vectors that are used by the 
        model equations.

        Do not create vectors if they have no variables (are zero length).

        ### Arguments

        linearisation_year: The year in which the model is linearised.
        e.g. 2011 implies linearise model equations around the values
        of the model variables in 2011 (or in adjacent years for leads/lags).
        
        &#34;&#34;&#34;
        # Initialise RHS vectors with database values from the linearisation base year or the lead/lag from that year.
        for vector_name in self.sym_data.rhs_vector_names:
            rhs_vector:pd.DataFrame = self.linearisation_database.rhs_vector_value(vector_name=vector_name, year=linearisation_year, use_neutral_real_interest_rate=True)
            if rhs_vector is not None:
                setattr(self, f&#34;_{vector_name}&#34;, rhs_vector)
            else:
                raise Exception(f&#34;Failed to get RHS vector {vector_name} from the linearisation database.&#34;)

    def __compute_benchmark_equation_results(self):
        &#34;&#34;&#34;
        ### Overview

        Compute the benchmark LHS vector values using supplied RHS values.
        These are used in computing the non-linear equations in the model.
        &#34;&#34;&#34;

        self._original_lhs_vectors: dict[str, np.ndarray] = dict()
        for lhs_vector_name in self.sym_data.lhs_vector_names:
            lhs_vector = getattr(self, &#34;_{}&#34;.format(lhs_vector_name))
            for lhs_index in range(len(lhs_vector)):
                function_name = &#34;{}_{}&#34;.format(lhs_vector_name, lhs_index)
                if hasattr(self.equations, function_name):
                    func = getattr(self.equations, function_name)
                    func()
                else:
                    # logging.warning(&#34;No {} equation for element {}&#34;.format(lhs_vector_name, lhs_index))
                    pass
            self._original_lhs_vectors[lhs_vector_name] = lhs_vector.copy()

    def __load_equation_map(self):
        &#34;&#34;&#34;
        ### Overview

        Uses the eqnmap output from the sym processor to create a map from each
        RHS variable (vector + index combination) to the equations that include
        that variable on the RHS.

        This map ensures we only have to evaluate the relevant equations when computing
        the partial derivatives of the model equations when considering each RHS variable.
        &#34;&#34;&#34;

        self._equations_map: dict[tuple[str, int], list[tuple[str, int]]] = dict()
        &#34;&#34;&#34;
        This is a map from RHS variable identifiers to LHS equation identifiers.
        Each RHS and LHS identifier is a tuple: a string, identifying the vector
        name (eg: x1l or zer) and an integer, identifying the string index.
        &#34;&#34;&#34;

        rows: pd.DataFrame = pd.read_csv(self.configuration.eqnmap_file, header=None)
        rows.columns = [&#39;name&#39;, &#39;number&#39;]
        # Remove &#39;par&#39; RHS entries - they are not needed.
        rows = rows.loc[~(rows.name == &#39;par&#39;), :]

        lhs: tuple[str, int] = None
        rhs: tuple[str, int] = None

        equationCount = 0
        for row in rows.itertuples(index=False):
            if row[0].endswith(&#39;l&#39;):
                equationCount = equationCount + 1
                lhs = (row[0], int(row[1]))
                rhs = None
                continue
            else:
                rhs = (row[0], int(row[1]))

            if rhs is None:
                continue

            if rhs in self._equations_map:
                self._equations_map[rhs].append(lhs)
            else:
                self._equations_map[rhs] = [lhs]

    def __compute_partial_derivatives(self):
        &#34;&#34;&#34;
        ### Overview

        Generate the matrices that reflect the linear approximation
        to the model. The model is linearised around the data for 
        a specific year that is specified in the model configuration.

        Do not compute partial derivatives for any vectors with zero length.

        Use the equation map to ensure that only non-zero partial derivatives
        are calculated. The others are, obviously, zero.
        &#34;&#34;&#34;

        # Create the dictionary where the partial derivative matrices will be stored.
        self._partial_derivatives: dict[tuple[str, str], np.ndarray] = dict()

        # Initialise the matrices of partial derivatives

        for lhs in self.sym_data.lhs_vector_names:
            lhs_length = self.sym_data.vector_length(vector_name=lhs)
            if lhs_length == 0:
                continue

            for rhs in self.sym_data.rhs_vector_names:
                rhs_length = self.sym_data.vector_length(vector_name=rhs)
                if rhs_length == 0:
                    continue
                self._partial_derivatives[(lhs, rhs)] = np.zeros((lhs_length, rhs_length), dtype=float)

        for rhs in self.sym_data.rhs_vector_names:

            start_time: float = time.time()

            rhs_length = self.sym_data.vector_length(vector_name=rhs)
            if rhs_length == 0:
                continue

            # Get the vector of RHS variables in the named rhs vector
            rhs_vector = self.get_vector_by_name(vector_name=rhs)
            
            for rhs_index in range(rhs_length):

                 if (rhs, rhs_index) in self._equations_map:

                    original_RHS_value: float = rhs_vector[rhs_index].copy()

                    # Compute the partial by incrementing by delta then restore original value.
                    rhs_vector[rhs_index] = original_RHS_value + Constants().DELTA

                    # Iterate all equations that use the RHS variable to compute the partial derivatives.
                    for (lhs, lhs_index) in self._equations_map[(rhs, rhs_index)]:

                        # Run the relevant function to evaluate the model equation 
                        # at the adjusted RHS variable value.
                        func = getattr(self.equations, f&#34;{lhs}_{lhs_index}&#34;)
                        func()

                        perturbed_LHS_value: float = self.get_vector_by_name(vector_name=lhs)[lhs_index]
                        original_LHS_value: float = self.get_original_lhs_vector_by_name(lhs_vector_name=lhs)[lhs_index]
                        partial_derivative: float = ((perturbed_LHS_value - original_LHS_value) / Constants().DELTA)

                        # Store the value of the derivative in the partial derivatives matrix at the
                        # appropriate row and column index.
                        self.get_partials(lhs_vector_name=lhs, rhs_vector_name=rhs)[lhs_index, rhs_index] = partial_derivative

                    rhs_vector[rhs_index] = original_RHS_value

            elapsed_time: float = time.time()- start_time
            if elapsed_time &gt; 5:
                execution_time: str = &#34;{:.3f}&#34;.format(elapsed_time)
                logging.info(f&#34;Partial derivatives wrt variables in the {rhs} vector took {execution_time} seconds to calculate.&#34;)


        self._linear_model_is_available = True

    def __generate_nonlinear_equation_differences(self):
        &#34;&#34;&#34;
        ### Overview
        
        Generate a report of the differences between observed values and 
        non-linear equation solutions used in model linearisation.
        &#34;&#34;&#34;
        x1_diff: pd.DataFrame = pd.DataFrame(np.hstack((self._x1r,self._x1l, self._x1r - self._x1l)))
        x1_diff.index = self.model.sym_data.vector_variable_names(vector_name=&#39;x1l&#39;)
        x1_diff.columns = [&#39;rhs&#39;, &#39;lhs&#39;, &#39;rhs_minus_lhs&#39;]
        j1_diff: pd.DataFrame = pd.DataFrame(np.hstack((self._j1r, self._j1l, self._j1r - self._j1l)))
        j1_diff.index = self.model.sym_data.vector_variable_names(vector_name=&#39;j1l&#39;)
        j1_diff.columns = [&#39;rhs&#39;, &#39;lhs&#39;, &#39;rhs_minus_lhs&#39;]
        ze_diff: pd.DataFrame = pd.DataFrame(np.hstack((self._zer, self._zer, self._zer - self._zel)))
        ze_diff.index = self.model.sym_data.vector_variable_names(vector_name=&#39;zel&#39;)
        ze_diff.columns = [&#39;rhs&#39;, &#39;lhs&#39;, &#39;rhs_minus_lhs&#39;]
        z1_diff: pd.DataFrame = pd.DataFrame(np.hstack((self._z1r, self._z1l, self._z1r - self._z1l)))
        z1_diff.index = self.model.sym_data.vector_variable_names(vector_name=&#39;z1l&#39;)
        z1_diff.columns = [&#39;rhs&#39;, &#39;lhs&#39;, &#39;rhs_minus_lhs&#39;]
        exo_diff: pd.DataFrame = pd.DataFrame(index=self.model.sym_data.vector_variable_names(vector_name=&#39;exo&#39;), columns=[&#39;rhs&#39;, &#39;lhs&#39;, &#39;rhs_minus_lhs&#39;])
        exo_diff.loc[:,&#39;rhs&#39;] = self._exo
        exo_diff.loc[:, &#39;lhs&#39;] = self._exo
        exo_diff.loc[:, &#39;rhs_minus_lhs&#39;] = 0
        diffs = pd.concat([
            x1_diff,
            j1_diff,
            ze_diff,
            z1_diff,
            exo_diff])
        database_ordered_variable_list: pd.DataFrame = self.linearisation_database.variables.name
        self._nonlinear_equation_differences = pd.concat([database_ordered_variable_list, diffs], axis=1)
        self._nonlinear_equation_differences.drop(&#39;name&#39;, inplace=True, axis=1)
        self._nonlinear_equation_differences.insert(loc=0, column=&#39;vector&#39;, value=self.sym_data.combined_variable_summary.loc[:, &#39;vector&#39;])
        self._nonlinear_equation_differences = self._nonlinear_equation_differences.loc[self._nonlinear_equation_differences.vector != &#39;exo&#39;, :]

    @property
    def nonlinear_equation_differences(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Details about the differences between the LHS and RHS values for all
        endogenous variables as at the point of linearisation. This is only used for unit testing
        purposes.
        &#34;&#34;&#34;
        self.__generate_nonlinear_equation_differences()
        return self._nonlinear_equation_differences</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gcubed.linearisation.linear_model.LinearModel"><code class="flex name class">
<span>class <span class="ident">LinearModel</span></span>
<span>(</span><span>model: <a title="gcubed.model.Model" href="../model.html#gcubed.model.Model">Model</a>)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="overview">Overview</h3>
<p>The algebra embodied in this class follows
<a href="https://www.msgpl.com.au/Manuals2021/GGGv20JManual/softwaremanual/algorithm.pdf">https://www.msgpl.com.au/Manuals2021/GGGv20JManual/softwaremanual/algorithm.pdf</a></p>
<p>The notation has been extended to also include equations for
expected endogenous variables to include exogenous variables.</p>
<p>This class provides the ability to work with the model equations. It:</p>
<ol>
<li>Computes the partial derivatives of the model equations
so that an approximation of the model can be expressed as
a set of linear equations.</li>
<li>Constructs the matrices of constants associated with the
state-space form of the linearised model. This involves eliminating
the endogenous variables from the model via substitution.</li>
</ol>
<p>To use this class:</p>
<ol>
<li>instantiate it with a model.</li>
<li>run the __compute_partial_derivatives() method.</li>
</ol>
<p>Once this sequence of steps has been completed without raising an exception,
the matrices associated with the state space form will be accessible
as properties of the linear model to support solving the model.</p>
<p>Instantiation determines the values for the RHS variable vectors
based upon the model's database and the year that has been chosen
to determine the variable values that the model will be linearised
around.</p>
<p>These RHS variable vector values, and the implied LHS variable vector values
are exposed as properties of the linear model. The names of these vector
properties are 3 character acronyms:</p>
<p>The linear model supports evaluation of the model equations to obtain
values for the LHS and RHS vectors of variables defined in sym_data.</p>
<p>To understanding the naming conventions, the partial
derivatives matrix associated with the partials of
x1l with respect to z1r are stored in a property called x1l_z1r_partials.
The same naming convention is used for all partials matrices:
<LHS_vector_name>_<RHS_vector_name>_partials.</p>
<h3 id="arguments">Arguments</h3>
<p>model: The model that is to be linearised with the linearisation
year specified as part of the model configuration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LinearModel(Base):
    &#34;&#34;&#34;

    ### Overview
    
    The algebra embodied in this class follows 
    https://www.msgpl.com.au/Manuals2021/GGGv20JManual/softwaremanual/algorithm.pdf
    
    The notation has been extended to also include equations for 
    expected endogenous variables to include exogenous variables.

    This class provides the ability to work with the model equations. It:

    1. Computes the partial derivatives of the model equations
    so that an approximation of the model can be expressed as 
    a set of linear equations.
    2. Constructs the matrices of constants associated with the 
    state-space form of the linearised model. This involves eliminating
    the endogenous variables from the model via substitution.

    To use this class:

    1.  instantiate it with a model.
    2.  run the __compute_partial_derivatives() method.

    Once this sequence of steps has been completed without raising an exception,
    the matrices associated with the state space form will be accessible
    as properties of the linear model to support solving the model.

    Instantiation determines the values for the RHS variable vectors
    based upon the model&#39;s database and the year that has been chosen
    to determine the variable values that the model will be linearised 
    around.

    These RHS variable vector values, and the implied LHS variable vector values 
    are exposed as properties of the linear model. The names of these vector 
    properties are 3 character acronyms:

    The linear model supports evaluation of the model equations to obtain
    values for the LHS and RHS vectors of variables defined in sym_data.

    To understanding the naming conventions, the partial 
    derivatives matrix associated with the partials of
    x1l with respect to z1r are stored in a property called x1l_z1r_partials.
    The same naming convention is used for all partials matrices:
    &lt;LHS_vector_name&gt;_&lt;RHS_vector_name&gt;_partials.
    &#34;&#34;&#34;

    def __init__(self, model: Model) -&gt; None:
        &#34;&#34;&#34;
        ### Arguments

        model: The model that is to be linearised with the linearisation
        year specified as part of the model configuration.
        &#34;&#34;&#34;

        # Set this switch to true when the partial derivatives have been computed.
        self._linear_model_is_available: bool = False

        assert model is not None
        self._model = model

        logging.info(f&#34;Linearising the model using data with a base year of {self.configuration.linearisation_year}&#34;)
        self._linearisation_database = GDPScaledDatabase(database=self.model.database, base_year=self.configuration.linearisation_year)

        # Set up the LHS vectors as vectors of zeros.
        self.__configure_lhs_vectors()
        
        # Set up the RHS vectors for the model using data for the linearisation year.
        # First check which linearisation approach to use.
        if not self.model.configuration.linearise_around_strict_model_solution:
            # Do the standard kind of linearisation
            self.__load_rhs_vectors(linearisation_year=self.configuration.linearisation_year)
        else:
            # Do the fancy linearisation where we search for a strict solution to the model first.
            model_solver: ModelSolver = ModelSolver(model=self.model, linearisation_year=self.configuration.linearisation_year)
            if not model_solver.solution_found:
                raise Exception(f&#34;Failed to find a solution to the model for data values near those in the database for linearisation year {self.configuration.linearisation_year}. Linearisation cannot proceed.&#34;)
            for vector_name in self.sym_data.rhs_vector_names:
                rhs_vector:pd.DataFrame = getattr(model_solver, f&#34;_{vector_name}&#34;)
                if rhs_vector is not None:
                    setattr(self, f&#34;_{vector_name}&#34;, rhs_vector)
                else:
                    raise Exception(f&#34;Failed to get RHS vector {vector_name} from the solved model.&#34;)


        # Import the model equations.
        sys.path.append(self.configuration.sym_directory)
        equations_module = importlib.import_module(self.configuration.sym_output_filename_prefix)
        equations_class = getattr(equations_module, &#34;Equations&#34;)
        self._equations = equations_class(x1l=self._x1l,
                                          j1l=self._j1l,
                                          zel=self._zel,
                                          z1l=self._z1l,
                                          x1r=self._x1r,
                                          j1r=self._j1r,
                                          z1r=self._z1r,
                                          zer=self._zer,
                                          yjr=self._yjr,
                                          yxr=self._yxr,
                                          exo=self._exo,
                                          exz=self._exz,
                                          par=self.model.parameters.parameter_values_vector)

        # Solve for LHS vectors using the model equations,
        # the parameters and the RHS vectors. Store the results as benchmark
        # values for calculating partial derivatives.
        self.__compute_benchmark_equation_results()

        # Generate differences in LHS variables from those used on RHS to evaluate equations
        # These two lines of code do not typically need to run but give insight into linearisation.
        # self.__generate_nonlinear_equation_differences()
        # self.nonlinear_equation_differences.to_csv(f&#34;{self.model.configuration.benchmarking_reports_directory}nonlinear equation LHS-RHS differences.csv&#34;)

        # Load the map from RHS variables to model equations to use when computing partial derivatives.
        self.__load_equation_map()

        # Compute the partial derivatives
        self.__compute_partial_derivatives()

        self.__validate()

    def __validate(self):
        &#34;&#34;&#34;
        Validate the linear model details and 
        &#34;&#34;&#34;

        # Check we have all vectors and they are the right lengths.
        for vector_name in self.sym_data.lhs_vector_names:
            vector = self.get_vector_by_name(vector_name=vector_name)
            assert vector is not None
            assert len(vector) == self.sym_data.vector_length(
                vector_name=vector_name)

        if self.linear_model_is_available:
            logging.info(&#34;The model has been linearised.&#34;)
        else:
            logging.error(&#34;The model linearisation failed. Changes are required before proceeding.&#34;)

    @property
    def linearisation_database(self) -&gt; GDPScaledDatabase:
        &#34;&#34;&#34;
        linearisation_database (GDPScaledDatabase): The database 
        containing the values that will be utilised to populate 
        variable values for the linearisation.
        &#34;&#34;&#34;
        return self._linearisation_database

    @property
    def linear_model_is_available(self) -&gt; bool:
        &#34;&#34;&#34;
        linear_model_is_available (bool): True if the model has been linearised 
        successfully and False otherwise (either because linearisation has not
        finished or linearisation was not possible for whatever reason).
        &#34;&#34;&#34;
        return self._linear_model_is_available

    @property
    def equations(self):
        &#34;&#34;&#34;
        (BaseEquations): The equations subclass instance that implements the functions
        for each of the nonlinear equations in the model.
        &#34;&#34;&#34;
        return self._equations

    @property
    def model(self):
        &#34;&#34;&#34;
        (Model): The model being linearised.
        &#34;&#34;&#34;
        return self._model

    @property
    def sym_data(self) -&gt; SymData:
        &#34;&#34;&#34;
        The SYM data for the model being linearised.
        &#34;&#34;&#34;
        return self.model.sym_data

    @property
    def configuration(self) -&gt; ModelConfiguration:
        &#34;&#34;&#34;
        The configuration details for the model 
        being linearised.
        &#34;&#34;&#34;
        return self.model.configuration

    @property
    def equations_map(self) -&gt; dict[tuple[str, int], list[tuple[str, int]]]:
        &#34;&#34;&#34;
        ### Overview

        This is only a public property to assist with unit testing.
        Do not use it directly for other purposes.

        The map is populated from the SYM processor output and is used to make
        the calculation of partial derivatives more efficient, only calculating
        those derivatives that are not zero by definition.

        ### Returns

        The map from each RHS variable in the model to the list of 
        LHS variables (equations) that depend on it.
        &#34;&#34;&#34;
        return self._equations_map

    def get_vector_by_name(self, vector_name) -&gt; np.ndarray:
        &#34;&#34;&#34;
        ### Overview

        Use the name of the vector to retrieve its numpy array value.
        These values have been set using data in the database.

        ### Arguments

        vector_name: The name of the LHS or RHS vector.
        
        ### Returns
        
        The named column vector.
        
        &#34;&#34;&#34;
        if not hasattr(self, &#34;_{}&#34;.format(vector_name)):
            raise Exception(&#34;There is no vector for {}&#34;.format(vector_name))
        return getattr(self, &#34;_{}&#34;.format(vector_name))

    def get_original_lhs_vector_by_name(self, lhs_vector_name:str) -&gt; np.ndarray:
        &#34;&#34;&#34;

        ### Overview

        This function is useful for benchmarking the model&#39;s nonlinear equation evaluations.

        Use the name of the vector to retrieve its numpy array value.
        These values have been set by evaluating the model&#39;s non-linear equations
        using the RHS vector values for the base year chosen for the linearisation.

        ### Arguments

        lhs_vector_name: The name of the LHS vector, e.g. &#39;x1l&#39; or &#39;j1l&#39;.
        
        ### Returns
        
        The named LHS column vector.

        &#34;&#34;&#34;
        if not lhs_vector_name in self._original_lhs_vectors:
            raise Exception(f&#34;The requested vector, {lhs_vector_name}, is not a LHS vector in the model.&#34;)
        return self._original_lhs_vectors[lhs_vector_name]

    def get_partials(self, lhs_vector_name:str, rhs_vector_name:str) -&gt; np.ndarray:
        &#34;&#34;&#34;

        ### Overview

        Use the name of the LHS vector and the RHS vector to retrieve 
        the numpy matrix value for the partial derivatives.

        The matrices of partial derivatives are stored in a dictionary indexed
        by the lhs and rhs vector names.

        ### Arguments

        lhs_vector_name: The name of the LHS vector, e.g. &#39;x1l&#39; or &#39;j1l&#39;.

        rhs_vector_name: The name of the RHS vector, e.g. &#39;yxr&#39; or &#39;j1r&#39;.

        ### Returns
        
        The required partial derivatives as a dataframe 
        with variable names as the row and column labels.

        &#34;&#34;&#34;
        if self._partial_derivatives is None:
            raise Exception(f&#34;Attempted to access partial derivatives {lhs_vector_name} on {rhs_vector_name} before it was created.&#34;)
        key = (lhs_vector_name, rhs_vector_name)
        if key in self._partial_derivatives:
            return self._partial_derivatives[key]
        return None

    def get_partials_as_dataframe(self, lhs_vector_name, rhs_vector_name) -&gt; pd.DataFrame:
        &#34;&#34;&#34;

        ### Arguments

        lhs_vector_name: The name of the LHS vector, e.g. &#39;x1l&#39; or &#39;j1l&#39;.

        rhs_vector_name: The name of the RHS vector, e.g. &#39;yxr&#39; or &#39;j1r&#39;.

        ### Returns
        
        The required partial derivatives as a dataframe 
        with variable names as the row and column labels.

        &#34;&#34;&#34;
        if self._partial_derivatives is None:
            raise Exception(f&#34;Attempted to access partial derivatives {lhs_vector_name} on {rhs_vector_name} before it was created.&#34;)
        key = (lhs_vector_name, rhs_vector_name)
        if key in self._partial_derivatives:
            result: pd.DataFrame = pd.DataFrame(self._partial_derivatives[key])
            result.index = self.sym_data.vector_variable_names(vector_name=lhs_vector_name)
            result.columns = self.sym_data.vector_variable_names(vector_name=rhs_vector_name)
            return result
        return None

    def __configure_lhs_vectors(self):
        &#34;&#34;&#34;
        ### Overview

        Create the LHS vectors that are used by the model equations.
        Initialise LHS vectors with zeros.
        &#34;&#34;&#34;
        for vector_name in self.sym_data.lhs_vector_names:
            setattr(self, &#34;_{}&#34;.format(vector_name), np.zeros(
                shape=(self.sym_data.vector_length(vector_name=vector_name), 1), dtype=float))

    def __load_rhs_vectors(self, linearisation_year: int):
        &#34;&#34;&#34;

        ### Overview

        Create and set values for the RHS vectors that are used by the 
        model equations.

        Do not create vectors if they have no variables (are zero length).

        ### Arguments

        linearisation_year: The year in which the model is linearised.
        e.g. 2011 implies linearise model equations around the values
        of the model variables in 2011 (or in adjacent years for leads/lags).
        
        &#34;&#34;&#34;
        # Initialise RHS vectors with database values from the linearisation base year or the lead/lag from that year.
        for vector_name in self.sym_data.rhs_vector_names:
            rhs_vector:pd.DataFrame = self.linearisation_database.rhs_vector_value(vector_name=vector_name, year=linearisation_year, use_neutral_real_interest_rate=True)
            if rhs_vector is not None:
                setattr(self, f&#34;_{vector_name}&#34;, rhs_vector)
            else:
                raise Exception(f&#34;Failed to get RHS vector {vector_name} from the linearisation database.&#34;)

    def __compute_benchmark_equation_results(self):
        &#34;&#34;&#34;
        ### Overview

        Compute the benchmark LHS vector values using supplied RHS values.
        These are used in computing the non-linear equations in the model.
        &#34;&#34;&#34;

        self._original_lhs_vectors: dict[str, np.ndarray] = dict()
        for lhs_vector_name in self.sym_data.lhs_vector_names:
            lhs_vector = getattr(self, &#34;_{}&#34;.format(lhs_vector_name))
            for lhs_index in range(len(lhs_vector)):
                function_name = &#34;{}_{}&#34;.format(lhs_vector_name, lhs_index)
                if hasattr(self.equations, function_name):
                    func = getattr(self.equations, function_name)
                    func()
                else:
                    # logging.warning(&#34;No {} equation for element {}&#34;.format(lhs_vector_name, lhs_index))
                    pass
            self._original_lhs_vectors[lhs_vector_name] = lhs_vector.copy()

    def __load_equation_map(self):
        &#34;&#34;&#34;
        ### Overview

        Uses the eqnmap output from the sym processor to create a map from each
        RHS variable (vector + index combination) to the equations that include
        that variable on the RHS.

        This map ensures we only have to evaluate the relevant equations when computing
        the partial derivatives of the model equations when considering each RHS variable.
        &#34;&#34;&#34;

        self._equations_map: dict[tuple[str, int], list[tuple[str, int]]] = dict()
        &#34;&#34;&#34;
        This is a map from RHS variable identifiers to LHS equation identifiers.
        Each RHS and LHS identifier is a tuple: a string, identifying the vector
        name (eg: x1l or zer) and an integer, identifying the string index.
        &#34;&#34;&#34;

        rows: pd.DataFrame = pd.read_csv(self.configuration.eqnmap_file, header=None)
        rows.columns = [&#39;name&#39;, &#39;number&#39;]
        # Remove &#39;par&#39; RHS entries - they are not needed.
        rows = rows.loc[~(rows.name == &#39;par&#39;), :]

        lhs: tuple[str, int] = None
        rhs: tuple[str, int] = None

        equationCount = 0
        for row in rows.itertuples(index=False):
            if row[0].endswith(&#39;l&#39;):
                equationCount = equationCount + 1
                lhs = (row[0], int(row[1]))
                rhs = None
                continue
            else:
                rhs = (row[0], int(row[1]))

            if rhs is None:
                continue

            if rhs in self._equations_map:
                self._equations_map[rhs].append(lhs)
            else:
                self._equations_map[rhs] = [lhs]

    def __compute_partial_derivatives(self):
        &#34;&#34;&#34;
        ### Overview

        Generate the matrices that reflect the linear approximation
        to the model. The model is linearised around the data for 
        a specific year that is specified in the model configuration.

        Do not compute partial derivatives for any vectors with zero length.

        Use the equation map to ensure that only non-zero partial derivatives
        are calculated. The others are, obviously, zero.
        &#34;&#34;&#34;

        # Create the dictionary where the partial derivative matrices will be stored.
        self._partial_derivatives: dict[tuple[str, str], np.ndarray] = dict()

        # Initialise the matrices of partial derivatives

        for lhs in self.sym_data.lhs_vector_names:
            lhs_length = self.sym_data.vector_length(vector_name=lhs)
            if lhs_length == 0:
                continue

            for rhs in self.sym_data.rhs_vector_names:
                rhs_length = self.sym_data.vector_length(vector_name=rhs)
                if rhs_length == 0:
                    continue
                self._partial_derivatives[(lhs, rhs)] = np.zeros((lhs_length, rhs_length), dtype=float)

        for rhs in self.sym_data.rhs_vector_names:

            start_time: float = time.time()

            rhs_length = self.sym_data.vector_length(vector_name=rhs)
            if rhs_length == 0:
                continue

            # Get the vector of RHS variables in the named rhs vector
            rhs_vector = self.get_vector_by_name(vector_name=rhs)
            
            for rhs_index in range(rhs_length):

                 if (rhs, rhs_index) in self._equations_map:

                    original_RHS_value: float = rhs_vector[rhs_index].copy()

                    # Compute the partial by incrementing by delta then restore original value.
                    rhs_vector[rhs_index] = original_RHS_value + Constants().DELTA

                    # Iterate all equations that use the RHS variable to compute the partial derivatives.
                    for (lhs, lhs_index) in self._equations_map[(rhs, rhs_index)]:

                        # Run the relevant function to evaluate the model equation 
                        # at the adjusted RHS variable value.
                        func = getattr(self.equations, f&#34;{lhs}_{lhs_index}&#34;)
                        func()

                        perturbed_LHS_value: float = self.get_vector_by_name(vector_name=lhs)[lhs_index]
                        original_LHS_value: float = self.get_original_lhs_vector_by_name(lhs_vector_name=lhs)[lhs_index]
                        partial_derivative: float = ((perturbed_LHS_value - original_LHS_value) / Constants().DELTA)

                        # Store the value of the derivative in the partial derivatives matrix at the
                        # appropriate row and column index.
                        self.get_partials(lhs_vector_name=lhs, rhs_vector_name=rhs)[lhs_index, rhs_index] = partial_derivative

                    rhs_vector[rhs_index] = original_RHS_value

            elapsed_time: float = time.time()- start_time
            if elapsed_time &gt; 5:
                execution_time: str = &#34;{:.3f}&#34;.format(elapsed_time)
                logging.info(f&#34;Partial derivatives wrt variables in the {rhs} vector took {execution_time} seconds to calculate.&#34;)


        self._linear_model_is_available = True

    def __generate_nonlinear_equation_differences(self):
        &#34;&#34;&#34;
        ### Overview
        
        Generate a report of the differences between observed values and 
        non-linear equation solutions used in model linearisation.
        &#34;&#34;&#34;
        x1_diff: pd.DataFrame = pd.DataFrame(np.hstack((self._x1r,self._x1l, self._x1r - self._x1l)))
        x1_diff.index = self.model.sym_data.vector_variable_names(vector_name=&#39;x1l&#39;)
        x1_diff.columns = [&#39;rhs&#39;, &#39;lhs&#39;, &#39;rhs_minus_lhs&#39;]
        j1_diff: pd.DataFrame = pd.DataFrame(np.hstack((self._j1r, self._j1l, self._j1r - self._j1l)))
        j1_diff.index = self.model.sym_data.vector_variable_names(vector_name=&#39;j1l&#39;)
        j1_diff.columns = [&#39;rhs&#39;, &#39;lhs&#39;, &#39;rhs_minus_lhs&#39;]
        ze_diff: pd.DataFrame = pd.DataFrame(np.hstack((self._zer, self._zer, self._zer - self._zel)))
        ze_diff.index = self.model.sym_data.vector_variable_names(vector_name=&#39;zel&#39;)
        ze_diff.columns = [&#39;rhs&#39;, &#39;lhs&#39;, &#39;rhs_minus_lhs&#39;]
        z1_diff: pd.DataFrame = pd.DataFrame(np.hstack((self._z1r, self._z1l, self._z1r - self._z1l)))
        z1_diff.index = self.model.sym_data.vector_variable_names(vector_name=&#39;z1l&#39;)
        z1_diff.columns = [&#39;rhs&#39;, &#39;lhs&#39;, &#39;rhs_minus_lhs&#39;]
        exo_diff: pd.DataFrame = pd.DataFrame(index=self.model.sym_data.vector_variable_names(vector_name=&#39;exo&#39;), columns=[&#39;rhs&#39;, &#39;lhs&#39;, &#39;rhs_minus_lhs&#39;])
        exo_diff.loc[:,&#39;rhs&#39;] = self._exo
        exo_diff.loc[:, &#39;lhs&#39;] = self._exo
        exo_diff.loc[:, &#39;rhs_minus_lhs&#39;] = 0
        diffs = pd.concat([
            x1_diff,
            j1_diff,
            ze_diff,
            z1_diff,
            exo_diff])
        database_ordered_variable_list: pd.DataFrame = self.linearisation_database.variables.name
        self._nonlinear_equation_differences = pd.concat([database_ordered_variable_list, diffs], axis=1)
        self._nonlinear_equation_differences.drop(&#39;name&#39;, inplace=True, axis=1)
        self._nonlinear_equation_differences.insert(loc=0, column=&#39;vector&#39;, value=self.sym_data.combined_variable_summary.loc[:, &#39;vector&#39;])
        self._nonlinear_equation_differences = self._nonlinear_equation_differences.loc[self._nonlinear_equation_differences.vector != &#39;exo&#39;, :]

    @property
    def nonlinear_equation_differences(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Details about the differences between the LHS and RHS values for all
        endogenous variables as at the point of linearisation. This is only used for unit testing
        purposes.
        &#34;&#34;&#34;
        self.__generate_nonlinear_equation_differences()
        return self._nonlinear_equation_differences</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gcubed.base.Base" href="../base.html#gcubed.base.Base">Base</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="gcubed.linearisation.linear_model.LinearModel.configuration"><code class="name">var <span class="ident">configuration</span> : <a title="gcubed.model_configuration.ModelConfiguration" href="../model_configuration.html#gcubed.model_configuration.ModelConfiguration">ModelConfiguration</a></code></dt>
<dd>
<div class="desc"><p>The configuration details for the model
being linearised.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def configuration(self) -&gt; ModelConfiguration:
    &#34;&#34;&#34;
    The configuration details for the model 
    being linearised.
    &#34;&#34;&#34;
    return self.model.configuration</code></pre>
</details>
</dd>
<dt id="gcubed.linearisation.linear_model.LinearModel.equations"><code class="name">var <span class="ident">equations</span></code></dt>
<dd>
<div class="desc"><p>(BaseEquations): The equations subclass instance that implements the functions
for each of the nonlinear equations in the model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def equations(self):
    &#34;&#34;&#34;
    (BaseEquations): The equations subclass instance that implements the functions
    for each of the nonlinear equations in the model.
    &#34;&#34;&#34;
    return self._equations</code></pre>
</details>
</dd>
<dt id="gcubed.linearisation.linear_model.LinearModel.equations_map"><code class="name">var <span class="ident">equations_map</span> : dict[tuple[str, int], list[tuple[str, int]]]</code></dt>
<dd>
<div class="desc"><h3 id="overview">Overview</h3>
<p>This is only a public property to assist with unit testing.
Do not use it directly for other purposes.</p>
<p>The map is populated from the SYM processor output and is used to make
the calculation of partial derivatives more efficient, only calculating
those derivatives that are not zero by definition.</p>
<h3 id="returns">Returns</h3>
<p>The map from each RHS variable in the model to the list of
LHS variables (equations) that depend on it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def equations_map(self) -&gt; dict[tuple[str, int], list[tuple[str, int]]]:
    &#34;&#34;&#34;
    ### Overview

    This is only a public property to assist with unit testing.
    Do not use it directly for other purposes.

    The map is populated from the SYM processor output and is used to make
    the calculation of partial derivatives more efficient, only calculating
    those derivatives that are not zero by definition.

    ### Returns

    The map from each RHS variable in the model to the list of 
    LHS variables (equations) that depend on it.
    &#34;&#34;&#34;
    return self._equations_map</code></pre>
</details>
</dd>
<dt id="gcubed.linearisation.linear_model.LinearModel.linear_model_is_available"><code class="name">var <span class="ident">linear_model_is_available</span> : bool</code></dt>
<dd>
<div class="desc"><p>linear_model_is_available (bool): True if the model has been linearised
successfully and False otherwise (either because linearisation has not
finished or linearisation was not possible for whatever reason).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def linear_model_is_available(self) -&gt; bool:
    &#34;&#34;&#34;
    linear_model_is_available (bool): True if the model has been linearised 
    successfully and False otherwise (either because linearisation has not
    finished or linearisation was not possible for whatever reason).
    &#34;&#34;&#34;
    return self._linear_model_is_available</code></pre>
</details>
</dd>
<dt id="gcubed.linearisation.linear_model.LinearModel.linearisation_database"><code class="name">var <span class="ident">linearisation_database</span> : <a title="gcubed.data.gdp_scaled_database.GDPScaledDatabase" href="../data/gdp_scaled_database.html#gcubed.data.gdp_scaled_database.GDPScaledDatabase">GDPScaledDatabase</a></code></dt>
<dd>
<div class="desc"><p>linearisation_database (GDPScaledDatabase): The database
containing the values that will be utilised to populate
variable values for the linearisation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def linearisation_database(self) -&gt; GDPScaledDatabase:
    &#34;&#34;&#34;
    linearisation_database (GDPScaledDatabase): The database 
    containing the values that will be utilised to populate 
    variable values for the linearisation.
    &#34;&#34;&#34;
    return self._linearisation_database</code></pre>
</details>
</dd>
<dt id="gcubed.linearisation.linear_model.LinearModel.model"><code class="name">var <span class="ident">model</span></code></dt>
<dd>
<div class="desc"><p>(Model): The model being linearised.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def model(self):
    &#34;&#34;&#34;
    (Model): The model being linearised.
    &#34;&#34;&#34;
    return self._model</code></pre>
</details>
</dd>
<dt id="gcubed.linearisation.linear_model.LinearModel.nonlinear_equation_differences"><code class="name">var <span class="ident">nonlinear_equation_differences</span> : pandas.core.frame.DataFrame</code></dt>
<dd>
<div class="desc"><p>Details about the differences between the LHS and RHS values for all
endogenous variables as at the point of linearisation. This is only used for unit testing
purposes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def nonlinear_equation_differences(self) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Details about the differences between the LHS and RHS values for all
    endogenous variables as at the point of linearisation. This is only used for unit testing
    purposes.
    &#34;&#34;&#34;
    self.__generate_nonlinear_equation_differences()
    return self._nonlinear_equation_differences</code></pre>
</details>
</dd>
<dt id="gcubed.linearisation.linear_model.LinearModel.sym_data"><code class="name">var <span class="ident">sym_data</span> : <a title="gcubed.sym_data.SymData" href="../sym_data.html#gcubed.sym_data.SymData">SymData</a></code></dt>
<dd>
<div class="desc"><p>The SYM data for the model being linearised.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sym_data(self) -&gt; SymData:
    &#34;&#34;&#34;
    The SYM data for the model being linearised.
    &#34;&#34;&#34;
    return self.model.sym_data</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="gcubed.linearisation.linear_model.LinearModel.get_original_lhs_vector_by_name"><code class="name flex">
<span>def <span class="ident">get_original_lhs_vector_by_name</span></span>(<span>self, lhs_vector_name: str) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><h3 id="overview">Overview</h3>
<p>This function is useful for benchmarking the model's nonlinear equation evaluations.</p>
<p>Use the name of the vector to retrieve its numpy array value.
These values have been set by evaluating the model's non-linear equations
using the RHS vector values for the base year chosen for the linearisation.</p>
<h3 id="arguments">Arguments</h3>
<p>lhs_vector_name: The name of the LHS vector, e.g. 'x1l' or 'j1l'.</p>
<h3 id="returns">Returns</h3>
<p>The named LHS column vector.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_original_lhs_vector_by_name(self, lhs_vector_name:str) -&gt; np.ndarray:
    &#34;&#34;&#34;

    ### Overview

    This function is useful for benchmarking the model&#39;s nonlinear equation evaluations.

    Use the name of the vector to retrieve its numpy array value.
    These values have been set by evaluating the model&#39;s non-linear equations
    using the RHS vector values for the base year chosen for the linearisation.

    ### Arguments

    lhs_vector_name: The name of the LHS vector, e.g. &#39;x1l&#39; or &#39;j1l&#39;.
    
    ### Returns
    
    The named LHS column vector.

    &#34;&#34;&#34;
    if not lhs_vector_name in self._original_lhs_vectors:
        raise Exception(f&#34;The requested vector, {lhs_vector_name}, is not a LHS vector in the model.&#34;)
    return self._original_lhs_vectors[lhs_vector_name]</code></pre>
</details>
</dd>
<dt id="gcubed.linearisation.linear_model.LinearModel.get_partials"><code class="name flex">
<span>def <span class="ident">get_partials</span></span>(<span>self, lhs_vector_name: str, rhs_vector_name: str) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><h3 id="overview">Overview</h3>
<p>Use the name of the LHS vector and the RHS vector to retrieve
the numpy matrix value for the partial derivatives.</p>
<p>The matrices of partial derivatives are stored in a dictionary indexed
by the lhs and rhs vector names.</p>
<h3 id="arguments">Arguments</h3>
<p>lhs_vector_name: The name of the LHS vector, e.g. 'x1l' or 'j1l'.</p>
<p>rhs_vector_name: The name of the RHS vector, e.g. 'yxr' or 'j1r'.</p>
<h3 id="returns">Returns</h3>
<p>The required partial derivatives as a dataframe
with variable names as the row and column labels.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_partials(self, lhs_vector_name:str, rhs_vector_name:str) -&gt; np.ndarray:
    &#34;&#34;&#34;

    ### Overview

    Use the name of the LHS vector and the RHS vector to retrieve 
    the numpy matrix value for the partial derivatives.

    The matrices of partial derivatives are stored in a dictionary indexed
    by the lhs and rhs vector names.

    ### Arguments

    lhs_vector_name: The name of the LHS vector, e.g. &#39;x1l&#39; or &#39;j1l&#39;.

    rhs_vector_name: The name of the RHS vector, e.g. &#39;yxr&#39; or &#39;j1r&#39;.

    ### Returns
    
    The required partial derivatives as a dataframe 
    with variable names as the row and column labels.

    &#34;&#34;&#34;
    if self._partial_derivatives is None:
        raise Exception(f&#34;Attempted to access partial derivatives {lhs_vector_name} on {rhs_vector_name} before it was created.&#34;)
    key = (lhs_vector_name, rhs_vector_name)
    if key in self._partial_derivatives:
        return self._partial_derivatives[key]
    return None</code></pre>
</details>
</dd>
<dt id="gcubed.linearisation.linear_model.LinearModel.get_partials_as_dataframe"><code class="name flex">
<span>def <span class="ident">get_partials_as_dataframe</span></span>(<span>self, lhs_vector_name, rhs_vector_name) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><h3 id="arguments">Arguments</h3>
<p>lhs_vector_name: The name of the LHS vector, e.g. 'x1l' or 'j1l'.</p>
<p>rhs_vector_name: The name of the RHS vector, e.g. 'yxr' or 'j1r'.</p>
<h3 id="returns">Returns</h3>
<p>The required partial derivatives as a dataframe
with variable names as the row and column labels.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_partials_as_dataframe(self, lhs_vector_name, rhs_vector_name) -&gt; pd.DataFrame:
    &#34;&#34;&#34;

    ### Arguments

    lhs_vector_name: The name of the LHS vector, e.g. &#39;x1l&#39; or &#39;j1l&#39;.

    rhs_vector_name: The name of the RHS vector, e.g. &#39;yxr&#39; or &#39;j1r&#39;.

    ### Returns
    
    The required partial derivatives as a dataframe 
    with variable names as the row and column labels.

    &#34;&#34;&#34;
    if self._partial_derivatives is None:
        raise Exception(f&#34;Attempted to access partial derivatives {lhs_vector_name} on {rhs_vector_name} before it was created.&#34;)
    key = (lhs_vector_name, rhs_vector_name)
    if key in self._partial_derivatives:
        result: pd.DataFrame = pd.DataFrame(self._partial_derivatives[key])
        result.index = self.sym_data.vector_variable_names(vector_name=lhs_vector_name)
        result.columns = self.sym_data.vector_variable_names(vector_name=rhs_vector_name)
        return result
    return None</code></pre>
</details>
</dd>
<dt id="gcubed.linearisation.linear_model.LinearModel.get_vector_by_name"><code class="name flex">
<span>def <span class="ident">get_vector_by_name</span></span>(<span>self, vector_name) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><h3 id="overview">Overview</h3>
<p>Use the name of the vector to retrieve its numpy array value.
These values have been set using data in the database.</p>
<h3 id="arguments">Arguments</h3>
<p>vector_name: The name of the LHS or RHS vector.</p>
<h3 id="returns">Returns</h3>
<p>The named column vector.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_vector_by_name(self, vector_name) -&gt; np.ndarray:
    &#34;&#34;&#34;
    ### Overview

    Use the name of the vector to retrieve its numpy array value.
    These values have been set using data in the database.

    ### Arguments

    vector_name: The name of the LHS or RHS vector.
    
    ### Returns
    
    The named column vector.
    
    &#34;&#34;&#34;
    if not hasattr(self, &#34;_{}&#34;.format(vector_name)):
        raise Exception(&#34;There is no vector for {}&#34;.format(vector_name))
    return getattr(self, &#34;_{}&#34;.format(vector_name))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gcubed.base.Base" href="../base.html#gcubed.base.Base">Base</a></b></code>:
<ul class="hlist">
<li><code><a title="gcubed.base.Base.get_year_labels" href="../base.html#gcubed.base.Base.get_year_labels">get_year_labels</a></code></li>
<li><code><a title="gcubed.base.Base.load_data" href="../base.html#gcubed.base.Base.load_data">load_data</a></code></li>
<li><code><a title="gcubed.base.Base.zeros" href="../base.html#gcubed.base.Base.zeros">zeros</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gcubed.linearisation" href="index.html">gcubed.linearisation</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gcubed.linearisation.linear_model.LinearModel" href="#gcubed.linearisation.linear_model.LinearModel">LinearModel</a></code></h4>
<ul class="">
<li><code><a title="gcubed.linearisation.linear_model.LinearModel.configuration" href="#gcubed.linearisation.linear_model.LinearModel.configuration">configuration</a></code></li>
<li><code><a title="gcubed.linearisation.linear_model.LinearModel.equations" href="#gcubed.linearisation.linear_model.LinearModel.equations">equations</a></code></li>
<li><code><a title="gcubed.linearisation.linear_model.LinearModel.equations_map" href="#gcubed.linearisation.linear_model.LinearModel.equations_map">equations_map</a></code></li>
<li><code><a title="gcubed.linearisation.linear_model.LinearModel.get_original_lhs_vector_by_name" href="#gcubed.linearisation.linear_model.LinearModel.get_original_lhs_vector_by_name">get_original_lhs_vector_by_name</a></code></li>
<li><code><a title="gcubed.linearisation.linear_model.LinearModel.get_partials" href="#gcubed.linearisation.linear_model.LinearModel.get_partials">get_partials</a></code></li>
<li><code><a title="gcubed.linearisation.linear_model.LinearModel.get_partials_as_dataframe" href="#gcubed.linearisation.linear_model.LinearModel.get_partials_as_dataframe">get_partials_as_dataframe</a></code></li>
<li><code><a title="gcubed.linearisation.linear_model.LinearModel.get_vector_by_name" href="#gcubed.linearisation.linear_model.LinearModel.get_vector_by_name">get_vector_by_name</a></code></li>
<li><code><a title="gcubed.linearisation.linear_model.LinearModel.linear_model_is_available" href="#gcubed.linearisation.linear_model.LinearModel.linear_model_is_available">linear_model_is_available</a></code></li>
<li><code><a title="gcubed.linearisation.linear_model.LinearModel.linearisation_database" href="#gcubed.linearisation.linear_model.LinearModel.linearisation_database">linearisation_database</a></code></li>
<li><code><a title="gcubed.linearisation.linear_model.LinearModel.model" href="#gcubed.linearisation.linear_model.LinearModel.model">model</a></code></li>
<li><code><a title="gcubed.linearisation.linear_model.LinearModel.nonlinear_equation_differences" href="#gcubed.linearisation.linear_model.LinearModel.nonlinear_equation_differences">nonlinear_equation_differences</a></code></li>
<li><code><a title="gcubed.linearisation.linear_model.LinearModel.sym_data" href="#gcubed.linearisation.linear_model.LinearModel.sym_data">sym_data</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
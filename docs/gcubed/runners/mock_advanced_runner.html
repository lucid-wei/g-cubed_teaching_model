<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gcubed.runners.mock_advanced_runner API documentation</title>
<meta name="description" content="This runner uses the mock relinearisation projections. Only used
for unit testing purposes." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gcubed.runners.mock_advanced_runner</code></h1>
</header>
<section id="section-intro">
<h2 id="this-runner-uses-the-mock-relinearisation-projections-only-used">This runner uses the mock relinearisation projections. Only used</h2>
<p>for unit testing purposes.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;

## This runner uses the mock relinearisation projections. Only used
for unit testing purposes.

&#34;&#34;&#34;
import os
import logging
from datetime import datetime
from queue import Empty
from gcubed.base import Base
from gcubed.model_configuration import ModelConfiguration
from gcubed.model import Model
from gcubed.linearisation.linear_model import LinearModel
from gcubed.linearisation.state_space_form import StateSpaceForm
from gcubed.linearisation.stable_manifold import StableManifold
from gcubed.projections.projections import Projections
from gcubed.projections.baseline_projections import BaselineProjections
from gcubed.projections.simulation_layer_definitions import SimulationLayerDefinitions
from gcubed.projections.simulation_layer import SimulationLayer
from gcubed.projections.mock_relinearisation_projections import MockRelinearisationProjections

class MockAdvancedRunner(Base):
    &#34;&#34;&#34;

    ### Overview


    The AdvancedRunner class runs a simulation experiment 
    with G-Cubed that incorporates relinearisation in chosen years while
    allowing for strict or non-strict choice of points to linearise around
    and supporting simulation experiments using or not using relinearisation
    in their event years.

    1. The model is loaded and used to generate baseline projections.
    2. The experiment design is loaded, setting out each of the events being
    simulated as a separate simulation layer.
    3. The simulation layers are loaded and applied to the model to generate 
    projection updates. 
    
    Projections based on any of the simulation layers can be compared to projections
    from the baseline or from other simulation layers associated with the experiment.
    &#34;&#34;&#34;

    def __init__(self, working_directory:str, configuration_file: str, relinearisation_years: list[int] = None, experiment_design_file: str = None):
        &#34;&#34;&#34;

        ### Overview

        Loads the configuration and the model, ready for running. Call the run method
        when you are ready to start model linearisation etc.

        The relinearisation of the model is done for each event year associated with
        a simulation layer and for each year nominated for relinearisation.

        After a successful run, if the `SimpleRunner.save_results` = `True`,
        you will see the results generated in a new timestamped results subdirectory 
        of the directory that you ran the command from.
        
        The results directory contains three CSV files and a log file:

        * `baseline_projections.csv` 
        * `deviation_projections.csv`
        * `final_projections.csv`
        * `run.log`

        The log file is a text file that contains messages 
        about the progress of the model run and any problems that arose.

        ### Arguments
        
        `working_directory`: The directory where the results 
        and logs are to be stored.

        `configuration_file`: The location of the configuration 
        file, as an absolute path or relative to the 
        specified working directory.

        `relinearisation_years`: The list of years where a 
        relinearisation is required. This list can be empty
        in which case the model is not relinearised.

        `experiment_design_file`: The optional location of the 
        experiment design CSV file, as a relative path directory
        to the experiment design file from the simulations directory 
        within the model directory (the model directory contains
        the configuration file).
        &#34;&#34;&#34;

        self._all_projections: list[Projections] = []

        self.save_results = False

        self.relinearise_in_event_years = False

        self._completed_successfully: bool = False

        if not os.path.isdir(working_directory):
            raise Exception(f&#34;{working_directory} is not a directory.&#34;)
        
        if not os.access(working_directory, os.W_OK):
            raise Exception(f&#34;You need write access to {working_directory} but that permission has not been granted to you.&#34;)

        if self.save_results:
            # Set up directory where results will be stored
            self.timestamp: str = datetime.now().strftime(&#34;%Y-%m-%d_%H-%M-%S&#34;)
            self.results_directory: str = os.path.join(working_directory, f&#34;results_{self.timestamp}&#34;)
            if not os.path.exists(self.results_directory):
                os.mkdir(self.results_directory)
            if not os.path.isdir(self.results_directory):
                raise Exception(f&#34;Results are to be stored in the directory {self.results_directory} but it is a file, not a directory.&#34;)

        # Get the absolute path to the model configuration file.
        if os.path.isabs(configuration_file):
            self.filename:str = configuration_file
        else:
            self.filename: str = os.path.join(working_directory, configuration_file)
        if not os.path.isfile(self.filename):
            raise Exception(f&#34;There is no model configuration file at {self.filename}.&#34;)
        logging.info(f&#34;The model configuration will be loaded from {self.filename}.&#34;)

        # Load the model
        model_configuration: ModelConfiguration = ModelConfiguration(configuration_file=self.filename)
        self._model: Model = Model(model_configuration)

        # Validate and save the list of relinearisation years.
        if not relinearisation_years:
            self._relinearisation_years = []
        else:
            if not isinstance(relinearisation_years, list):
                raise Exception(&#34;You must specify a list of years in which the model is to be relinearised.&#34;)
            for year in relinearisation_years:
                if not isinstance(year, int):
                    raise Exception(&#34;The list of relinearisation years must contain YYYY formatted integers.&#34;)
            if len(relinearisation_years) != len(set(relinearisation_years)):
                raise Exception(&#34;There must not be duplicate relinearisation years.&#34;)
            if relinearisation_years != sorted(relinearisation_years):
                raise Exception(&#34;The list of relinearisation years must be in ascending order.&#34;)
            if relinearisation_years[0] &lt;= model_configuration.original_first_projection_year:
                raise Exception(&#34;The relinearisation years must be after the first projection year.&#34;)
            if relinearisation_years[-1] &gt;= model_configuration.last_projection_year:
                raise Exception(&#34;The relinearisation years must be before the last projection year.&#34;)
            self._relinearisation_years = relinearisation_years

        # Save the experiment design file for later use.
        self.experiment_design_file = experiment_design_file

    @property
    def model(self) -&gt; ModelConfiguration:
        &#34;&#34;&#34;
        The model being run.
        &#34;&#34;&#34;
        return self._model

    @property
    def relinearisation_years(self) -&gt; list[int]:
        &#34;&#34;&#34;
        The (possibly empty) list of relinearisation years (all in YYYY format).
        &#34;&#34;&#34;
        return self._relinearisation_years

    @property
    def event_years(self) -&gt; list[int]:
        &#34;&#34;&#34;
        The (possibly empty) list of event years (all in YYYY format).
        &#34;&#34;&#34;
        return self._event_years

    @property
    def all_projections(self) -&gt; list[Projections]:
        &#34;&#34;&#34;
        A list of all projections generated by the 
        runner or an empty list if no projections
        have been generated by the runner when this 
        property is requested. The first projections are the baseline projections
        and then the following projections are the projections generated due 
        to simulation layers or relinearisations etc. added to the list as they 
        are generated.

        This method will return the empty list if the runner has
        not started. If the runner is partway through the run, 
        then the projections that have been produced will be available.
        &#34;&#34;&#34;
        if not hasattr(self,&#39;_all_projections&#39;):
            raise Exception(&#34;The list of all projections does not exist but it should. There is a bug in this runner.&#34;)
        return self._all_projections

    @property
    def baseline_projections(self) -&gt; BaselineProjections:
        &#34;&#34;&#34;
        The baseline projections.
        &#34;&#34;&#34;
        if self._all_projections is Empty:
            raise Exception(&#34;The baseline projections are not yet available. Make sure you run the model before accessing them.&#34;)
        return self.all_projections[0]

    @property
    def most_recently_generated_projections(self) -&gt; Projections:
        &#34;&#34;&#34;
        The projections most recently generated in the run.
        &#34;&#34;&#34;
        if self._all_projections is Empty:
            raise Exception(&#34;Projections are not yet available. Make sure you run the model before accessing them.&#34;)
        return self.all_projections[-1]

    @property
    def final_projections(self) -&gt; Projections:
        &#34;&#34;&#34;
        The final projections which can be the baseline
        projections if there was no simulation experiment to do.
        &#34;&#34;&#34;
        if not self.completed_successfully:
            raise Exception(&#34;The run has not yet completed so the final projections are not yet available.&#34;)
        if self._all_projections is Empty:
            raise Exception(&#34;The final projections are not yet available. Make sure you run the model before accessing them.&#34;)
        return self.all_projections[-1]
        
    @property
    def simulation_layer_definitions(self) -&gt; SimulationLayerDefinitions:
        &#34;&#34;&#34;
        The simulation layer definitions documented in the experiment design.
        &#34;&#34;&#34;
        if not hasattr(self, &#34;_simulation_layer_definitions&#34;):
            raise Exception(&#34;The simulation layer definitions have not been loaded yet.&#34;)
        return self._simulation_layer_definitions

    @property
    def save_results(self) -&gt; bool:
        &#34;&#34;&#34;
        `True` if the results are to be saved to a results directory automatically at the end of the
        run and `False` otherwise. 
        
        Defaults to False.

        If necessary, modify this setting once the runner is instantiated but 
        before the experiment is run.
        &#34;&#34;&#34;
        return self._save_results

    @save_results.setter
    def save_results(self, value: bool) -&gt; bool:
        &#34;&#34;&#34;
        ### Overview
        
        Set the value to `True` if the results are to be saved to a 
        results directory automatically at the end of the run and `False` otherwise.
        &#34;&#34;&#34;
        assert value is not None
        assert isinstance(value, bool)
        self._save_results = value

    @property
    def relinearise_in_event_years(self) -&gt; bool:
        &#34;&#34;&#34;
        `True` if the runner is to relinearise the model in all event years
        as well as the years specified and `False` if the runner is to relinearise the model only
        in the years specified.
        
        Defaults to `False`.

        If necessary, modify this setting once the running is instantiated but 
        before the experiment is run.
        &#34;&#34;&#34;
        return self._relinearise_in_event_years

    @relinearise_in_event_years.setter
    def relinearise_in_event_years(self, value: bool) -&gt; bool:
        &#34;&#34;&#34;
        ### Overview
        
        Set the value to `True` if the runner is to relinearise the model in all event years
        as well as the years specified and `False` if the runner is to relinearise the model only
        in the years specified.
        &#34;&#34;&#34;
        assert value is not None
        assert isinstance(value, bool)
        self._relinearise_in_event_years = value

    @property
    def completed_successfully(self) -&gt; bool:
        &#34;&#34;&#34;
        `True` if the runner has completed all projections successfully and `False` otherwise.
        &#34;&#34;&#34;
        return self._completed_successfully

    def run(self):
        &#34;&#34;&#34;
        ### Overview

        Do the actual work of running the model and performing 
        the experiment.
        
        Call this method after creating a Runner instance.

        Once the experiment has run, you can retrieve projections from
        the simulation layer(s) of interest and the baseline for comparison and
        analysis purposes.
        &#34;&#34;&#34;
        if self.save_results:
            log_file: str = os.path.join(self.results_directory, &#34;run.log&#34;)
            fh = logging.FileHandler(log_file, mode=&#39;w&#39;)
            logging.basicConfig(level=logging.DEBUG,
                                format=&#39;%(asctime)s %(levelname)s %(message)s&#39;,
                                handlers=[
                                    fh,
                                    logging.StreamHandler()
                                ])
            logging.info(f&#34;Saving results and logs to {self.results_directory}.&#34;)
        else:
            logging.basicConfig(level=logging.DEBUG,
                                format=&#39;%(asctime)s %(levelname)s %(message)s&#39;,
                                handlers=[
                                    logging.StreamHandler()
                                ])
            logging.info(f&#34;Only logging to the console. No results being saved to files.&#34;)

        # Get the model stable manifold and related results for the baseline projections
        linear_model: LinearModel = LinearModel(model=self.model)
        state_space_form: StateSpaceForm = StateSpaceForm(linear_model=linear_model)
        stable_manifold: StableManifold = StableManifold(state_space_form=state_space_form)

        # Generate and store the baseline projections
        self.all_projections.append(BaselineProjections(stable_manifold=stable_manifold))

        # Generate the CSV file containing baseline projections
        if self.save_results:
            self.baseline_projections.publishable_projections.to_csv(f&#34;{self.results_directory}/baseline_projections.csv&#34;)
            logging.info(f&#34;Baseline publication projections have been saved to a CSV file in {self.results_directory}&#34;)

        # Load the simulation layer definitions from the experiment design file.
        self._simulation_layer_definitions = SimulationLayerDefinitions(sym_data=self.baseline_projections.sym_data)        
        self.simulation_layer_definitions.load_from_csv_file(design_file=self.experiment_design_file)
        
        self._event_years = self.simulation_layer_definitions.all_event_years_in_ascending_order

        if self.relinearise_in_event_years and self.experiment_design_file is not None:
            # Augment the list of relinearisation years.
            self.relinearisation_years = sorted(set(self.relinearisation_years).union(set(self.event_years)))
            logging.debug(f&#34;The combined event and relinearisation years are:\n{self.relinearisation_years}&#34;)

        # Step forward through the projection years and for each step check if we need to do 
        # a simulation or relinearisation.
        for year in range(self.baseline_projections.first_projection_year, self.baseline_projections.last_projection_year):
            
            # Do a relinearisation and add any relevant simulation layers while we are at it.
            if year in self.relinearisation_years:

                self.all_projections.append(
                    MockRelinearisationProjections(
                        baseline_projections=self.baseline_projections, 
                        previous_projections=self.most_recently_generated_projections,
                        relinearisation_year=year, 
                        simulation_layer_definitions=self.simulation_layer_definitions
                        )
                    )

                logging.info(f&#34;Generated relinearised projections from {self.most_recently_generated_projections.first_projection_year}.&#34;)
                continue

            if year in self.event_years:
                # Apply each simulation layer with this event year, one after the other.
                for simulation_layer_definition in self.simulation_layer_definitions.get_simulation_layer_definitions(event_year=year):

                    self.all_projections.append(
                        SimulationLayer(
                            simulation_layer_definition=simulation_layer_definition,
                            previous_projections=self.most_recently_generated_projections
                            )
                        )
                    
                    logging.info(f&#34;Added {simulation_layer_definition.name} simulation layer to projections from {self.most_recently_generated_projections.first_projection_year}.&#34;)
                
                continue

        self._completed_successfully = True

        if self.save_results:
            # Generate the CSV file containing simulation projections
            self.final_projections.publishable_projections.to_csv(f&#34;{self.results_directory}/final_projections.csv&#34;)
            # Generate the CSV file containing the simulation deviation from baseline projections
            Projections.get_differences_between_projections(new_projections=self.final_projectionsl.publishable_projections, original_projections=self.baseline_projections.publishable_projections).to_csv(f&#34;{self.results_directory}/deviation_projections.csv&#34;)
            logging.info(f&#34;The simulation experiment results have been saved as CSV files in {self.results_directory}&#34;)
        else:
            logging.info(f&#34;The simulation experiment has run.&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gcubed.runners.mock_advanced_runner.MockAdvancedRunner"><code class="flex name class">
<span>class <span class="ident">MockAdvancedRunner</span></span>
<span>(</span><span>working_directory: str, configuration_file: str, relinearisation_years: list[int] = None, experiment_design_file: str = None)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="overview">Overview</h3>
<p>The AdvancedRunner class runs a simulation experiment
with G-Cubed that incorporates relinearisation in chosen years while
allowing for strict or non-strict choice of points to linearise around
and supporting simulation experiments using or not using relinearisation
in their event years.</p>
<ol>
<li>The model is loaded and used to generate baseline projections.</li>
<li>The experiment design is loaded, setting out each of the events being
simulated as a separate simulation layer.</li>
<li>The simulation layers are loaded and applied to the model to generate
projection updates. </li>
</ol>
<p>Projections based on any of the simulation layers can be compared to projections
from the baseline or from other simulation layers associated with the experiment.</p>
<h3 id="overview_1">Overview</h3>
<p>Loads the configuration and the model, ready for running. Call the run method
when you are ready to start model linearisation etc.</p>
<p>The relinearisation of the model is done for each event year associated with
a simulation layer and for each year nominated for relinearisation.</p>
<p>After a successful run, if the <code>SimpleRunner.save_results</code> = <code>True</code>,
you will see the results generated in a new timestamped results subdirectory
of the directory that you ran the command from.</p>
<p>The results directory contains three CSV files and a log file:</p>
<ul>
<li><code>baseline_projections.csv</code> </li>
<li><code>deviation_projections.csv</code></li>
<li><code>final_projections.csv</code></li>
<li><code>run.log</code></li>
</ul>
<p>The log file is a text file that contains messages
about the progress of the model run and any problems that arose.</p>
<h3 id="arguments">Arguments</h3>
<p><code>working_directory</code>: The directory where the results
and logs are to be stored.</p>
<p><code>configuration_file</code>: The location of the configuration
file, as an absolute path or relative to the
specified working directory.</p>
<p><code>relinearisation_years</code>: The list of years where a
relinearisation is required. This list can be empty
in which case the model is not relinearised.</p>
<p><code>experiment_design_file</code>: The optional location of the
experiment design CSV file, as a relative path directory
to the experiment design file from the simulations directory
within the model directory (the model directory contains
the configuration file).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MockAdvancedRunner(Base):
    &#34;&#34;&#34;

    ### Overview


    The AdvancedRunner class runs a simulation experiment 
    with G-Cubed that incorporates relinearisation in chosen years while
    allowing for strict or non-strict choice of points to linearise around
    and supporting simulation experiments using or not using relinearisation
    in their event years.

    1. The model is loaded and used to generate baseline projections.
    2. The experiment design is loaded, setting out each of the events being
    simulated as a separate simulation layer.
    3. The simulation layers are loaded and applied to the model to generate 
    projection updates. 
    
    Projections based on any of the simulation layers can be compared to projections
    from the baseline or from other simulation layers associated with the experiment.
    &#34;&#34;&#34;

    def __init__(self, working_directory:str, configuration_file: str, relinearisation_years: list[int] = None, experiment_design_file: str = None):
        &#34;&#34;&#34;

        ### Overview

        Loads the configuration and the model, ready for running. Call the run method
        when you are ready to start model linearisation etc.

        The relinearisation of the model is done for each event year associated with
        a simulation layer and for each year nominated for relinearisation.

        After a successful run, if the `SimpleRunner.save_results` = `True`,
        you will see the results generated in a new timestamped results subdirectory 
        of the directory that you ran the command from.
        
        The results directory contains three CSV files and a log file:

        * `baseline_projections.csv` 
        * `deviation_projections.csv`
        * `final_projections.csv`
        * `run.log`

        The log file is a text file that contains messages 
        about the progress of the model run and any problems that arose.

        ### Arguments
        
        `working_directory`: The directory where the results 
        and logs are to be stored.

        `configuration_file`: The location of the configuration 
        file, as an absolute path or relative to the 
        specified working directory.

        `relinearisation_years`: The list of years where a 
        relinearisation is required. This list can be empty
        in which case the model is not relinearised.

        `experiment_design_file`: The optional location of the 
        experiment design CSV file, as a relative path directory
        to the experiment design file from the simulations directory 
        within the model directory (the model directory contains
        the configuration file).
        &#34;&#34;&#34;

        self._all_projections: list[Projections] = []

        self.save_results = False

        self.relinearise_in_event_years = False

        self._completed_successfully: bool = False

        if not os.path.isdir(working_directory):
            raise Exception(f&#34;{working_directory} is not a directory.&#34;)
        
        if not os.access(working_directory, os.W_OK):
            raise Exception(f&#34;You need write access to {working_directory} but that permission has not been granted to you.&#34;)

        if self.save_results:
            # Set up directory where results will be stored
            self.timestamp: str = datetime.now().strftime(&#34;%Y-%m-%d_%H-%M-%S&#34;)
            self.results_directory: str = os.path.join(working_directory, f&#34;results_{self.timestamp}&#34;)
            if not os.path.exists(self.results_directory):
                os.mkdir(self.results_directory)
            if not os.path.isdir(self.results_directory):
                raise Exception(f&#34;Results are to be stored in the directory {self.results_directory} but it is a file, not a directory.&#34;)

        # Get the absolute path to the model configuration file.
        if os.path.isabs(configuration_file):
            self.filename:str = configuration_file
        else:
            self.filename: str = os.path.join(working_directory, configuration_file)
        if not os.path.isfile(self.filename):
            raise Exception(f&#34;There is no model configuration file at {self.filename}.&#34;)
        logging.info(f&#34;The model configuration will be loaded from {self.filename}.&#34;)

        # Load the model
        model_configuration: ModelConfiguration = ModelConfiguration(configuration_file=self.filename)
        self._model: Model = Model(model_configuration)

        # Validate and save the list of relinearisation years.
        if not relinearisation_years:
            self._relinearisation_years = []
        else:
            if not isinstance(relinearisation_years, list):
                raise Exception(&#34;You must specify a list of years in which the model is to be relinearised.&#34;)
            for year in relinearisation_years:
                if not isinstance(year, int):
                    raise Exception(&#34;The list of relinearisation years must contain YYYY formatted integers.&#34;)
            if len(relinearisation_years) != len(set(relinearisation_years)):
                raise Exception(&#34;There must not be duplicate relinearisation years.&#34;)
            if relinearisation_years != sorted(relinearisation_years):
                raise Exception(&#34;The list of relinearisation years must be in ascending order.&#34;)
            if relinearisation_years[0] &lt;= model_configuration.original_first_projection_year:
                raise Exception(&#34;The relinearisation years must be after the first projection year.&#34;)
            if relinearisation_years[-1] &gt;= model_configuration.last_projection_year:
                raise Exception(&#34;The relinearisation years must be before the last projection year.&#34;)
            self._relinearisation_years = relinearisation_years

        # Save the experiment design file for later use.
        self.experiment_design_file = experiment_design_file

    @property
    def model(self) -&gt; ModelConfiguration:
        &#34;&#34;&#34;
        The model being run.
        &#34;&#34;&#34;
        return self._model

    @property
    def relinearisation_years(self) -&gt; list[int]:
        &#34;&#34;&#34;
        The (possibly empty) list of relinearisation years (all in YYYY format).
        &#34;&#34;&#34;
        return self._relinearisation_years

    @property
    def event_years(self) -&gt; list[int]:
        &#34;&#34;&#34;
        The (possibly empty) list of event years (all in YYYY format).
        &#34;&#34;&#34;
        return self._event_years

    @property
    def all_projections(self) -&gt; list[Projections]:
        &#34;&#34;&#34;
        A list of all projections generated by the 
        runner or an empty list if no projections
        have been generated by the runner when this 
        property is requested. The first projections are the baseline projections
        and then the following projections are the projections generated due 
        to simulation layers or relinearisations etc. added to the list as they 
        are generated.

        This method will return the empty list if the runner has
        not started. If the runner is partway through the run, 
        then the projections that have been produced will be available.
        &#34;&#34;&#34;
        if not hasattr(self,&#39;_all_projections&#39;):
            raise Exception(&#34;The list of all projections does not exist but it should. There is a bug in this runner.&#34;)
        return self._all_projections

    @property
    def baseline_projections(self) -&gt; BaselineProjections:
        &#34;&#34;&#34;
        The baseline projections.
        &#34;&#34;&#34;
        if self._all_projections is Empty:
            raise Exception(&#34;The baseline projections are not yet available. Make sure you run the model before accessing them.&#34;)
        return self.all_projections[0]

    @property
    def most_recently_generated_projections(self) -&gt; Projections:
        &#34;&#34;&#34;
        The projections most recently generated in the run.
        &#34;&#34;&#34;
        if self._all_projections is Empty:
            raise Exception(&#34;Projections are not yet available. Make sure you run the model before accessing them.&#34;)
        return self.all_projections[-1]

    @property
    def final_projections(self) -&gt; Projections:
        &#34;&#34;&#34;
        The final projections which can be the baseline
        projections if there was no simulation experiment to do.
        &#34;&#34;&#34;
        if not self.completed_successfully:
            raise Exception(&#34;The run has not yet completed so the final projections are not yet available.&#34;)
        if self._all_projections is Empty:
            raise Exception(&#34;The final projections are not yet available. Make sure you run the model before accessing them.&#34;)
        return self.all_projections[-1]
        
    @property
    def simulation_layer_definitions(self) -&gt; SimulationLayerDefinitions:
        &#34;&#34;&#34;
        The simulation layer definitions documented in the experiment design.
        &#34;&#34;&#34;
        if not hasattr(self, &#34;_simulation_layer_definitions&#34;):
            raise Exception(&#34;The simulation layer definitions have not been loaded yet.&#34;)
        return self._simulation_layer_definitions

    @property
    def save_results(self) -&gt; bool:
        &#34;&#34;&#34;
        `True` if the results are to be saved to a results directory automatically at the end of the
        run and `False` otherwise. 
        
        Defaults to False.

        If necessary, modify this setting once the runner is instantiated but 
        before the experiment is run.
        &#34;&#34;&#34;
        return self._save_results

    @save_results.setter
    def save_results(self, value: bool) -&gt; bool:
        &#34;&#34;&#34;
        ### Overview
        
        Set the value to `True` if the results are to be saved to a 
        results directory automatically at the end of the run and `False` otherwise.
        &#34;&#34;&#34;
        assert value is not None
        assert isinstance(value, bool)
        self._save_results = value

    @property
    def relinearise_in_event_years(self) -&gt; bool:
        &#34;&#34;&#34;
        `True` if the runner is to relinearise the model in all event years
        as well as the years specified and `False` if the runner is to relinearise the model only
        in the years specified.
        
        Defaults to `False`.

        If necessary, modify this setting once the running is instantiated but 
        before the experiment is run.
        &#34;&#34;&#34;
        return self._relinearise_in_event_years

    @relinearise_in_event_years.setter
    def relinearise_in_event_years(self, value: bool) -&gt; bool:
        &#34;&#34;&#34;
        ### Overview
        
        Set the value to `True` if the runner is to relinearise the model in all event years
        as well as the years specified and `False` if the runner is to relinearise the model only
        in the years specified.
        &#34;&#34;&#34;
        assert value is not None
        assert isinstance(value, bool)
        self._relinearise_in_event_years = value

    @property
    def completed_successfully(self) -&gt; bool:
        &#34;&#34;&#34;
        `True` if the runner has completed all projections successfully and `False` otherwise.
        &#34;&#34;&#34;
        return self._completed_successfully

    def run(self):
        &#34;&#34;&#34;
        ### Overview

        Do the actual work of running the model and performing 
        the experiment.
        
        Call this method after creating a Runner instance.

        Once the experiment has run, you can retrieve projections from
        the simulation layer(s) of interest and the baseline for comparison and
        analysis purposes.
        &#34;&#34;&#34;
        if self.save_results:
            log_file: str = os.path.join(self.results_directory, &#34;run.log&#34;)
            fh = logging.FileHandler(log_file, mode=&#39;w&#39;)
            logging.basicConfig(level=logging.DEBUG,
                                format=&#39;%(asctime)s %(levelname)s %(message)s&#39;,
                                handlers=[
                                    fh,
                                    logging.StreamHandler()
                                ])
            logging.info(f&#34;Saving results and logs to {self.results_directory}.&#34;)
        else:
            logging.basicConfig(level=logging.DEBUG,
                                format=&#39;%(asctime)s %(levelname)s %(message)s&#39;,
                                handlers=[
                                    logging.StreamHandler()
                                ])
            logging.info(f&#34;Only logging to the console. No results being saved to files.&#34;)

        # Get the model stable manifold and related results for the baseline projections
        linear_model: LinearModel = LinearModel(model=self.model)
        state_space_form: StateSpaceForm = StateSpaceForm(linear_model=linear_model)
        stable_manifold: StableManifold = StableManifold(state_space_form=state_space_form)

        # Generate and store the baseline projections
        self.all_projections.append(BaselineProjections(stable_manifold=stable_manifold))

        # Generate the CSV file containing baseline projections
        if self.save_results:
            self.baseline_projections.publishable_projections.to_csv(f&#34;{self.results_directory}/baseline_projections.csv&#34;)
            logging.info(f&#34;Baseline publication projections have been saved to a CSV file in {self.results_directory}&#34;)

        # Load the simulation layer definitions from the experiment design file.
        self._simulation_layer_definitions = SimulationLayerDefinitions(sym_data=self.baseline_projections.sym_data)        
        self.simulation_layer_definitions.load_from_csv_file(design_file=self.experiment_design_file)
        
        self._event_years = self.simulation_layer_definitions.all_event_years_in_ascending_order

        if self.relinearise_in_event_years and self.experiment_design_file is not None:
            # Augment the list of relinearisation years.
            self.relinearisation_years = sorted(set(self.relinearisation_years).union(set(self.event_years)))
            logging.debug(f&#34;The combined event and relinearisation years are:\n{self.relinearisation_years}&#34;)

        # Step forward through the projection years and for each step check if we need to do 
        # a simulation or relinearisation.
        for year in range(self.baseline_projections.first_projection_year, self.baseline_projections.last_projection_year):
            
            # Do a relinearisation and add any relevant simulation layers while we are at it.
            if year in self.relinearisation_years:

                self.all_projections.append(
                    MockRelinearisationProjections(
                        baseline_projections=self.baseline_projections, 
                        previous_projections=self.most_recently_generated_projections,
                        relinearisation_year=year, 
                        simulation_layer_definitions=self.simulation_layer_definitions
                        )
                    )

                logging.info(f&#34;Generated relinearised projections from {self.most_recently_generated_projections.first_projection_year}.&#34;)
                continue

            if year in self.event_years:
                # Apply each simulation layer with this event year, one after the other.
                for simulation_layer_definition in self.simulation_layer_definitions.get_simulation_layer_definitions(event_year=year):

                    self.all_projections.append(
                        SimulationLayer(
                            simulation_layer_definition=simulation_layer_definition,
                            previous_projections=self.most_recently_generated_projections
                            )
                        )
                    
                    logging.info(f&#34;Added {simulation_layer_definition.name} simulation layer to projections from {self.most_recently_generated_projections.first_projection_year}.&#34;)
                
                continue

        self._completed_successfully = True

        if self.save_results:
            # Generate the CSV file containing simulation projections
            self.final_projections.publishable_projections.to_csv(f&#34;{self.results_directory}/final_projections.csv&#34;)
            # Generate the CSV file containing the simulation deviation from baseline projections
            Projections.get_differences_between_projections(new_projections=self.final_projectionsl.publishable_projections, original_projections=self.baseline_projections.publishable_projections).to_csv(f&#34;{self.results_directory}/deviation_projections.csv&#34;)
            logging.info(f&#34;The simulation experiment results have been saved as CSV files in {self.results_directory}&#34;)
        else:
            logging.info(f&#34;The simulation experiment has run.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gcubed.base.Base" href="../base.html#gcubed.base.Base">Base</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="gcubed.runners.mock_advanced_runner.MockAdvancedRunner.all_projections"><code class="name">var <span class="ident">all_projections</span> : list[<a title="gcubed.projections.projections.Projections" href="../projections/projections.html#gcubed.projections.projections.Projections">Projections</a>]</code></dt>
<dd>
<div class="desc"><p>A list of all projections generated by the
runner or an empty list if no projections
have been generated by the runner when this
property is requested. The first projections are the baseline projections
and then the following projections are the projections generated due
to simulation layers or relinearisations etc. added to the list as they
are generated.</p>
<p>This method will return the empty list if the runner has
not started. If the runner is partway through the run,
then the projections that have been produced will be available.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def all_projections(self) -&gt; list[Projections]:
    &#34;&#34;&#34;
    A list of all projections generated by the 
    runner or an empty list if no projections
    have been generated by the runner when this 
    property is requested. The first projections are the baseline projections
    and then the following projections are the projections generated due 
    to simulation layers or relinearisations etc. added to the list as they 
    are generated.

    This method will return the empty list if the runner has
    not started. If the runner is partway through the run, 
    then the projections that have been produced will be available.
    &#34;&#34;&#34;
    if not hasattr(self,&#39;_all_projections&#39;):
        raise Exception(&#34;The list of all projections does not exist but it should. There is a bug in this runner.&#34;)
    return self._all_projections</code></pre>
</details>
</dd>
<dt id="gcubed.runners.mock_advanced_runner.MockAdvancedRunner.baseline_projections"><code class="name">var <span class="ident">baseline_projections</span> : <a title="gcubed.projections.baseline_projections.BaselineProjections" href="../projections/baseline_projections.html#gcubed.projections.baseline_projections.BaselineProjections">BaselineProjections</a></code></dt>
<dd>
<div class="desc"><p>The baseline projections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def baseline_projections(self) -&gt; BaselineProjections:
    &#34;&#34;&#34;
    The baseline projections.
    &#34;&#34;&#34;
    if self._all_projections is Empty:
        raise Exception(&#34;The baseline projections are not yet available. Make sure you run the model before accessing them.&#34;)
    return self.all_projections[0]</code></pre>
</details>
</dd>
<dt id="gcubed.runners.mock_advanced_runner.MockAdvancedRunner.completed_successfully"><code class="name">var <span class="ident">completed_successfully</span> : bool</code></dt>
<dd>
<div class="desc"><p><code>True</code> if the runner has completed all projections successfully and <code>False</code> otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def completed_successfully(self) -&gt; bool:
    &#34;&#34;&#34;
    `True` if the runner has completed all projections successfully and `False` otherwise.
    &#34;&#34;&#34;
    return self._completed_successfully</code></pre>
</details>
</dd>
<dt id="gcubed.runners.mock_advanced_runner.MockAdvancedRunner.event_years"><code class="name">var <span class="ident">event_years</span> : list[int]</code></dt>
<dd>
<div class="desc"><p>The (possibly empty) list of event years (all in YYYY format).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def event_years(self) -&gt; list[int]:
    &#34;&#34;&#34;
    The (possibly empty) list of event years (all in YYYY format).
    &#34;&#34;&#34;
    return self._event_years</code></pre>
</details>
</dd>
<dt id="gcubed.runners.mock_advanced_runner.MockAdvancedRunner.final_projections"><code class="name">var <span class="ident">final_projections</span> : <a title="gcubed.projections.projections.Projections" href="../projections/projections.html#gcubed.projections.projections.Projections">Projections</a></code></dt>
<dd>
<div class="desc"><p>The final projections which can be the baseline
projections if there was no simulation experiment to do.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def final_projections(self) -&gt; Projections:
    &#34;&#34;&#34;
    The final projections which can be the baseline
    projections if there was no simulation experiment to do.
    &#34;&#34;&#34;
    if not self.completed_successfully:
        raise Exception(&#34;The run has not yet completed so the final projections are not yet available.&#34;)
    if self._all_projections is Empty:
        raise Exception(&#34;The final projections are not yet available. Make sure you run the model before accessing them.&#34;)
    return self.all_projections[-1]</code></pre>
</details>
</dd>
<dt id="gcubed.runners.mock_advanced_runner.MockAdvancedRunner.model"><code class="name">var <span class="ident">model</span> : <a title="gcubed.model_configuration.ModelConfiguration" href="../model_configuration.html#gcubed.model_configuration.ModelConfiguration">ModelConfiguration</a></code></dt>
<dd>
<div class="desc"><p>The model being run.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def model(self) -&gt; ModelConfiguration:
    &#34;&#34;&#34;
    The model being run.
    &#34;&#34;&#34;
    return self._model</code></pre>
</details>
</dd>
<dt id="gcubed.runners.mock_advanced_runner.MockAdvancedRunner.most_recently_generated_projections"><code class="name">var <span class="ident">most_recently_generated_projections</span> : <a title="gcubed.projections.projections.Projections" href="../projections/projections.html#gcubed.projections.projections.Projections">Projections</a></code></dt>
<dd>
<div class="desc"><p>The projections most recently generated in the run.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def most_recently_generated_projections(self) -&gt; Projections:
    &#34;&#34;&#34;
    The projections most recently generated in the run.
    &#34;&#34;&#34;
    if self._all_projections is Empty:
        raise Exception(&#34;Projections are not yet available. Make sure you run the model before accessing them.&#34;)
    return self.all_projections[-1]</code></pre>
</details>
</dd>
<dt id="gcubed.runners.mock_advanced_runner.MockAdvancedRunner.relinearisation_years"><code class="name">var <span class="ident">relinearisation_years</span> : list[int]</code></dt>
<dd>
<div class="desc"><p>The (possibly empty) list of relinearisation years (all in YYYY format).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def relinearisation_years(self) -&gt; list[int]:
    &#34;&#34;&#34;
    The (possibly empty) list of relinearisation years (all in YYYY format).
    &#34;&#34;&#34;
    return self._relinearisation_years</code></pre>
</details>
</dd>
<dt id="gcubed.runners.mock_advanced_runner.MockAdvancedRunner.relinearise_in_event_years"><code class="name">var <span class="ident">relinearise_in_event_years</span> : bool</code></dt>
<dd>
<div class="desc"><p><code>True</code> if the runner is to relinearise the model in all event years
as well as the years specified and <code>False</code> if the runner is to relinearise the model only
in the years specified.</p>
<p>Defaults to <code>False</code>.</p>
<p>If necessary, modify this setting once the running is instantiated but
before the experiment is run.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def relinearise_in_event_years(self) -&gt; bool:
    &#34;&#34;&#34;
    `True` if the runner is to relinearise the model in all event years
    as well as the years specified and `False` if the runner is to relinearise the model only
    in the years specified.
    
    Defaults to `False`.

    If necessary, modify this setting once the running is instantiated but 
    before the experiment is run.
    &#34;&#34;&#34;
    return self._relinearise_in_event_years</code></pre>
</details>
</dd>
<dt id="gcubed.runners.mock_advanced_runner.MockAdvancedRunner.save_results"><code class="name">var <span class="ident">save_results</span> : bool</code></dt>
<dd>
<div class="desc"><p><code>True</code> if the results are to be saved to a results directory automatically at the end of the
run and <code>False</code> otherwise. </p>
<p>Defaults to False.</p>
<p>If necessary, modify this setting once the runner is instantiated but
before the experiment is run.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def save_results(self) -&gt; bool:
    &#34;&#34;&#34;
    `True` if the results are to be saved to a results directory automatically at the end of the
    run and `False` otherwise. 
    
    Defaults to False.

    If necessary, modify this setting once the runner is instantiated but 
    before the experiment is run.
    &#34;&#34;&#34;
    return self._save_results</code></pre>
</details>
</dd>
<dt id="gcubed.runners.mock_advanced_runner.MockAdvancedRunner.simulation_layer_definitions"><code class="name">var <span class="ident">simulation_layer_definitions</span> : <a title="gcubed.projections.simulation_layer_definitions.SimulationLayerDefinitions" href="../projections/simulation_layer_definitions.html#gcubed.projections.simulation_layer_definitions.SimulationLayerDefinitions">SimulationLayerDefinitions</a></code></dt>
<dd>
<div class="desc"><p>The simulation layer definitions documented in the experiment design.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def simulation_layer_definitions(self) -&gt; SimulationLayerDefinitions:
    &#34;&#34;&#34;
    The simulation layer definitions documented in the experiment design.
    &#34;&#34;&#34;
    if not hasattr(self, &#34;_simulation_layer_definitions&#34;):
        raise Exception(&#34;The simulation layer definitions have not been loaded yet.&#34;)
    return self._simulation_layer_definitions</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="gcubed.runners.mock_advanced_runner.MockAdvancedRunner.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="overview">Overview</h3>
<p>Do the actual work of running the model and performing
the experiment.</p>
<p>Call this method after creating a Runner instance.</p>
<p>Once the experiment has run, you can retrieve projections from
the simulation layer(s) of interest and the baseline for comparison and
analysis purposes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    &#34;&#34;&#34;
    ### Overview

    Do the actual work of running the model and performing 
    the experiment.
    
    Call this method after creating a Runner instance.

    Once the experiment has run, you can retrieve projections from
    the simulation layer(s) of interest and the baseline for comparison and
    analysis purposes.
    &#34;&#34;&#34;
    if self.save_results:
        log_file: str = os.path.join(self.results_directory, &#34;run.log&#34;)
        fh = logging.FileHandler(log_file, mode=&#39;w&#39;)
        logging.basicConfig(level=logging.DEBUG,
                            format=&#39;%(asctime)s %(levelname)s %(message)s&#39;,
                            handlers=[
                                fh,
                                logging.StreamHandler()
                            ])
        logging.info(f&#34;Saving results and logs to {self.results_directory}.&#34;)
    else:
        logging.basicConfig(level=logging.DEBUG,
                            format=&#39;%(asctime)s %(levelname)s %(message)s&#39;,
                            handlers=[
                                logging.StreamHandler()
                            ])
        logging.info(f&#34;Only logging to the console. No results being saved to files.&#34;)

    # Get the model stable manifold and related results for the baseline projections
    linear_model: LinearModel = LinearModel(model=self.model)
    state_space_form: StateSpaceForm = StateSpaceForm(linear_model=linear_model)
    stable_manifold: StableManifold = StableManifold(state_space_form=state_space_form)

    # Generate and store the baseline projections
    self.all_projections.append(BaselineProjections(stable_manifold=stable_manifold))

    # Generate the CSV file containing baseline projections
    if self.save_results:
        self.baseline_projections.publishable_projections.to_csv(f&#34;{self.results_directory}/baseline_projections.csv&#34;)
        logging.info(f&#34;Baseline publication projections have been saved to a CSV file in {self.results_directory}&#34;)

    # Load the simulation layer definitions from the experiment design file.
    self._simulation_layer_definitions = SimulationLayerDefinitions(sym_data=self.baseline_projections.sym_data)        
    self.simulation_layer_definitions.load_from_csv_file(design_file=self.experiment_design_file)
    
    self._event_years = self.simulation_layer_definitions.all_event_years_in_ascending_order

    if self.relinearise_in_event_years and self.experiment_design_file is not None:
        # Augment the list of relinearisation years.
        self.relinearisation_years = sorted(set(self.relinearisation_years).union(set(self.event_years)))
        logging.debug(f&#34;The combined event and relinearisation years are:\n{self.relinearisation_years}&#34;)

    # Step forward through the projection years and for each step check if we need to do 
    # a simulation or relinearisation.
    for year in range(self.baseline_projections.first_projection_year, self.baseline_projections.last_projection_year):
        
        # Do a relinearisation and add any relevant simulation layers while we are at it.
        if year in self.relinearisation_years:

            self.all_projections.append(
                MockRelinearisationProjections(
                    baseline_projections=self.baseline_projections, 
                    previous_projections=self.most_recently_generated_projections,
                    relinearisation_year=year, 
                    simulation_layer_definitions=self.simulation_layer_definitions
                    )
                )

            logging.info(f&#34;Generated relinearised projections from {self.most_recently_generated_projections.first_projection_year}.&#34;)
            continue

        if year in self.event_years:
            # Apply each simulation layer with this event year, one after the other.
            for simulation_layer_definition in self.simulation_layer_definitions.get_simulation_layer_definitions(event_year=year):

                self.all_projections.append(
                    SimulationLayer(
                        simulation_layer_definition=simulation_layer_definition,
                        previous_projections=self.most_recently_generated_projections
                        )
                    )
                
                logging.info(f&#34;Added {simulation_layer_definition.name} simulation layer to projections from {self.most_recently_generated_projections.first_projection_year}.&#34;)
            
            continue

    self._completed_successfully = True

    if self.save_results:
        # Generate the CSV file containing simulation projections
        self.final_projections.publishable_projections.to_csv(f&#34;{self.results_directory}/final_projections.csv&#34;)
        # Generate the CSV file containing the simulation deviation from baseline projections
        Projections.get_differences_between_projections(new_projections=self.final_projectionsl.publishable_projections, original_projections=self.baseline_projections.publishable_projections).to_csv(f&#34;{self.results_directory}/deviation_projections.csv&#34;)
        logging.info(f&#34;The simulation experiment results have been saved as CSV files in {self.results_directory}&#34;)
    else:
        logging.info(f&#34;The simulation experiment has run.&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gcubed.base.Base" href="../base.html#gcubed.base.Base">Base</a></b></code>:
<ul class="hlist">
<li><code><a title="gcubed.base.Base.get_year_labels" href="../base.html#gcubed.base.Base.get_year_labels">get_year_labels</a></code></li>
<li><code><a title="gcubed.base.Base.load_data" href="../base.html#gcubed.base.Base.load_data">load_data</a></code></li>
<li><code><a title="gcubed.base.Base.zeros" href="../base.html#gcubed.base.Base.zeros">zeros</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#this-runner-uses-the-mock-relinearisation-projections-only-used">This runner uses the mock relinearisation projections. Only used</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gcubed.runners" href="index.html">gcubed.runners</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gcubed.runners.mock_advanced_runner.MockAdvancedRunner" href="#gcubed.runners.mock_advanced_runner.MockAdvancedRunner">MockAdvancedRunner</a></code></h4>
<ul class="">
<li><code><a title="gcubed.runners.mock_advanced_runner.MockAdvancedRunner.all_projections" href="#gcubed.runners.mock_advanced_runner.MockAdvancedRunner.all_projections">all_projections</a></code></li>
<li><code><a title="gcubed.runners.mock_advanced_runner.MockAdvancedRunner.baseline_projections" href="#gcubed.runners.mock_advanced_runner.MockAdvancedRunner.baseline_projections">baseline_projections</a></code></li>
<li><code><a title="gcubed.runners.mock_advanced_runner.MockAdvancedRunner.completed_successfully" href="#gcubed.runners.mock_advanced_runner.MockAdvancedRunner.completed_successfully">completed_successfully</a></code></li>
<li><code><a title="gcubed.runners.mock_advanced_runner.MockAdvancedRunner.event_years" href="#gcubed.runners.mock_advanced_runner.MockAdvancedRunner.event_years">event_years</a></code></li>
<li><code><a title="gcubed.runners.mock_advanced_runner.MockAdvancedRunner.final_projections" href="#gcubed.runners.mock_advanced_runner.MockAdvancedRunner.final_projections">final_projections</a></code></li>
<li><code><a title="gcubed.runners.mock_advanced_runner.MockAdvancedRunner.model" href="#gcubed.runners.mock_advanced_runner.MockAdvancedRunner.model">model</a></code></li>
<li><code><a title="gcubed.runners.mock_advanced_runner.MockAdvancedRunner.most_recently_generated_projections" href="#gcubed.runners.mock_advanced_runner.MockAdvancedRunner.most_recently_generated_projections">most_recently_generated_projections</a></code></li>
<li><code><a title="gcubed.runners.mock_advanced_runner.MockAdvancedRunner.relinearisation_years" href="#gcubed.runners.mock_advanced_runner.MockAdvancedRunner.relinearisation_years">relinearisation_years</a></code></li>
<li><code><a title="gcubed.runners.mock_advanced_runner.MockAdvancedRunner.relinearise_in_event_years" href="#gcubed.runners.mock_advanced_runner.MockAdvancedRunner.relinearise_in_event_years">relinearise_in_event_years</a></code></li>
<li><code><a title="gcubed.runners.mock_advanced_runner.MockAdvancedRunner.run" href="#gcubed.runners.mock_advanced_runner.MockAdvancedRunner.run">run</a></code></li>
<li><code><a title="gcubed.runners.mock_advanced_runner.MockAdvancedRunner.save_results" href="#gcubed.runners.mock_advanced_runner.MockAdvancedRunner.save_results">save_results</a></code></li>
<li><code><a title="gcubed.runners.mock_advanced_runner.MockAdvancedRunner.simulation_layer_definitions" href="#gcubed.runners.mock_advanced_runner.MockAdvancedRunner.simulation_layer_definitions">simulation_layer_definitions</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
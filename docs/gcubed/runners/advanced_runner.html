<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gcubed.runners.advanced_runner API documentation</title>
<meta name="description" content="Contains the advanced runner class - used to run advanced model experiments." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gcubed.runners.advanced_runner</code></h1>
</header>
<section id="section-intro">
<p>Contains the advanced runner class - used to run advanced model experiments.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Contains the advanced runner class - used to run advanced model experiments.
&#34;&#34;&#34;
import os
import logging
from datetime import datetime
from gcubed.base import Base
from gcubed.constants import Constants
from gcubed.model_configuration import ModelConfiguration
from gcubed.model import Model
from gcubed.linearisation.linear_model import LinearModel
from gcubed.linearisation.state_space_form import StateSpaceForm
from gcubed.linearisation.stable_manifold import StableManifold
from gcubed.projections.projections import Projections
from gcubed.projections.baseline_projections import BaselineProjections
from gcubed.projections.simulation_experiment import SimulationExperiment
from gcubed.projections.simulation_layer_definitions import SimulationLayerDefinitions
from gcubed.projections.simulation_layer_definition import SimulationLayerDefinition
from gcubed.projections.simulation_layer import SimulationLayer
from gcubed.projections.relinearisation_projections import RelinearisationProjections

class AdvancedRunner(Base):
    &#34;&#34;&#34;

    ### Overview

    The AdvancedRunner class runs a simulation experiment 
    with G-Cubed that incorporates relinearisation in chosen years while
    allowing for strict or non-strict choice of points to linearise around
    and supporting simulation experiments using or not using relinearisation
    in their event years.

    1. The model is loaded and used to generate baseline projections.
    2. The experiment design is loaded, setting out each of the events being
    simulated as a separate simulation layer.
    3. The simulation layers are loaded and applied to the model to generate 
    projection updates. 
    
    Projections based on any of the simulation layers can be compared to projections
    from the baseline or from other simulation layers associated with the experiment.
    &#34;&#34;&#34;

    def __init__(self, working_directory:str, configuration_file: str, relinearisation_years: list[int], experiment_design_file: str = None):
        &#34;&#34;&#34;

        ### Overview

        Loads the configuration and the model, ready for running. Call the run method
        when you are ready to start model linearisation etc.

        The relinearisation of the model is done for each event year associated with
        a simulation layer and for each year nominated for relinearisation.

        ### Arguments
        
        working_directory: The directory where the results and logs are to be stored.

        configuration_file: The location of the configuration file, as an absolute path or relative to the 
        specified working directory.

        relinearisation_years: The list of years where a relinearisation is required. This list can be empty
        in which case the model is not relinearised.

        experiment_design_file: The optional location of the experiment design CSV file, as a relative path directory
        to the experiment design file from the simulations folder within the model folder (the model folder contains
        the configuration file).
        &#34;&#34;&#34;

        self.save_results = False

        self.relinearise_in_event_years = False

        if not os.path.isdir(working_directory):
            raise Exception(f&#34;{working_directory} is not a directory.&#34;)
        
        if not os.access(working_directory, os.W_OK):
            raise Exception(f&#34;You need write access to {working_directory} but that permission has not been granted to you.&#34;)

        if self.save_results:
            # Set up directory where results will be stored
            self.timestamp: str = datetime.now().strftime(&#34;%Y-%m-%d_%H-%M-%S&#34;)
            self.results_directory: str = os.path.join(working_directory, f&#34;results_{self.timestamp}&#34;)
            if not os.path.exists(self.results_directory):
                os.mkdir(self.results_directory)
            if not os.path.isdir(self.results_directory):
                raise Exception(f&#34;Results are to be stored in the directory {self.results_directory} but it is a file, not a directory.&#34;)

        # Get the absolute path to the model configuration file.
        if os.path.isabs(configuration_file):
            self.filename:str = configuration_file
        else:
            self.filename: str = os.path.join(working_directory, configuration_file)
        if not os.path.isfile(self.filename):
            raise Exception(f&#34;There is no model configuration file at {self.filename}.&#34;)
        logging.info(f&#34;The model configuration will be loaded from {self.filename}.&#34;)

        # Load the model
        model_configuration: ModelConfiguration = ModelConfiguration(configuration_file=self.filename)
        self._model: Model = Model(model_configuration)

        # Validate and save the list of relinearisation years.
        if relinearisation_years == None:
            self._relinearisation_years = []
        else:
            if not isinstance(relinearisation_years, list):
                raise Exception(&#34;You must specify a list of years in which the model is to be relinearised.&#34;)
            for year in relinearisation_years:
                if not isinstance(year, int):
                    raise Exception(&#34;The list of relinearisation years must contain YYYY formatted integers.&#34;)
            if len(relinearisation_years) != len(set(relinearisation_years)):
                raise Exception(&#34;There must not be duplicate relinearisation years.&#34;)
            if relinearisation_years != sorted(relinearisation_years):
                raise Exception(&#34;The list of relinearisation years must be in ascending order.&#34;)
            if relinearisation_years[0] &lt;= model_configuration.original_first_projection_year:
                raise Exception(&#34;The relinearisation years must be after the first projection year.&#34;)
            if relinearisation_years[-1] &gt;= model_configuration.last_projection_year:
                raise Exception(&#34;The relinearisation years must be before the last projection year.&#34;)
            self._relinearisation_years = relinearisation_years

        # Save the experiment design file for later use.
        self.experiment_design_file = experiment_design_file

    @property
    def model(self) -&gt; ModelConfiguration:
        &#34;&#34;&#34;
        The model being run.
        &#34;&#34;&#34;
        return self._model

    @property
    def relinearisation_years(self) -&gt; list[int]:
        &#34;&#34;&#34;
        The (possibly empty) list of relinearisation years (all in YYYY format).
        &#34;&#34;&#34;
        return self._relinearisation_years

    @property
    def event_years(self) -&gt; list[int]:
        &#34;&#34;&#34;
        The (possibly empty) list of event years (all in YYYY format).
        &#34;&#34;&#34;
        return self._event_years

    @property
    def baseline_projections(self) -&gt; BaselineProjections:
        &#34;&#34;&#34;
        The baseline projections.
        &#34;&#34;&#34;
        if not hasattr(self, &#34;_baseline_projections&#34;):
            raise Exception(&#34;The baseline projections are not yet available. Make sure you run the model before accessing them.&#34;)
        return self._baseline_projections
    
    @property
    def final_projections(self) -&gt; BaselineProjections:
        &#34;&#34;&#34;
        The final projections.
        &#34;&#34;&#34;
        if not hasattr(self, &#34;_final_projections&#34;):
            logging.warning(&#34;The final projections are not yet available. Make sure you run the model to completion before accessing them.&#34;)
        return self._final_projections
        
    @property
    def simulation_layer_definitions(self) -&gt; SimulationLayerDefinitions:
        &#34;&#34;&#34;
        The simulation layer definitions documented in the experiment design.
        &#34;&#34;&#34;
        if not hasattr(self, &#34;_simulation_layer_definitions&#34;):
            raise Exception(&#34;The simulation layer definitions have not been loaded yet.&#34;)
        return self._simulation_layer_definitions

    @property
    def save_results(self) -&gt; bool:
        &#34;&#34;&#34;
        True if the results are to be saved to a results folder automatically at the end of the
        run and false otherwise. 
        
        Defaults to False.

        If necessary, modify this setting once the running is instantiated but 
        before the experiment is run.
        &#34;&#34;&#34;
        return self._save_results

    @save_results.setter
    def save_results(self, value: bool) -&gt; bool:
        &#34;&#34;&#34;
        ### Overview
        
        Set the value to True if the results are to be saved to a 
        results folder automatically at the end of the run and false otherwise.
        &#34;&#34;&#34;
        assert value is not None
        assert isinstance(value, bool)
        self._save_results = value

    @property
    def relinearise_in_event_years(self) -&gt; bool:
        &#34;&#34;&#34;
        True if the runner is to relinearise the model in all event years
        as well as the years specified and false if the runner is to relinearise the model only
        in the years specified.
        
        Defaults to False.

        If necessary, modify this setting once the running is instantiated but 
        before the experiment is run.
        &#34;&#34;&#34;
        return self._relinearise_in_event_years

    @relinearise_in_event_years.setter
    def relinearise_in_event_years(self, value: bool) -&gt; bool:
        &#34;&#34;&#34;
        ### Overview
        
        Set the value to True if the runner is to relinearise the model in all event years
        as well as the years specified and false if the runner is to relinearise the model only
        in the years specified.
        &#34;&#34;&#34;
        assert value is not None
        assert isinstance(value, bool)
        self._relinearise_in_event_years = value

    def run(self):
        &#34;&#34;&#34;
        ### Overview

        Do the actual work of running the model and performing 
        the experiment.
        
        Call this method after creating a Runner instance.

        Once the experiment has run, you can retrieve projections from
        the simulation layer(s) of interest and the baseline for comparison and
        analysis purposes.
        &#34;&#34;&#34;
        if self.save_results:
            log_file: str = os.path.join(self.results_directory, &#34;run.log&#34;)
            fh = logging.FileHandler(log_file, mode=&#39;w&#39;)
            logging.basicConfig(level=logging.DEBUG,
                                format=&#39;%(asctime)s %(levelname)s %(message)s&#39;,
                                handlers=[
                                    fh,
                                    logging.StreamHandler()
                                ])
            logging.info(f&#34;Saving results and logs to {self.results_directory}.&#34;)
        else:
            logging.basicConfig(level=logging.DEBUG,
                                format=&#39;%(asctime)s %(levelname)s %(message)s&#39;,
                                handlers=[
                                    logging.StreamHandler()
                                ])
            logging.info(f&#34;Only logging to the console. No results being saved to files.&#34;)

        # Get the model stable manifold and related results
        linear_model: LinearModel = LinearModel(model=self.model)
        state_space_form: StateSpaceForm = StateSpaceForm(linear_model=linear_model)
        stable_manifold: StableManifold = StableManifold(state_space_form=state_space_form)

        # Generate the baseline projections
        self._baseline_projections: BaselineProjections = BaselineProjections(stable_manifold=stable_manifold)

        # Generate the CSV file containing baseline projections
        if self.save_results:
            self.baseline_projections.publishable_projections.to_csv(f&#34;{self.results_directory}/baseline_projections.csv&#34;)
            logging.info(f&#34;Baseline publication projections have been saved to a CSV file in {self.results_directory}&#34;)

        # Load the simulation layer definitions from the experiment design file.
        self._simulation_layer_definitions = SimulationLayerDefinitions(sym_data=self.baseline_projections.sym_data)        
        self.simulation_layer_definitions.load_from_csv_file(design_file=self.experiment_design_file)
        
        self._event_years = self.simulation_layer_definitions.all_event_years_in_ascending_order

        if self.relinearise_in_event_years and self.experiment_design_file is not None:
            # Augment the list of relinearisation years.
            self.relinearisation_years = sorted(set(self.relinearisation_years).union(set(self.event_years)))
            logging.debug(f&#34;The combined event and relinearisation years are:\n{self.relinearisation_years}&#34;)

        # Start with the original baseline projections
        old_projections = self.baseline_projections

        # Step forward through the projection years and for each step check if we need to do 
        # a simulation or relinearisation.
        for year in range(self.baseline_projections.first_projection_year, self.model.configuration.last_projection_year):

            if year in self.relinearisation_years:
                # Do a relinearisation and add any relevant simulation layers while we are at it.
                # logging.debug(f&#34;{old_projections.first_projection_year} database projections\n{old_projections.database_projections.loc[Constants().REPORTING_VARIABLES, Constants().REPORTING_YEARS]}&#34;)

                new_projections: Projections = RelinearisationProjections(
                    baseline_projections=self.baseline_projections, 
                    previous_projections=old_projections, 
                    relinearisation_year=year, 
                    simulation_layer_definitions=self.simulation_layer_definitions)

                old_projections = new_projections
                logging.info(f&#34;Generated the relinearised projections with first projection year {new_projections.first_projection_year}&#34;)
                continue

            if year in self.event_years:
                # Apply each simulation layer with this event year, one after the other.
                for simulation_layer_definition in self.simulation_layer_definitions.get_simulation_layer_definitions(event_year=year):
                    new_projections: Projections = SimulationLayer(
                        simulation_layer_definition=simulation_layer_definition,
                        previous_projections=old_projections
                    )
                    old_projections = new_projections
                    logging.info(f&#34;Generated projections for the {simulation_layer_definition.name} simulation layer without relinearisation.&#34;)
                continue

            continue

        self._final_projections: Projections = new_projections

        if self.save_results:
            # Generate the CSV file containing simulation projections
            new_projections.publishable_projections.to_csv(f&#34;{self.results_directory}/simulation_projections.csv&#34;)
            # Generate the CSV file containing the simulation deviation from baseline projections
            Projections.get_differences_between_projections(new_projections=new_projections.publishable_projections, original_projections=self.baseline_projections.publishable_projections).to_csv(f&#34;{self.results_directory}/deviation_projections.csv&#34;)
            logging.info(f&#34;The simulation experiment results have been saved as CSV files in {self.results_directory}&#34;)
        else:
            logging.info(f&#34;The simulation experiment has run.&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gcubed.runners.advanced_runner.AdvancedRunner"><code class="flex name class">
<span>class <span class="ident">AdvancedRunner</span></span>
<span>(</span><span>working_directory: str, configuration_file: str, relinearisation_years: list[int], experiment_design_file: str = None)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="overview">Overview</h3>
<p>The AdvancedRunner class runs a simulation experiment
with G-Cubed that incorporates relinearisation in chosen years while
allowing for strict or non-strict choice of points to linearise around
and supporting simulation experiments using or not using relinearisation
in their event years.</p>
<ol>
<li>The model is loaded and used to generate baseline projections.</li>
<li>The experiment design is loaded, setting out each of the events being
simulated as a separate simulation layer.</li>
<li>The simulation layers are loaded and applied to the model to generate
projection updates. </li>
</ol>
<p>Projections based on any of the simulation layers can be compared to projections
from the baseline or from other simulation layers associated with the experiment.</p>
<h3 id="overview_1">Overview</h3>
<p>Loads the configuration and the model, ready for running. Call the run method
when you are ready to start model linearisation etc.</p>
<p>The relinearisation of the model is done for each event year associated with
a simulation layer and for each year nominated for relinearisation.</p>
<h3 id="arguments">Arguments</h3>
<p>working_directory: The directory where the results and logs are to be stored.</p>
<p>configuration_file: The location of the configuration file, as an absolute path or relative to the
specified working directory.</p>
<p>relinearisation_years: The list of years where a relinearisation is required. This list can be empty
in which case the model is not relinearised.</p>
<p>experiment_design_file: The optional location of the experiment design CSV file, as a relative path directory
to the experiment design file from the simulations folder within the model folder (the model folder contains
the configuration file).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AdvancedRunner(Base):
    &#34;&#34;&#34;

    ### Overview

    The AdvancedRunner class runs a simulation experiment 
    with G-Cubed that incorporates relinearisation in chosen years while
    allowing for strict or non-strict choice of points to linearise around
    and supporting simulation experiments using or not using relinearisation
    in their event years.

    1. The model is loaded and used to generate baseline projections.
    2. The experiment design is loaded, setting out each of the events being
    simulated as a separate simulation layer.
    3. The simulation layers are loaded and applied to the model to generate 
    projection updates. 
    
    Projections based on any of the simulation layers can be compared to projections
    from the baseline or from other simulation layers associated with the experiment.
    &#34;&#34;&#34;

    def __init__(self, working_directory:str, configuration_file: str, relinearisation_years: list[int], experiment_design_file: str = None):
        &#34;&#34;&#34;

        ### Overview

        Loads the configuration and the model, ready for running. Call the run method
        when you are ready to start model linearisation etc.

        The relinearisation of the model is done for each event year associated with
        a simulation layer and for each year nominated for relinearisation.

        ### Arguments
        
        working_directory: The directory where the results and logs are to be stored.

        configuration_file: The location of the configuration file, as an absolute path or relative to the 
        specified working directory.

        relinearisation_years: The list of years where a relinearisation is required. This list can be empty
        in which case the model is not relinearised.

        experiment_design_file: The optional location of the experiment design CSV file, as a relative path directory
        to the experiment design file from the simulations folder within the model folder (the model folder contains
        the configuration file).
        &#34;&#34;&#34;

        self.save_results = False

        self.relinearise_in_event_years = False

        if not os.path.isdir(working_directory):
            raise Exception(f&#34;{working_directory} is not a directory.&#34;)
        
        if not os.access(working_directory, os.W_OK):
            raise Exception(f&#34;You need write access to {working_directory} but that permission has not been granted to you.&#34;)

        if self.save_results:
            # Set up directory where results will be stored
            self.timestamp: str = datetime.now().strftime(&#34;%Y-%m-%d_%H-%M-%S&#34;)
            self.results_directory: str = os.path.join(working_directory, f&#34;results_{self.timestamp}&#34;)
            if not os.path.exists(self.results_directory):
                os.mkdir(self.results_directory)
            if not os.path.isdir(self.results_directory):
                raise Exception(f&#34;Results are to be stored in the directory {self.results_directory} but it is a file, not a directory.&#34;)

        # Get the absolute path to the model configuration file.
        if os.path.isabs(configuration_file):
            self.filename:str = configuration_file
        else:
            self.filename: str = os.path.join(working_directory, configuration_file)
        if not os.path.isfile(self.filename):
            raise Exception(f&#34;There is no model configuration file at {self.filename}.&#34;)
        logging.info(f&#34;The model configuration will be loaded from {self.filename}.&#34;)

        # Load the model
        model_configuration: ModelConfiguration = ModelConfiguration(configuration_file=self.filename)
        self._model: Model = Model(model_configuration)

        # Validate and save the list of relinearisation years.
        if relinearisation_years == None:
            self._relinearisation_years = []
        else:
            if not isinstance(relinearisation_years, list):
                raise Exception(&#34;You must specify a list of years in which the model is to be relinearised.&#34;)
            for year in relinearisation_years:
                if not isinstance(year, int):
                    raise Exception(&#34;The list of relinearisation years must contain YYYY formatted integers.&#34;)
            if len(relinearisation_years) != len(set(relinearisation_years)):
                raise Exception(&#34;There must not be duplicate relinearisation years.&#34;)
            if relinearisation_years != sorted(relinearisation_years):
                raise Exception(&#34;The list of relinearisation years must be in ascending order.&#34;)
            if relinearisation_years[0] &lt;= model_configuration.original_first_projection_year:
                raise Exception(&#34;The relinearisation years must be after the first projection year.&#34;)
            if relinearisation_years[-1] &gt;= model_configuration.last_projection_year:
                raise Exception(&#34;The relinearisation years must be before the last projection year.&#34;)
            self._relinearisation_years = relinearisation_years

        # Save the experiment design file for later use.
        self.experiment_design_file = experiment_design_file

    @property
    def model(self) -&gt; ModelConfiguration:
        &#34;&#34;&#34;
        The model being run.
        &#34;&#34;&#34;
        return self._model

    @property
    def relinearisation_years(self) -&gt; list[int]:
        &#34;&#34;&#34;
        The (possibly empty) list of relinearisation years (all in YYYY format).
        &#34;&#34;&#34;
        return self._relinearisation_years

    @property
    def event_years(self) -&gt; list[int]:
        &#34;&#34;&#34;
        The (possibly empty) list of event years (all in YYYY format).
        &#34;&#34;&#34;
        return self._event_years

    @property
    def baseline_projections(self) -&gt; BaselineProjections:
        &#34;&#34;&#34;
        The baseline projections.
        &#34;&#34;&#34;
        if not hasattr(self, &#34;_baseline_projections&#34;):
            raise Exception(&#34;The baseline projections are not yet available. Make sure you run the model before accessing them.&#34;)
        return self._baseline_projections
    
    @property
    def final_projections(self) -&gt; BaselineProjections:
        &#34;&#34;&#34;
        The final projections.
        &#34;&#34;&#34;
        if not hasattr(self, &#34;_final_projections&#34;):
            logging.warning(&#34;The final projections are not yet available. Make sure you run the model to completion before accessing them.&#34;)
        return self._final_projections
        
    @property
    def simulation_layer_definitions(self) -&gt; SimulationLayerDefinitions:
        &#34;&#34;&#34;
        The simulation layer definitions documented in the experiment design.
        &#34;&#34;&#34;
        if not hasattr(self, &#34;_simulation_layer_definitions&#34;):
            raise Exception(&#34;The simulation layer definitions have not been loaded yet.&#34;)
        return self._simulation_layer_definitions

    @property
    def save_results(self) -&gt; bool:
        &#34;&#34;&#34;
        True if the results are to be saved to a results folder automatically at the end of the
        run and false otherwise. 
        
        Defaults to False.

        If necessary, modify this setting once the running is instantiated but 
        before the experiment is run.
        &#34;&#34;&#34;
        return self._save_results

    @save_results.setter
    def save_results(self, value: bool) -&gt; bool:
        &#34;&#34;&#34;
        ### Overview
        
        Set the value to True if the results are to be saved to a 
        results folder automatically at the end of the run and false otherwise.
        &#34;&#34;&#34;
        assert value is not None
        assert isinstance(value, bool)
        self._save_results = value

    @property
    def relinearise_in_event_years(self) -&gt; bool:
        &#34;&#34;&#34;
        True if the runner is to relinearise the model in all event years
        as well as the years specified and false if the runner is to relinearise the model only
        in the years specified.
        
        Defaults to False.

        If necessary, modify this setting once the running is instantiated but 
        before the experiment is run.
        &#34;&#34;&#34;
        return self._relinearise_in_event_years

    @relinearise_in_event_years.setter
    def relinearise_in_event_years(self, value: bool) -&gt; bool:
        &#34;&#34;&#34;
        ### Overview
        
        Set the value to True if the runner is to relinearise the model in all event years
        as well as the years specified and false if the runner is to relinearise the model only
        in the years specified.
        &#34;&#34;&#34;
        assert value is not None
        assert isinstance(value, bool)
        self._relinearise_in_event_years = value

    def run(self):
        &#34;&#34;&#34;
        ### Overview

        Do the actual work of running the model and performing 
        the experiment.
        
        Call this method after creating a Runner instance.

        Once the experiment has run, you can retrieve projections from
        the simulation layer(s) of interest and the baseline for comparison and
        analysis purposes.
        &#34;&#34;&#34;
        if self.save_results:
            log_file: str = os.path.join(self.results_directory, &#34;run.log&#34;)
            fh = logging.FileHandler(log_file, mode=&#39;w&#39;)
            logging.basicConfig(level=logging.DEBUG,
                                format=&#39;%(asctime)s %(levelname)s %(message)s&#39;,
                                handlers=[
                                    fh,
                                    logging.StreamHandler()
                                ])
            logging.info(f&#34;Saving results and logs to {self.results_directory}.&#34;)
        else:
            logging.basicConfig(level=logging.DEBUG,
                                format=&#39;%(asctime)s %(levelname)s %(message)s&#39;,
                                handlers=[
                                    logging.StreamHandler()
                                ])
            logging.info(f&#34;Only logging to the console. No results being saved to files.&#34;)

        # Get the model stable manifold and related results
        linear_model: LinearModel = LinearModel(model=self.model)
        state_space_form: StateSpaceForm = StateSpaceForm(linear_model=linear_model)
        stable_manifold: StableManifold = StableManifold(state_space_form=state_space_form)

        # Generate the baseline projections
        self._baseline_projections: BaselineProjections = BaselineProjections(stable_manifold=stable_manifold)

        # Generate the CSV file containing baseline projections
        if self.save_results:
            self.baseline_projections.publishable_projections.to_csv(f&#34;{self.results_directory}/baseline_projections.csv&#34;)
            logging.info(f&#34;Baseline publication projections have been saved to a CSV file in {self.results_directory}&#34;)

        # Load the simulation layer definitions from the experiment design file.
        self._simulation_layer_definitions = SimulationLayerDefinitions(sym_data=self.baseline_projections.sym_data)        
        self.simulation_layer_definitions.load_from_csv_file(design_file=self.experiment_design_file)
        
        self._event_years = self.simulation_layer_definitions.all_event_years_in_ascending_order

        if self.relinearise_in_event_years and self.experiment_design_file is not None:
            # Augment the list of relinearisation years.
            self.relinearisation_years = sorted(set(self.relinearisation_years).union(set(self.event_years)))
            logging.debug(f&#34;The combined event and relinearisation years are:\n{self.relinearisation_years}&#34;)

        # Start with the original baseline projections
        old_projections = self.baseline_projections

        # Step forward through the projection years and for each step check if we need to do 
        # a simulation or relinearisation.
        for year in range(self.baseline_projections.first_projection_year, self.model.configuration.last_projection_year):

            if year in self.relinearisation_years:
                # Do a relinearisation and add any relevant simulation layers while we are at it.
                # logging.debug(f&#34;{old_projections.first_projection_year} database projections\n{old_projections.database_projections.loc[Constants().REPORTING_VARIABLES, Constants().REPORTING_YEARS]}&#34;)

                new_projections: Projections = RelinearisationProjections(
                    baseline_projections=self.baseline_projections, 
                    previous_projections=old_projections, 
                    relinearisation_year=year, 
                    simulation_layer_definitions=self.simulation_layer_definitions)

                old_projections = new_projections
                logging.info(f&#34;Generated the relinearised projections with first projection year {new_projections.first_projection_year}&#34;)
                continue

            if year in self.event_years:
                # Apply each simulation layer with this event year, one after the other.
                for simulation_layer_definition in self.simulation_layer_definitions.get_simulation_layer_definitions(event_year=year):
                    new_projections: Projections = SimulationLayer(
                        simulation_layer_definition=simulation_layer_definition,
                        previous_projections=old_projections
                    )
                    old_projections = new_projections
                    logging.info(f&#34;Generated projections for the {simulation_layer_definition.name} simulation layer without relinearisation.&#34;)
                continue

            continue

        self._final_projections: Projections = new_projections

        if self.save_results:
            # Generate the CSV file containing simulation projections
            new_projections.publishable_projections.to_csv(f&#34;{self.results_directory}/simulation_projections.csv&#34;)
            # Generate the CSV file containing the simulation deviation from baseline projections
            Projections.get_differences_between_projections(new_projections=new_projections.publishable_projections, original_projections=self.baseline_projections.publishable_projections).to_csv(f&#34;{self.results_directory}/deviation_projections.csv&#34;)
            logging.info(f&#34;The simulation experiment results have been saved as CSV files in {self.results_directory}&#34;)
        else:
            logging.info(f&#34;The simulation experiment has run.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gcubed.base.Base" href="../base.html#gcubed.base.Base">Base</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="gcubed.runners.advanced_runner.AdvancedRunner.baseline_projections"><code class="name">var <span class="ident">baseline_projections</span> : <a title="gcubed.projections.baseline_projections.BaselineProjections" href="../projections/baseline_projections.html#gcubed.projections.baseline_projections.BaselineProjections">BaselineProjections</a></code></dt>
<dd>
<div class="desc"><p>The baseline projections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def baseline_projections(self) -&gt; BaselineProjections:
    &#34;&#34;&#34;
    The baseline projections.
    &#34;&#34;&#34;
    if not hasattr(self, &#34;_baseline_projections&#34;):
        raise Exception(&#34;The baseline projections are not yet available. Make sure you run the model before accessing them.&#34;)
    return self._baseline_projections</code></pre>
</details>
</dd>
<dt id="gcubed.runners.advanced_runner.AdvancedRunner.event_years"><code class="name">var <span class="ident">event_years</span> : list[int]</code></dt>
<dd>
<div class="desc"><p>The (possibly empty) list of event years (all in YYYY format).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def event_years(self) -&gt; list[int]:
    &#34;&#34;&#34;
    The (possibly empty) list of event years (all in YYYY format).
    &#34;&#34;&#34;
    return self._event_years</code></pre>
</details>
</dd>
<dt id="gcubed.runners.advanced_runner.AdvancedRunner.final_projections"><code class="name">var <span class="ident">final_projections</span> : <a title="gcubed.projections.baseline_projections.BaselineProjections" href="../projections/baseline_projections.html#gcubed.projections.baseline_projections.BaselineProjections">BaselineProjections</a></code></dt>
<dd>
<div class="desc"><p>The final projections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def final_projections(self) -&gt; BaselineProjections:
    &#34;&#34;&#34;
    The final projections.
    &#34;&#34;&#34;
    if not hasattr(self, &#34;_final_projections&#34;):
        logging.warning(&#34;The final projections are not yet available. Make sure you run the model to completion before accessing them.&#34;)
    return self._final_projections</code></pre>
</details>
</dd>
<dt id="gcubed.runners.advanced_runner.AdvancedRunner.model"><code class="name">var <span class="ident">model</span> : <a title="gcubed.model_configuration.ModelConfiguration" href="../model_configuration.html#gcubed.model_configuration.ModelConfiguration">ModelConfiguration</a></code></dt>
<dd>
<div class="desc"><p>The model being run.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def model(self) -&gt; ModelConfiguration:
    &#34;&#34;&#34;
    The model being run.
    &#34;&#34;&#34;
    return self._model</code></pre>
</details>
</dd>
<dt id="gcubed.runners.advanced_runner.AdvancedRunner.relinearisation_years"><code class="name">var <span class="ident">relinearisation_years</span> : list[int]</code></dt>
<dd>
<div class="desc"><p>The (possibly empty) list of relinearisation years (all in YYYY format).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def relinearisation_years(self) -&gt; list[int]:
    &#34;&#34;&#34;
    The (possibly empty) list of relinearisation years (all in YYYY format).
    &#34;&#34;&#34;
    return self._relinearisation_years</code></pre>
</details>
</dd>
<dt id="gcubed.runners.advanced_runner.AdvancedRunner.relinearise_in_event_years"><code class="name">var <span class="ident">relinearise_in_event_years</span> : bool</code></dt>
<dd>
<div class="desc"><p>True if the runner is to relinearise the model in all event years
as well as the years specified and false if the runner is to relinearise the model only
in the years specified.</p>
<p>Defaults to False.</p>
<p>If necessary, modify this setting once the running is instantiated but
before the experiment is run.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def relinearise_in_event_years(self) -&gt; bool:
    &#34;&#34;&#34;
    True if the runner is to relinearise the model in all event years
    as well as the years specified and false if the runner is to relinearise the model only
    in the years specified.
    
    Defaults to False.

    If necessary, modify this setting once the running is instantiated but 
    before the experiment is run.
    &#34;&#34;&#34;
    return self._relinearise_in_event_years</code></pre>
</details>
</dd>
<dt id="gcubed.runners.advanced_runner.AdvancedRunner.save_results"><code class="name">var <span class="ident">save_results</span> : bool</code></dt>
<dd>
<div class="desc"><p>True if the results are to be saved to a results folder automatically at the end of the
run and false otherwise. </p>
<p>Defaults to False.</p>
<p>If necessary, modify this setting once the running is instantiated but
before the experiment is run.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def save_results(self) -&gt; bool:
    &#34;&#34;&#34;
    True if the results are to be saved to a results folder automatically at the end of the
    run and false otherwise. 
    
    Defaults to False.

    If necessary, modify this setting once the running is instantiated but 
    before the experiment is run.
    &#34;&#34;&#34;
    return self._save_results</code></pre>
</details>
</dd>
<dt id="gcubed.runners.advanced_runner.AdvancedRunner.simulation_layer_definitions"><code class="name">var <span class="ident">simulation_layer_definitions</span> : <a title="gcubed.projections.simulation_layer_definitions.SimulationLayerDefinitions" href="../projections/simulation_layer_definitions.html#gcubed.projections.simulation_layer_definitions.SimulationLayerDefinitions">SimulationLayerDefinitions</a></code></dt>
<dd>
<div class="desc"><p>The simulation layer definitions documented in the experiment design.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def simulation_layer_definitions(self) -&gt; SimulationLayerDefinitions:
    &#34;&#34;&#34;
    The simulation layer definitions documented in the experiment design.
    &#34;&#34;&#34;
    if not hasattr(self, &#34;_simulation_layer_definitions&#34;):
        raise Exception(&#34;The simulation layer definitions have not been loaded yet.&#34;)
    return self._simulation_layer_definitions</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="gcubed.runners.advanced_runner.AdvancedRunner.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="overview">Overview</h3>
<p>Do the actual work of running the model and performing
the experiment.</p>
<p>Call this method after creating a Runner instance.</p>
<p>Once the experiment has run, you can retrieve projections from
the simulation layer(s) of interest and the baseline for comparison and
analysis purposes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    &#34;&#34;&#34;
    ### Overview

    Do the actual work of running the model and performing 
    the experiment.
    
    Call this method after creating a Runner instance.

    Once the experiment has run, you can retrieve projections from
    the simulation layer(s) of interest and the baseline for comparison and
    analysis purposes.
    &#34;&#34;&#34;
    if self.save_results:
        log_file: str = os.path.join(self.results_directory, &#34;run.log&#34;)
        fh = logging.FileHandler(log_file, mode=&#39;w&#39;)
        logging.basicConfig(level=logging.DEBUG,
                            format=&#39;%(asctime)s %(levelname)s %(message)s&#39;,
                            handlers=[
                                fh,
                                logging.StreamHandler()
                            ])
        logging.info(f&#34;Saving results and logs to {self.results_directory}.&#34;)
    else:
        logging.basicConfig(level=logging.DEBUG,
                            format=&#39;%(asctime)s %(levelname)s %(message)s&#39;,
                            handlers=[
                                logging.StreamHandler()
                            ])
        logging.info(f&#34;Only logging to the console. No results being saved to files.&#34;)

    # Get the model stable manifold and related results
    linear_model: LinearModel = LinearModel(model=self.model)
    state_space_form: StateSpaceForm = StateSpaceForm(linear_model=linear_model)
    stable_manifold: StableManifold = StableManifold(state_space_form=state_space_form)

    # Generate the baseline projections
    self._baseline_projections: BaselineProjections = BaselineProjections(stable_manifold=stable_manifold)

    # Generate the CSV file containing baseline projections
    if self.save_results:
        self.baseline_projections.publishable_projections.to_csv(f&#34;{self.results_directory}/baseline_projections.csv&#34;)
        logging.info(f&#34;Baseline publication projections have been saved to a CSV file in {self.results_directory}&#34;)

    # Load the simulation layer definitions from the experiment design file.
    self._simulation_layer_definitions = SimulationLayerDefinitions(sym_data=self.baseline_projections.sym_data)        
    self.simulation_layer_definitions.load_from_csv_file(design_file=self.experiment_design_file)
    
    self._event_years = self.simulation_layer_definitions.all_event_years_in_ascending_order

    if self.relinearise_in_event_years and self.experiment_design_file is not None:
        # Augment the list of relinearisation years.
        self.relinearisation_years = sorted(set(self.relinearisation_years).union(set(self.event_years)))
        logging.debug(f&#34;The combined event and relinearisation years are:\n{self.relinearisation_years}&#34;)

    # Start with the original baseline projections
    old_projections = self.baseline_projections

    # Step forward through the projection years and for each step check if we need to do 
    # a simulation or relinearisation.
    for year in range(self.baseline_projections.first_projection_year, self.model.configuration.last_projection_year):

        if year in self.relinearisation_years:
            # Do a relinearisation and add any relevant simulation layers while we are at it.
            # logging.debug(f&#34;{old_projections.first_projection_year} database projections\n{old_projections.database_projections.loc[Constants().REPORTING_VARIABLES, Constants().REPORTING_YEARS]}&#34;)

            new_projections: Projections = RelinearisationProjections(
                baseline_projections=self.baseline_projections, 
                previous_projections=old_projections, 
                relinearisation_year=year, 
                simulation_layer_definitions=self.simulation_layer_definitions)

            old_projections = new_projections
            logging.info(f&#34;Generated the relinearised projections with first projection year {new_projections.first_projection_year}&#34;)
            continue

        if year in self.event_years:
            # Apply each simulation layer with this event year, one after the other.
            for simulation_layer_definition in self.simulation_layer_definitions.get_simulation_layer_definitions(event_year=year):
                new_projections: Projections = SimulationLayer(
                    simulation_layer_definition=simulation_layer_definition,
                    previous_projections=old_projections
                )
                old_projections = new_projections
                logging.info(f&#34;Generated projections for the {simulation_layer_definition.name} simulation layer without relinearisation.&#34;)
            continue

        continue

    self._final_projections: Projections = new_projections

    if self.save_results:
        # Generate the CSV file containing simulation projections
        new_projections.publishable_projections.to_csv(f&#34;{self.results_directory}/simulation_projections.csv&#34;)
        # Generate the CSV file containing the simulation deviation from baseline projections
        Projections.get_differences_between_projections(new_projections=new_projections.publishable_projections, original_projections=self.baseline_projections.publishable_projections).to_csv(f&#34;{self.results_directory}/deviation_projections.csv&#34;)
        logging.info(f&#34;The simulation experiment results have been saved as CSV files in {self.results_directory}&#34;)
    else:
        logging.info(f&#34;The simulation experiment has run.&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gcubed.base.Base" href="../base.html#gcubed.base.Base">Base</a></b></code>:
<ul class="hlist">
<li><code><a title="gcubed.base.Base.get_year_labels" href="../base.html#gcubed.base.Base.get_year_labels">get_year_labels</a></code></li>
<li><code><a title="gcubed.base.Base.load_data" href="../base.html#gcubed.base.Base.load_data">load_data</a></code></li>
<li><code><a title="gcubed.base.Base.zeros" href="../base.html#gcubed.base.Base.zeros">zeros</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gcubed.runners" href="index.html">gcubed.runners</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gcubed.runners.advanced_runner.AdvancedRunner" href="#gcubed.runners.advanced_runner.AdvancedRunner">AdvancedRunner</a></code></h4>
<ul class="">
<li><code><a title="gcubed.runners.advanced_runner.AdvancedRunner.baseline_projections" href="#gcubed.runners.advanced_runner.AdvancedRunner.baseline_projections">baseline_projections</a></code></li>
<li><code><a title="gcubed.runners.advanced_runner.AdvancedRunner.event_years" href="#gcubed.runners.advanced_runner.AdvancedRunner.event_years">event_years</a></code></li>
<li><code><a title="gcubed.runners.advanced_runner.AdvancedRunner.final_projections" href="#gcubed.runners.advanced_runner.AdvancedRunner.final_projections">final_projections</a></code></li>
<li><code><a title="gcubed.runners.advanced_runner.AdvancedRunner.model" href="#gcubed.runners.advanced_runner.AdvancedRunner.model">model</a></code></li>
<li><code><a title="gcubed.runners.advanced_runner.AdvancedRunner.relinearisation_years" href="#gcubed.runners.advanced_runner.AdvancedRunner.relinearisation_years">relinearisation_years</a></code></li>
<li><code><a title="gcubed.runners.advanced_runner.AdvancedRunner.relinearise_in_event_years" href="#gcubed.runners.advanced_runner.AdvancedRunner.relinearise_in_event_years">relinearise_in_event_years</a></code></li>
<li><code><a title="gcubed.runners.advanced_runner.AdvancedRunner.run" href="#gcubed.runners.advanced_runner.AdvancedRunner.run">run</a></code></li>
<li><code><a title="gcubed.runners.advanced_runner.AdvancedRunner.save_results" href="#gcubed.runners.advanced_runner.AdvancedRunner.save_results">save_results</a></code></li>
<li><code><a title="gcubed.runners.advanced_runner.AdvancedRunner.simulation_layer_definitions" href="#gcubed.runners.advanced_runner.AdvancedRunner.simulation_layer_definitions">simulation_layer_definitions</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
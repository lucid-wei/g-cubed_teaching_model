<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gcubed.projections.baseline_projections API documentation</title>
<meta name="description" content="Contains the BaselineProjections class, for doing baseline projections." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gcubed.projections.baseline_projections</code></h1>
</header>
<section id="section-intro">
<p>Contains the BaselineProjections class, for doing baseline projections.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># ------------------------------------------------------------------
# Purpose: Compute and provide access to baseline projections.
# Author: Geoff Shuetrim
# ------------------------------------------------------------------
&#34;&#34;&#34;
Contains the BaselineProjections class, for doing baseline projections.
&#34;&#34;&#34;
import logging
import pandas as pd
import numpy as np
from gcubed.linearisation.stable_manifold import StableManifold
from gcubed.model import Model
from gcubed.linearisation.state_space_form import StateSpaceForm
from gcubed.sym_data import SymData
from gcubed.model_parameters.parameters import Parameters
from gcubed.model_configuration import ModelConfiguration
from gcubed.data.gdp_scaled_database import GDPScaledDatabase
from gcubed.baseline.effective_labour_productivity import EffectiveLabourProductivity
from gcubed.baseline.energy_usage_efficiency import EnergyUsageEfficiency
from gcubed.projections.projections import Projections


class BaselineProjections(Projections):
    &#34;&#34;&#34;
    ### Overview

    Compute the baseline model projections over the projection horizon 
    from the first projection year (a year with available data to be 
    matched by the projections) through to the last projection year.
    &#34;&#34;&#34;

    # The perturbation to use when computing partial derivatives for intertemporal constant determination.
    PERTURBATION = 0.0001

    def __init__(self, stable_manifold: StableManifold) -&gt; None:
        &#34;&#34;&#34;
       ### Arguments

        stable_manifold: The stable manifold that provides access to all 
        of the model information required to produce projections.
        &#34;&#34;&#34;
        logging.info(&#34;Setting up the baseline projections.&#34;)

        super().__init__(stable_manifold=stable_manifold)
        self._is_baseline_projections = True
        
        self._database = GDPScaledDatabase(database=self.model.database, base_year=self.configuration.base_year)

        self.__set_first_projection_year_observed_values()

        self.__store_observed_yxr_values_in_first_projection_year()

        # Set up the exogenous variable projections
        self.__create_exogenous_variable_projections()

        self.__store_observed_values_of_variables_adjusted_by_intertemporal_constants_in_first_projection_year()
        self.__compute_first_projection_year_ssf_deviations_from_observed_values()

        if not self.using_rolled_projections:
            self.__calculate_intertemporal_constants()

        # Generate the baseline projections
        self._generate_projections()

        # Generate the database projections
        self._generate_database_projections()

        # Generate publishable version of the projections
        self._generate_publishable_projections()

        self.__validate()


    def __validate(self):
        &#34;&#34;&#34;
        TODO:  Validate the projections: 
        1. check that they are available for the expected projection years.
        2. Check that the base year projections are equal to the base year data values.
        &#34;&#34;&#34;
        logging.info(&#34;The baseline projections have been generated.&#34;)

    @property
    def database(self) -&gt; GDPScaledDatabase:
        &#34;&#34;&#34;
        The database used as the starting point for the projections.
        &#34;&#34;&#34;
        return self._database

    @property
    def using_rolled_projections(self) -&gt; bool:
        &#34;&#34;&#34;
        True if these projections are building on
        previous projections rather than just observed data.

        This affects how the baseline projections are set up in terms
        of the constants used.
        &#34;&#34;&#34;
        return self.database.has_data_for_all_projection_years

    def __update_perturbed_variable(self, variable_details: pd.Series):
        &#34;&#34;&#34;
        ### Overview

        Changes the perturbed variable, preparing for the
        next evaluation of the values needed to compute
        partial derivatives relevant to the determination 
        of the intertemporal constants.
        &#34;&#34;&#34;

        if hasattr(self, &#39;_perturbed_variable_details&#39;):
            sequence = self._perturbed_variable_details[&#39;sequence&#39;]
            match self._perturbed_variable_details[&#39;var_type&#39;]:
                case &#39;x1l&#39;:
                    self.x1r_difference_from_ssf[sequence] = self._original_value
                case &#39;j1l&#39;:
                    self.j1r_difference_from_ssf[sequence] = self._original_value
                case &#39;zel&#39;:
                    self.zer_difference_from_ssf[sequence] = self._original_value
                case &#39;z1l&#39;:
                    self.z1r_difference_from_ssf[sequence] = self._original_value
            delattr(self, &#39;_original_value&#39;)

        if variable_details is None:
            delattr(self, &#39;_perturbed_variable_details&#39;)
        else:
            sequence = variable_details[&#39;sequence&#39;]
            match variable_details[&#39;var_type&#39;]:
                case &#39;x1l&#39;:
                    self._original_value = float(self.x1r_difference_from_ssf[sequence])
                    self.x1r_difference_from_ssf[sequence] = self._original_value + __class__.PERTURBATION
                case &#39;j1l&#39;:
                    self._original_value = float(self.j1r_difference_from_ssf[sequence])
                    self.j1r_difference_from_ssf[sequence] = self._original_value + __class__.PERTURBATION
                case &#39;zel&#39;:
                    self._original_value = float(self.zer_difference_from_ssf[sequence])
                    self.zer_difference_from_ssf[sequence] = self._original_value + __class__.PERTURBATION
                case &#39;z1l&#39;:
                    self._original_value = float(self.z1r_difference_from_ssf[sequence])
                    self.z1r_difference_from_ssf[sequence] = self._original_value + __class__.PERTURBATION
            self._perturbed_variable_details = variable_details

    @property
    def perturbed_variable_details(self) -&gt; pd.Series:
        &#34;&#34;&#34;
        The var_map details of the variable being perturbed to as part of computing
        derivatives needed to set intertemporal constants or none if just doing projections.
        &#34;&#34;&#34;
        if hasattr(self, &#39;_perturbed_variable_details&#39;):
            return self._perturbed_variable_details
        return None

    @property
    def first_year_projections_of_variables_adjusted_by_intertemporal_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The values of the variables that have been changed by the perturbation to 
        an intertemporal constant as part of computing partial derivatives for setting the
        intertemporal constants appropriately. These values are a column vector
        for the first projection year only.
        &#34;&#34;&#34;
        result = np.zeros(shape=(len(self.sym_data.variables_adjusted_by_intertemporal_constants), 1))
        i = 0
        for index, adjusted_variable_details in self.sym_data.variables_adjusted_by_intertemporal_constants.iterrows():
            sequence = adjusted_variable_details[&#39;sequence&#39;]
            match adjusted_variable_details[&#39;var_type&#39;]:
                case &#39;x1l&#39;:
                    result[i, 0] = self.yxr_first_year_projections[[sequence]]
                case &#39;j1l&#39;:
                    result[i, 0] = self.yjr_first_year_projections[[sequence]]
                case &#39;zel&#39;:
                    result[i, 0] = self.exz_first_year_projections[[sequence]]
                case &#39;z1l&#39;:
                    result[i, 0] = self.z1l_first_year_projections[[sequence]]
            i += 1
        return result

    def __set_first_projection_year_observed_values(self):
        &#34;&#34;&#34;
        ### Overview

        Sets the database values for the vectors in 
        the model in the first projection year.
        &#34;&#34;&#34;
        # RHS (identical to LHS) vector values to be compared to SSF calculated values
        self._first_projection_year_x1r: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;x1r&#39;, year=self.first_projection_year, use_neutral_real_interest_rate=True)  # t+1
        self._first_projection_year_j1r: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;j1r&#39;, year=self.first_projection_year, use_neutral_real_interest_rate=True)  # t+1
        self._first_projection_year_zer: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;zer&#39;, year=self.first_projection_year, use_neutral_real_interest_rate=True)  # t
        self._first_projection_year_z1r: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;z1r&#39;, year=self.first_projection_year, use_neutral_real_interest_rate=True)  # t

        # SSF RHS vector values
        self._first_projection_year_yxr: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;yxr&#39;, year=self.first_projection_year, use_neutral_real_interest_rate=True)  # t
        self._first_projection_year_yjr: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;yjr&#39;, year=self.first_projection_year, use_neutral_real_interest_rate=True)  # t
        self._first_projection_year_exz: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;exz&#39;, year=self.first_projection_year, use_neutral_real_interest_rate=True)  # t+1
        self._first_projection_year_exo: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;exo&#39;, year=self.first_projection_year, use_neutral_real_interest_rate=True)  # t

    def __store_observed_yxr_values_in_first_projection_year(self):
        &#34;&#34;&#34;
        Save the values of the state vector in the base projection year to use in
        initiating the projection process.
        &#34;&#34;&#34;
        yxr_initial_values = pd.DataFrame(self.first_projection_year_yxr.copy())
        yxr_initial_values.index = self.sym_data.vector_variable_names(vector_name=&#39;yxr&#39;)
        yxr_initial_values.columns = [str(self.first_projection_year)]
        self._yxr_initial_values: pd.DataFrame = yxr_initial_values

    def __store_observed_values_of_variables_adjusted_by_intertemporal_constants_in_first_projection_year(self):
        &#34;&#34;&#34;
        Save the database values of the variables
        that are adjusted by intertemporal constants so that we can use
        those as the values we adjust the variables to using the intertemporal
        constants.
        &#34;&#34;&#34;
        self._first_year_observed_values_of_variables_adjusted_by_intertemporal_constants: np.ndarray = \
            np.zeros(shape=(len(self.sym_data.variables_adjusted_by_intertemporal_constants), 1))
        i = 0
        for index, adjusted_variable_details in self.sym_data.variables_adjusted_by_intertemporal_constants.iterrows():
            sequence = adjusted_variable_details[&#39;sequence&#39;]
            match adjusted_variable_details[&#39;var_type&#39;]:
                case &#39;x1l&#39;:
                    self._first_year_observed_values_of_variables_adjusted_by_intertemporal_constants[i, 0] = self.first_projection_year_yxr[[sequence]]  # t = base year
                case &#39;j1l&#39;:
                    self._first_year_observed_values_of_variables_adjusted_by_intertemporal_constants[i, 0] = self.first_projection_year_yjr[[sequence]]  # t = base year
                case &#39;zel&#39;:
                    self._first_year_observed_values_of_variables_adjusted_by_intertemporal_constants[i, 0] = self.first_projection_year_exz[[sequence]]  # t+1 = year after base year
                case &#39;z1l&#39;:
                    self._first_year_observed_values_of_variables_adjusted_by_intertemporal_constants[i, 0] = self.first_projection_year_z1r[[sequence]]  # t = base year
            i += 1

    def __compute_first_projection_year_ssf_deviations_from_observed_values(self):
        &#34;&#34;&#34;
        Compute the SSF values for the base projection year and calculate the differences from
        observed variable values for all system-determined variables (not the exogenous ones).
        See setconSYMBL.ox for details of the Ox implementation.

        Compute values for LHS variables based on RHS variable values in the projection base year 
        based on the SSF model. Then determine the difference between these LHS variables 
        (model predictions) and the actual values.

        Results are saved as data minus projections for all vectors.
        &#34;&#34;&#34;

        # No constant adjustments for differences from SSF when doing rolling baseline projections
        if self.using_rolled_projections:
            self._x1r_difference_from_ssf = np.zeros((self.sym_data.vector_length(vector_name=&#39;x1r&#39;), 1))
            self._j1r_difference_from_ssf = np.zeros((self.sym_data.vector_length(vector_name=&#39;j1r&#39;), 1))
            self._zer_difference_from_ssf = np.zeros((self.sym_data.vector_length(vector_name=&#39;zer&#39;), 1))
            self._z1r_difference_from_ssf = np.zeros((self.sym_data.vector_length(vector_name=&#39;z1r&#39;), 1))
            return

        # We got here so we must be done the initial baseline projections that require a constant adjustment
        # for the SSF differences from observed data values in the base projection year.

        self.x1l_ssf_calculations_using_first_projection_year_data = self.state_space_form.delta(&#39;x1l&#39;, &#39;yxr&#39;) @ self.first_projection_year_yxr + \
            self.state_space_form.delta(&#39;x1l&#39;, &#39;yjr&#39;) @ self.first_projection_year_yjr + \
            self.state_space_form.delta(&#39;x1l&#39;, &#39;exz&#39;) @ self.first_projection_year_exz + \
            self.state_space_form.delta(&#39;x1l&#39;, &#39;exo&#39;) @ self.first_projection_year_exo

        self.j1l_ssf_calculations_using_first_projection_year_data = self.state_space_form.delta(&#39;j1l&#39;, &#39;yxr&#39;) @ self.first_projection_year_yxr + \
            self.state_space_form.delta(&#39;j1l&#39;, &#39;yjr&#39;) @ self.first_projection_year_yjr + \
            self.state_space_form.delta(&#39;j1l&#39;, &#39;exz&#39;) @ self.first_projection_year_exz + \
            self.state_space_form.delta(&#39;j1l&#39;, &#39;exo&#39;) @ self.first_projection_year_exo

        self.zel_ssf_calculations_using_first_projection_year_data = self.state_space_form.delta(&#39;zel&#39;, &#39;yxr&#39;) @ self.first_projection_year_yxr + \
            self.state_space_form.delta(&#39;zel&#39;, &#39;yjr&#39;) @ self.first_projection_year_yjr + \
            self.state_space_form.delta(&#39;zel&#39;, &#39;exz&#39;) @ self.first_projection_year_exz + \
            self.state_space_form.delta(&#39;zel&#39;, &#39;exo&#39;) @ self.first_projection_year_exo

        self.z1l_ssf_calculations_using_first_projection_year_data = self.state_space_form.delta(&#39;z1l&#39;, &#39;yxr&#39;) @ self.first_projection_year_yxr + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;yjr&#39;) @ self.first_projection_year_yjr + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;exz&#39;) @ self.first_projection_year_exz + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;exo&#39;) @ self.first_projection_year_exo

        self._x1r_difference_from_ssf = self.first_projection_year_x1r - self.x1l_ssf_calculations_using_first_projection_year_data  # t+1 = year after base year
        self._j1r_difference_from_ssf = self.first_projection_year_j1r - self.j1l_ssf_calculations_using_first_projection_year_data  # t+1 = year after base year
        self._zer_difference_from_ssf = self.first_projection_year_zer - self.zel_ssf_calculations_using_first_projection_year_data  # t = base year
        self._z1r_difference_from_ssf = self.first_projection_year_z1r - self.z1l_ssf_calculations_using_first_projection_year_data  # t = base year

    @property
    def first_projection_year_x1r(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        If the first projection year = t:
        Returns the value of x1r from the database as the value of x1 in period t+1
        &#34;&#34;&#34;
        return self._first_projection_year_x1r

    @property
    def first_projection_year_j1r(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        If the first projection year = t:
        Returns the value of j1r from the database as the value of j1 in period t+1
        &#34;&#34;&#34;
        return self._first_projection_year_j1r

    @property
    def first_projection_year_zer(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        If the first projection year = t:
        Returns the value of zer from the database as the value of x1 in period t
        &#34;&#34;&#34;
        return self._first_projection_year_zer

    @property
    def first_projection_year_z1r(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        If the first projection year = t:
        Returns the value of z1r from the database as the value of z1 in period t
        &#34;&#34;&#34;
        return self._first_projection_year_z1r

    @property
    def first_projection_year_yxr(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        If the first projection year = t:
        Returns the value of yxr from the database as the value of x1 in period t
        &#34;&#34;&#34;
        return self._first_projection_year_yxr

    @property
    def first_projection_year_yjr(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        If the first projection year = t:
        Returns the value of yjr from the database as the value of j1 in period t
        &#34;&#34;&#34;
        return self._first_projection_year_yjr

    @property
    def first_projection_year_exz(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        If the first projection year = t:
        Returns the value of exz from the database as the value of ze in period t+1
        &#34;&#34;&#34;
        return self._first_projection_year_exz

    @property
    def first_projection_year_exo(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        If the first projection year = t:
        Returns the value of exo from the database as the value of exogenous variables (exo)
        in period t
        &#34;&#34;&#34;
        return self._first_projection_year_exo

    @property
    def x1r_difference_from_ssf(self):
        &#34;&#34;&#34;
        In Ox: decl cz2 = x1r - x1l
        &#34;&#34;&#34;
        return self._x1r_difference_from_ssf

    @property
    def j1r_difference_from_ssf(self):
        &#34;&#34;&#34;
        In Ox: decl cz4 = j1r - j1l
        &#34;&#34;&#34;
        return self._j1r_difference_from_ssf

    @property
    def zer_difference_from_ssf(self):
        &#34;&#34;&#34;
        In Ox: decl cz5 = zer - zel
        &#34;&#34;&#34;
        return self._zer_difference_from_ssf

    @property
    def z1r_difference_from_ssf(self):
        &#34;&#34;&#34;
        In Ox: decl cz6 = z1r - z1l
        &#34;&#34;&#34;
        return self._z1r_difference_from_ssf

    @property
    def reference_h3t_used_to_compute_intertemporal_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Equivalent to h3t in the Ox implementation
        Functions of current and future exogenous variables affecting J1.
        This is the reference version of h3t, computed to calculation the projections
        for the base year that will be used as a reference projection when determining 
        the numeric derivatives for calculation of the intertemporal constants.

        Its only role is to preserve the appropriate information for benchmarking against Ox.
        &#34;&#34;&#34;
        return self._reference_h3t_used_to_compute_intertemporal_constants

    @property
    def reference_c4t_used_to_compute_intertemporal_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Equivalent to c4t in the Ox implementation
        Functions of current and future exogenous variables affecting ZE.
        This is the reference version of h3t, computed to calculation the projections
        for the base year that will be used as a reference projection when determining 
        the numeric derivatives for calculation of the intertemporal constants.

        Its only role is to preserve the appropriate information for benchmarking against Ox.
        &#34;&#34;&#34;
        return self._reference_c4t_used_to_compute_intertemporal_constants

    @property
    def x1_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to X1 to ensure projections equal observed values.
        Add any intertemporal constant values to the X1R difference to SSF equation 
        results with zero constants to get the combined set of constants.
        &#34;&#34;&#34;

        if hasattr(self, &#34;_x1_constants&#34;):
            return self._x1_constants

        result: np.ndarray = self.x1r_difference_from_ssf.copy()
        if not hasattr(self, &#34;intertemporal_constants&#34;):
            return result

        i = 0
        for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
            if variable_details[&#39;var_type&#39;] == &#39;x1l&#39;:
                result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
            i = i + 1

        self._x1_constants: np.ndarray = result
        return self._x1_constants

    @property
    def j1_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to J1 to ensure projections equal observed values.
        Add any intertemporal constant values to the X1R difference to SSF equation results with zero constants
        to get the combined set of constants.
        &#34;&#34;&#34;

        if hasattr(self, &#34;_j1_constants&#34;):
            return self._j1_constants

        result: np.ndarray = self.j1r_difference_from_ssf.copy()
        if not hasattr(self, &#34;intertemporal_constants&#34;):
            return result
        i = 0
        for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
            if variable_details[&#39;var_type&#39;] == &#39;j1l&#39;:
                result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
            i = i + 1

        self._j1_constants: np.ndarray = result
        return self._j1_constants

    @property
    def ze_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to ZE to ensure projections equal observed values.
        Add any intertemporal constant values to the X1R difference to SSF equation results with zero constants
        to get the combined set of constants.
        &#34;&#34;&#34;

        if hasattr(self, &#34;_ze_constants&#34;):
            return self._ze_constants

        result: np.ndarray = self.zer_difference_from_ssf.copy()
        if not hasattr(self, &#34;intertemporal_constants&#34;):
            return result

        i = 0
        for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
            if variable_details[&#39;var_type&#39;] == &#39;zel&#39;:
                logging.debug(
                    f&#34;At index {i} intertemporal constant is {self.intertemporal_constants.loc[variable_details[&#39;name&#39;],&#39;constant_value&#39;]} : shape is {self.intertemporal_constants.shape}&#34;)
                result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
            i = i + 1

        self._ze_constants: np.ndarray = result
        return self._ze_constants

    @property
    def z1_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to Z1 to ensure projections equal observed values.
        Add any intertemporal constant values to the X1R difference to SSF equation results with zero constants
        to get the combined set of constants.
        &#34;&#34;&#34;

        if hasattr(self, &#34;_z1_constants&#34;):
            return self._z1_constants

        result: np.ndarray = self.z1r_difference_from_ssf.copy()
        if not hasattr(self, &#34;intertemporal_constants&#34;):
            return result
        i = 0
        for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
            if variable_details[&#39;var_type&#39;] == &#39;z1l&#39;:
                result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
            i = i + 1

        self._z1_constants: np.ndarray = result
        return self._z1_constants

    def __create_exogenous_variable_projections(self):
        &#34;&#34;&#34;
        Populates the exogenous variable values through the projection years. 
        These values are determined outside the system.

        The rolling baseline projections just copy the exogenous values from the previous projections
        and use those as the starting point for the next round of projection generation.

        Otherwise, when initially setting up baseline projections, incorporate values from:
        - the database in the base projection year
        - effective labour productivity projections
        - energy efficiency improvement projections
        &#34;&#34;&#34;

        # If we are doing the baseline projections after rolling forward to a new base projection year,
        # just copy the database values for the exogenous variables over the projection years
        # and then we are done.
        if self.using_rolled_projections:
            matching_indices: pd.Index = self.sym_data.combined_variable_summary.loc[self.sym_data.combined_variable_summary.vector == &#39;exo&#39;, :].index
            self._exo_projections: pd.DataFrame = self.database.data.loc[matching_indices, self.projection_years_column_labels]
            return

        # We got here so we must be setting up the exogenous variable projections for the first time ...

        # Replicate projection base year values across all projection periods for all exogenous variables.
        projections: pd.DataFrame = pd.DataFrame(np.tile(self.first_projection_year_exo, (1, self.configuration.projection_years_count)))
        projections.columns = self.projection_years_column_labels
        projections.reset_index()

        # Add effective labour productivity and energy usage efficiency.
        effective_labour_productivity: EffectiveLabourProductivity = self.model.effective_labour_productivity
        rogy: pd.DataFrame = effective_labour_productivity.rogy
        energy_usage_efficiency: EnergyUsageEfficiency = self.model.energy_usage_efficiency
        for region in self.sym_data.regions_members:

            regional_effective_labour_productivity: pd.DataFrame = effective_labour_productivity.effective_productivity_deviations(region=region)
            regional_energy_usage_efficiency: pd.DataFrame = energy_usage_efficiency.sector_cumulative_energy_usage_efficiency_gains(region=region)
            consumption_energy_usage_efficiency: pd.DataFrame = energy_usage_efficiency.consumption_cumulative_energy_usage_efficiency_gains

            variable_prefix_ROGY: str = f&#34;ROGY&#34;
            rogy_name: str = f&#34;{variable_prefix_ROGY}({region})&#34;
            if self.sym_data.has_variables(variable_name_prefix=rogy_name):
                rogy_index: int = self.sym_data.variable_index(vector_name=&#39;exo&#39;, variable_name=rogy_name)
                rogy_units = self.sym_data.variable_units(vector_name=&#39;exo&#39;, variable_name_prefix=variable_prefix_ROGY)
                rogy_data: pd.DataFrame = rogy.loc[[region], self.projection_years_column_labels]
                if &#39;gdp&#39; in rogy_units:
                    raise Exception(f&#34;{rogy_name} has gdp units so shocks to that variable are not supported.&#34;)

                projections.loc[[rogy_index], :] = projections.loc[[rogy_index], :] + (rogy_data.to_numpy().flatten() / 100)
            # else:
            #     logging.warning(f&#34;{rogy_name} is not in the SYM model.&#34;)

            shefc_name_prefix: str = f&#34;SHEFC&#34;
            shefc_name: str = f&#34;{shefc_name_prefix}({region})&#34;
            if self.sym_data.has_variables(variable_name_prefix=shefc_name_prefix):
                shefc_index: int = self.sym_data.variable_index(vector_name=&#39;exo&#39;, variable_name=shefc_name)
                shefc_units = self.sym_data.variable_units(vector_name=&#39;exo&#39;, variable_name_prefix=shefc_name_prefix)
                shefc_data: pd.DataFrame = consumption_energy_usage_efficiency.loc[[region], self.projection_years_column_labels]
                if &#39;gdp&#39; in shefc_units:
                    raise Exception(f&#34;{shefc_name} has gdp units so shocks to that variable are not supported.&#34;)
                projections.loc[[shefc_index], :] = projections.loc[[shefc_index], :] + (shefc_data.to_numpy().flatten() / 100)
            # else:
            #     logging.warning(f&#34;{shefc_name} is not in the SYM model.&#34;)

            variable_prefix_SHL: str = &#39;SHL&#39;
            variable_prefix_SHEF: str = &#39;SHEF&#39;
            for sector in self.sym_data.sectors_members:

                shl_name: str = f&#34;{variable_prefix_SHL}({region},{sector})&#34;
                if self.sym_data.has_variables(variable_name_prefix=shl_name):
                    shl_index: int = self.sym_data.variable_index(vector_name=&#39;exo&#39;, variable_name=shl_name)
                    shl_units = self.sym_data.variable_units(vector_name=&#39;exo&#39;, variable_name_prefix=variable_prefix_SHL)
                    shl_data: pd.DataFrame = regional_effective_labour_productivity.loc[[sector], self.projection_years_column_labels]
                    if &#39;gdp&#39; in shl_units:
                        raise Exception(f&#34;{shl_name} has gdp units so shocks to that variable are not supported.&#34;)
                    projections.loc[[shl_index], :] = projections.loc[[
                        shl_index], :] + (shl_data.to_numpy().flatten() / 100)
                # else:
                #     logging.warning(f&#34;{shl_name} is not in the SYM model.&#34;)

                shef_name: str = f&#34;{variable_prefix_SHEF}({sector},{region})&#34;
                if self.sym_data.has_variables(variable_name_prefix=shef_name):
                    shef_index: int = self.sym_data.variable_index(vector_name=&#39;exo&#39;, variable_name=shef_name)
                    shef_units = self.sym_data.variable_units(vector_name=&#39;exo&#39;, variable_name_prefix=variable_prefix_SHEF)
                    shef_data: pd.DataFrame = regional_energy_usage_efficiency.loc[[sector], self.projection_years_column_labels]
                    if &#39;gdp&#39; in shef_units:
                        raise Exception(f&#34;{shef_name} has gdp units so shocks to that variable are not supported.&#34;)
                    projections.loc[[shef_index], :] = projections.loc[[shef_index], :] + (shef_data.to_numpy().flatten() / 100)
                # else:
                #     logging.warning(f&#34;{shef_shock_name} is not in the SYM model.&#34;)

        # Index with variable names.
        projections.index = self.sym_data.vector_variable_names(vector_name=&#39;exo&#39;)

        # Store the exogenous projections that will be augmented for other projections.
        self._exo_projections: pd.DataFrame = projections

    def __evaluate_first_projection_year_vector_projections(self):
        &#34;&#34;&#34;
        Computes the values of the model equation vectors in the first projection year, 
        using the functions of future exogenous variables, the stable manifold, etc
        &#34;&#34;&#34;

        self._exo_first_year_projections = self.exo_projections[:, [0]]

        self._yxr_first_year_projections = self.yxr_initial_values.to_numpy().copy()

        # er = h1t*x[][1] + h2t*exog[][1] + h3t[][1];
        self._yjr_first_year_projections = \
            self.stable_manifold.H1 @ self.yxr_first_year_projections + \
            self.stable_manifold.H2 @ self.exo_first_year_projections + \
            self._h3t[:, [0]]

        # tzl = mu1t*x[][1] + mu4t*exog[][1] + c4t[][1];
        self._exz_first_year_projections = \
            self.stable_manifold.mu1 @ self.yxr_first_year_projections + \
            self.stable_manifold.mu2 @ self.exo_first_year_projections + \
            self._c4t[:, [0]]

        # z1l projections = d5n*x[][1]+d7n*exog[][1]+d6n*er+d4n*tzl+cz6[][1]
        self._z1l_first_year_projections = \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;yxr&#39;) @ self.yxr_first_year_projections + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;exo&#39;) @ self.exo_first_year_projections + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;yjr&#39;) @ self.yjr_first_year_projections + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;exz&#39;) @ self.exz_first_year_projections + \
            self.z1r_difference_from_ssf

    @property
    def yxr_first_year_projections(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Projections of X1_t (yxr) in the first projection year
        &#34;&#34;&#34;
        return self._yxr_first_year_projections

    @property
    def yjr_first_year_projections(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Projections of J1_t (yjr) in the first projection year
        &#34;&#34;&#34;
        return self._yjr_first_year_projections

    @property
    def exz_first_year_projections(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Projections of ZE_t (exz) in the first projection year
        &#34;&#34;&#34;
        return self._exz_first_year_projections

    @property
    def z1l_first_year_projections(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Projections of Z1_t (z1l=z1r) in the first projection year
        &#34;&#34;&#34;
        return self._z1l_first_year_projections

    @property
    def exo_first_year_projections(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Projections of EXO_t in the first projection year
        &#34;&#34;&#34;
        return self._exo_first_year_projections

    @property
    def first_year_original_projections_of_variables_adjusted_by_intertemporal_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The first year projected values for the variables that are being
        adjusted by the intertemporal constants.

        The values are those for the projection that is not adjusted by intertemporal constants.
        &#34;&#34;&#34;
        return self._first_year_original_projections_of_variables_adjusted_by_intertemporal_constants

    @property
    def first_year_original_projections_of_yxr(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The first year projected values for the state variables.
        Required for benchmarking against Ox.
        &#34;&#34;&#34;
        return self._first_year_original_projections_of_yxr

    @property
    def first_year_original_projections_of_yjr(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The first year projected values for the costate variables.
        Required for benchmarking against Ox.
        &#34;&#34;&#34;
        return self._first_year_original_projections_of_yjr

    @property
    def first_year_original_projections_of_exz(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The first year projected values for the expected endogenous variables exz.
        Required for benchmarking against Ox.
        &#34;&#34;&#34;
        return self._first_year_original_projections_of_exz

    @property
    def first_year_original_projections_of_z1l(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The first year projected values for the endogenous variables.
        Required for benchmarking against Ox.
        &#34;&#34;&#34;
        return self._first_year_original_projections_of_z1l

    @property
    def first_year_observed_values_of_variables_adjusted_by_intertemporal_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Returns the observed values, in the first projection year, of the 
        variables that are adjusted by intertemporal constants.
        &#34;&#34;&#34;
        return self._first_year_observed_values_of_variables_adjusted_by_intertemporal_constants

    @property
    def intertemporal_constants(self) -&gt; pd.DataFrame:
        return self._intertemporal_constants

    @property
    def partial_derivatives_wrt_intertemporal_constants(self) -&gt; np.ndarray:
        return self._partial_derivatives

    def __calculate_intertemporal_constants(self):
        &#34;&#34;&#34;
        Computes the intertemporal constant adjustments to jump and other variables to align starting data
        values with model projections in the first year.

        Step 1.
        Compute functions of future exogenous variables through all years of the projection.

        Step 2.
        For the variables that are to be adjusted by the intertemporal
        constants, compute their projected values in the base projection year
        and store these values for comparison to perturbed base year projections so we can calculate
        the derivatives matrix needed to set the intertemporal constants.
        Also store the values of each of the 4 vectors in the model in the base year for benchmarking.

        Step 3.
        Initialise the partial derivatives matrix. This is the matrix of derivatives of each of the
        variables that is adjusted by intertemporal constants, with respect to each of the intertemporal
        constants.
        Iterate over the intertemporal constants, perturbing each and recalculating the base year projections
        of the variables that are adjusted by intertemporal constants so that we can 
        estimate the relevant numeric derivatives.
        &#34;&#34;&#34;

        # Step 1.
        self._compute_functions_of_future_exogenous_variables()
        self._reference_c4t_used_to_compute_intertemporal_constants = self.c4t.copy()
        self._reference_h3t_used_to_compute_intertemporal_constants = self.h3t.copy()

        # Step 2.
        self.__evaluate_first_projection_year_vector_projections()
        self._first_year_original_projections_of_yxr = self.yxr_first_year_projections.copy()
        self._first_year_original_projections_of_yjr = self.yjr_first_year_projections.copy()
        self._first_year_original_projections_of_exz = self.exz_first_year_projections.copy()
        self._first_year_original_projections_of_z1l = self.z1l_first_year_projections.copy()
        self._first_year_original_projections_of_variables_adjusted_by_intertemporal_constants = \
            self.first_year_projections_of_variables_adjusted_by_intertemporal_constants.copy()

        # Step 3.
        self._partial_derivatives = np.zeros(shape=(len(self.sym_data.intertemporal_constant_variables), len(
            self.sym_data.variables_adjusted_by_intertemporal_constants)))
        i = 0
        for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
            self.__update_perturbed_variable(variable_details=variable_details)
            self._compute_functions_of_future_exogenous_variables()
            self.__evaluate_first_projection_year_vector_projections()
            self._partial_derivatives[:, [i]] = (
                self.first_year_projections_of_variables_adjusted_by_intertemporal_constants -
                self._first_year_original_projections_of_variables_adjusted_by_intertemporal_constants) \
                / __class__.PERTURBATION
            i += 1

        # Get the unperturbed values of the variables in first projection year

        # Generate the baseline projection to use in computing partial derivatives
        # and to generate matrix values that are used later in projection processes.
        self.__update_perturbed_variable(variable_details=None)

        # Use newtons method adjustment to compute intertemporal constant values
        self._intertemporal_constants = self.sym_data.intertemporal_constant_variables
        values: np.ndarray = np.linalg.inv(self._partial_derivatives) @ \
            (self.first_year_observed_values_of_variables_adjusted_by_intertemporal_constants -
             self.first_year_original_projections_of_variables_adjusted_by_intertemporal_constants)
        values = values.reshape((len(self.intertemporal_constants.index), 1))
        self._intertemporal_constants[&#39;constant_value&#39;] = values
        logging.info(&#34;The intertemporal constants have been calibrated.&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gcubed.projections.baseline_projections.BaselineProjections"><code class="flex name class">
<span>class <span class="ident">BaselineProjections</span></span>
<span>(</span><span>stable_manifold: <a title="gcubed.linearisation.stable_manifold.StableManifold" href="../linearisation/stable_manifold.html#gcubed.linearisation.stable_manifold.StableManifold">StableManifold</a>)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="overview">Overview</h3>
<p>Compute the baseline model projections over the projection horizon
from the first projection year (a year with available data to be
matched by the projections) through to the last projection year.</p>
<h3 id="arguments">Arguments</h3>
<p>stable_manifold: The stable manifold that provides access to all
of the model information required to produce projections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaselineProjections(Projections):
    &#34;&#34;&#34;
    ### Overview

    Compute the baseline model projections over the projection horizon 
    from the first projection year (a year with available data to be 
    matched by the projections) through to the last projection year.
    &#34;&#34;&#34;

    # The perturbation to use when computing partial derivatives for intertemporal constant determination.
    PERTURBATION = 0.0001

    def __init__(self, stable_manifold: StableManifold) -&gt; None:
        &#34;&#34;&#34;
       ### Arguments

        stable_manifold: The stable manifold that provides access to all 
        of the model information required to produce projections.
        &#34;&#34;&#34;
        logging.info(&#34;Setting up the baseline projections.&#34;)

        super().__init__(stable_manifold=stable_manifold)
        self._is_baseline_projections = True
        
        self._database = GDPScaledDatabase(database=self.model.database, base_year=self.configuration.base_year)

        self.__set_first_projection_year_observed_values()

        self.__store_observed_yxr_values_in_first_projection_year()

        # Set up the exogenous variable projections
        self.__create_exogenous_variable_projections()

        self.__store_observed_values_of_variables_adjusted_by_intertemporal_constants_in_first_projection_year()
        self.__compute_first_projection_year_ssf_deviations_from_observed_values()

        if not self.using_rolled_projections:
            self.__calculate_intertemporal_constants()

        # Generate the baseline projections
        self._generate_projections()

        # Generate the database projections
        self._generate_database_projections()

        # Generate publishable version of the projections
        self._generate_publishable_projections()

        self.__validate()


    def __validate(self):
        &#34;&#34;&#34;
        TODO:  Validate the projections: 
        1. check that they are available for the expected projection years.
        2. Check that the base year projections are equal to the base year data values.
        &#34;&#34;&#34;
        logging.info(&#34;The baseline projections have been generated.&#34;)

    @property
    def database(self) -&gt; GDPScaledDatabase:
        &#34;&#34;&#34;
        The database used as the starting point for the projections.
        &#34;&#34;&#34;
        return self._database

    @property
    def using_rolled_projections(self) -&gt; bool:
        &#34;&#34;&#34;
        True if these projections are building on
        previous projections rather than just observed data.

        This affects how the baseline projections are set up in terms
        of the constants used.
        &#34;&#34;&#34;
        return self.database.has_data_for_all_projection_years

    def __update_perturbed_variable(self, variable_details: pd.Series):
        &#34;&#34;&#34;
        ### Overview

        Changes the perturbed variable, preparing for the
        next evaluation of the values needed to compute
        partial derivatives relevant to the determination 
        of the intertemporal constants.
        &#34;&#34;&#34;

        if hasattr(self, &#39;_perturbed_variable_details&#39;):
            sequence = self._perturbed_variable_details[&#39;sequence&#39;]
            match self._perturbed_variable_details[&#39;var_type&#39;]:
                case &#39;x1l&#39;:
                    self.x1r_difference_from_ssf[sequence] = self._original_value
                case &#39;j1l&#39;:
                    self.j1r_difference_from_ssf[sequence] = self._original_value
                case &#39;zel&#39;:
                    self.zer_difference_from_ssf[sequence] = self._original_value
                case &#39;z1l&#39;:
                    self.z1r_difference_from_ssf[sequence] = self._original_value
            delattr(self, &#39;_original_value&#39;)

        if variable_details is None:
            delattr(self, &#39;_perturbed_variable_details&#39;)
        else:
            sequence = variable_details[&#39;sequence&#39;]
            match variable_details[&#39;var_type&#39;]:
                case &#39;x1l&#39;:
                    self._original_value = float(self.x1r_difference_from_ssf[sequence])
                    self.x1r_difference_from_ssf[sequence] = self._original_value + __class__.PERTURBATION
                case &#39;j1l&#39;:
                    self._original_value = float(self.j1r_difference_from_ssf[sequence])
                    self.j1r_difference_from_ssf[sequence] = self._original_value + __class__.PERTURBATION
                case &#39;zel&#39;:
                    self._original_value = float(self.zer_difference_from_ssf[sequence])
                    self.zer_difference_from_ssf[sequence] = self._original_value + __class__.PERTURBATION
                case &#39;z1l&#39;:
                    self._original_value = float(self.z1r_difference_from_ssf[sequence])
                    self.z1r_difference_from_ssf[sequence] = self._original_value + __class__.PERTURBATION
            self._perturbed_variable_details = variable_details

    @property
    def perturbed_variable_details(self) -&gt; pd.Series:
        &#34;&#34;&#34;
        The var_map details of the variable being perturbed to as part of computing
        derivatives needed to set intertemporal constants or none if just doing projections.
        &#34;&#34;&#34;
        if hasattr(self, &#39;_perturbed_variable_details&#39;):
            return self._perturbed_variable_details
        return None

    @property
    def first_year_projections_of_variables_adjusted_by_intertemporal_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The values of the variables that have been changed by the perturbation to 
        an intertemporal constant as part of computing partial derivatives for setting the
        intertemporal constants appropriately. These values are a column vector
        for the first projection year only.
        &#34;&#34;&#34;
        result = np.zeros(shape=(len(self.sym_data.variables_adjusted_by_intertemporal_constants), 1))
        i = 0
        for index, adjusted_variable_details in self.sym_data.variables_adjusted_by_intertemporal_constants.iterrows():
            sequence = adjusted_variable_details[&#39;sequence&#39;]
            match adjusted_variable_details[&#39;var_type&#39;]:
                case &#39;x1l&#39;:
                    result[i, 0] = self.yxr_first_year_projections[[sequence]]
                case &#39;j1l&#39;:
                    result[i, 0] = self.yjr_first_year_projections[[sequence]]
                case &#39;zel&#39;:
                    result[i, 0] = self.exz_first_year_projections[[sequence]]
                case &#39;z1l&#39;:
                    result[i, 0] = self.z1l_first_year_projections[[sequence]]
            i += 1
        return result

    def __set_first_projection_year_observed_values(self):
        &#34;&#34;&#34;
        ### Overview

        Sets the database values for the vectors in 
        the model in the first projection year.
        &#34;&#34;&#34;
        # RHS (identical to LHS) vector values to be compared to SSF calculated values
        self._first_projection_year_x1r: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;x1r&#39;, year=self.first_projection_year, use_neutral_real_interest_rate=True)  # t+1
        self._first_projection_year_j1r: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;j1r&#39;, year=self.first_projection_year, use_neutral_real_interest_rate=True)  # t+1
        self._first_projection_year_zer: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;zer&#39;, year=self.first_projection_year, use_neutral_real_interest_rate=True)  # t
        self._first_projection_year_z1r: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;z1r&#39;, year=self.first_projection_year, use_neutral_real_interest_rate=True)  # t

        # SSF RHS vector values
        self._first_projection_year_yxr: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;yxr&#39;, year=self.first_projection_year, use_neutral_real_interest_rate=True)  # t
        self._first_projection_year_yjr: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;yjr&#39;, year=self.first_projection_year, use_neutral_real_interest_rate=True)  # t
        self._first_projection_year_exz: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;exz&#39;, year=self.first_projection_year, use_neutral_real_interest_rate=True)  # t+1
        self._first_projection_year_exo: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;exo&#39;, year=self.first_projection_year, use_neutral_real_interest_rate=True)  # t

    def __store_observed_yxr_values_in_first_projection_year(self):
        &#34;&#34;&#34;
        Save the values of the state vector in the base projection year to use in
        initiating the projection process.
        &#34;&#34;&#34;
        yxr_initial_values = pd.DataFrame(self.first_projection_year_yxr.copy())
        yxr_initial_values.index = self.sym_data.vector_variable_names(vector_name=&#39;yxr&#39;)
        yxr_initial_values.columns = [str(self.first_projection_year)]
        self._yxr_initial_values: pd.DataFrame = yxr_initial_values

    def __store_observed_values_of_variables_adjusted_by_intertemporal_constants_in_first_projection_year(self):
        &#34;&#34;&#34;
        Save the database values of the variables
        that are adjusted by intertemporal constants so that we can use
        those as the values we adjust the variables to using the intertemporal
        constants.
        &#34;&#34;&#34;
        self._first_year_observed_values_of_variables_adjusted_by_intertemporal_constants: np.ndarray = \
            np.zeros(shape=(len(self.sym_data.variables_adjusted_by_intertemporal_constants), 1))
        i = 0
        for index, adjusted_variable_details in self.sym_data.variables_adjusted_by_intertemporal_constants.iterrows():
            sequence = adjusted_variable_details[&#39;sequence&#39;]
            match adjusted_variable_details[&#39;var_type&#39;]:
                case &#39;x1l&#39;:
                    self._first_year_observed_values_of_variables_adjusted_by_intertemporal_constants[i, 0] = self.first_projection_year_yxr[[sequence]]  # t = base year
                case &#39;j1l&#39;:
                    self._first_year_observed_values_of_variables_adjusted_by_intertemporal_constants[i, 0] = self.first_projection_year_yjr[[sequence]]  # t = base year
                case &#39;zel&#39;:
                    self._first_year_observed_values_of_variables_adjusted_by_intertemporal_constants[i, 0] = self.first_projection_year_exz[[sequence]]  # t+1 = year after base year
                case &#39;z1l&#39;:
                    self._first_year_observed_values_of_variables_adjusted_by_intertemporal_constants[i, 0] = self.first_projection_year_z1r[[sequence]]  # t = base year
            i += 1

    def __compute_first_projection_year_ssf_deviations_from_observed_values(self):
        &#34;&#34;&#34;
        Compute the SSF values for the base projection year and calculate the differences from
        observed variable values for all system-determined variables (not the exogenous ones).
        See setconSYMBL.ox for details of the Ox implementation.

        Compute values for LHS variables based on RHS variable values in the projection base year 
        based on the SSF model. Then determine the difference between these LHS variables 
        (model predictions) and the actual values.

        Results are saved as data minus projections for all vectors.
        &#34;&#34;&#34;

        # No constant adjustments for differences from SSF when doing rolling baseline projections
        if self.using_rolled_projections:
            self._x1r_difference_from_ssf = np.zeros((self.sym_data.vector_length(vector_name=&#39;x1r&#39;), 1))
            self._j1r_difference_from_ssf = np.zeros((self.sym_data.vector_length(vector_name=&#39;j1r&#39;), 1))
            self._zer_difference_from_ssf = np.zeros((self.sym_data.vector_length(vector_name=&#39;zer&#39;), 1))
            self._z1r_difference_from_ssf = np.zeros((self.sym_data.vector_length(vector_name=&#39;z1r&#39;), 1))
            return

        # We got here so we must be done the initial baseline projections that require a constant adjustment
        # for the SSF differences from observed data values in the base projection year.

        self.x1l_ssf_calculations_using_first_projection_year_data = self.state_space_form.delta(&#39;x1l&#39;, &#39;yxr&#39;) @ self.first_projection_year_yxr + \
            self.state_space_form.delta(&#39;x1l&#39;, &#39;yjr&#39;) @ self.first_projection_year_yjr + \
            self.state_space_form.delta(&#39;x1l&#39;, &#39;exz&#39;) @ self.first_projection_year_exz + \
            self.state_space_form.delta(&#39;x1l&#39;, &#39;exo&#39;) @ self.first_projection_year_exo

        self.j1l_ssf_calculations_using_first_projection_year_data = self.state_space_form.delta(&#39;j1l&#39;, &#39;yxr&#39;) @ self.first_projection_year_yxr + \
            self.state_space_form.delta(&#39;j1l&#39;, &#39;yjr&#39;) @ self.first_projection_year_yjr + \
            self.state_space_form.delta(&#39;j1l&#39;, &#39;exz&#39;) @ self.first_projection_year_exz + \
            self.state_space_form.delta(&#39;j1l&#39;, &#39;exo&#39;) @ self.first_projection_year_exo

        self.zel_ssf_calculations_using_first_projection_year_data = self.state_space_form.delta(&#39;zel&#39;, &#39;yxr&#39;) @ self.first_projection_year_yxr + \
            self.state_space_form.delta(&#39;zel&#39;, &#39;yjr&#39;) @ self.first_projection_year_yjr + \
            self.state_space_form.delta(&#39;zel&#39;, &#39;exz&#39;) @ self.first_projection_year_exz + \
            self.state_space_form.delta(&#39;zel&#39;, &#39;exo&#39;) @ self.first_projection_year_exo

        self.z1l_ssf_calculations_using_first_projection_year_data = self.state_space_form.delta(&#39;z1l&#39;, &#39;yxr&#39;) @ self.first_projection_year_yxr + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;yjr&#39;) @ self.first_projection_year_yjr + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;exz&#39;) @ self.first_projection_year_exz + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;exo&#39;) @ self.first_projection_year_exo

        self._x1r_difference_from_ssf = self.first_projection_year_x1r - self.x1l_ssf_calculations_using_first_projection_year_data  # t+1 = year after base year
        self._j1r_difference_from_ssf = self.first_projection_year_j1r - self.j1l_ssf_calculations_using_first_projection_year_data  # t+1 = year after base year
        self._zer_difference_from_ssf = self.first_projection_year_zer - self.zel_ssf_calculations_using_first_projection_year_data  # t = base year
        self._z1r_difference_from_ssf = self.first_projection_year_z1r - self.z1l_ssf_calculations_using_first_projection_year_data  # t = base year

    @property
    def first_projection_year_x1r(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        If the first projection year = t:
        Returns the value of x1r from the database as the value of x1 in period t+1
        &#34;&#34;&#34;
        return self._first_projection_year_x1r

    @property
    def first_projection_year_j1r(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        If the first projection year = t:
        Returns the value of j1r from the database as the value of j1 in period t+1
        &#34;&#34;&#34;
        return self._first_projection_year_j1r

    @property
    def first_projection_year_zer(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        If the first projection year = t:
        Returns the value of zer from the database as the value of x1 in period t
        &#34;&#34;&#34;
        return self._first_projection_year_zer

    @property
    def first_projection_year_z1r(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        If the first projection year = t:
        Returns the value of z1r from the database as the value of z1 in period t
        &#34;&#34;&#34;
        return self._first_projection_year_z1r

    @property
    def first_projection_year_yxr(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        If the first projection year = t:
        Returns the value of yxr from the database as the value of x1 in period t
        &#34;&#34;&#34;
        return self._first_projection_year_yxr

    @property
    def first_projection_year_yjr(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        If the first projection year = t:
        Returns the value of yjr from the database as the value of j1 in period t
        &#34;&#34;&#34;
        return self._first_projection_year_yjr

    @property
    def first_projection_year_exz(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        If the first projection year = t:
        Returns the value of exz from the database as the value of ze in period t+1
        &#34;&#34;&#34;
        return self._first_projection_year_exz

    @property
    def first_projection_year_exo(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        If the first projection year = t:
        Returns the value of exo from the database as the value of exogenous variables (exo)
        in period t
        &#34;&#34;&#34;
        return self._first_projection_year_exo

    @property
    def x1r_difference_from_ssf(self):
        &#34;&#34;&#34;
        In Ox: decl cz2 = x1r - x1l
        &#34;&#34;&#34;
        return self._x1r_difference_from_ssf

    @property
    def j1r_difference_from_ssf(self):
        &#34;&#34;&#34;
        In Ox: decl cz4 = j1r - j1l
        &#34;&#34;&#34;
        return self._j1r_difference_from_ssf

    @property
    def zer_difference_from_ssf(self):
        &#34;&#34;&#34;
        In Ox: decl cz5 = zer - zel
        &#34;&#34;&#34;
        return self._zer_difference_from_ssf

    @property
    def z1r_difference_from_ssf(self):
        &#34;&#34;&#34;
        In Ox: decl cz6 = z1r - z1l
        &#34;&#34;&#34;
        return self._z1r_difference_from_ssf

    @property
    def reference_h3t_used_to_compute_intertemporal_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Equivalent to h3t in the Ox implementation
        Functions of current and future exogenous variables affecting J1.
        This is the reference version of h3t, computed to calculation the projections
        for the base year that will be used as a reference projection when determining 
        the numeric derivatives for calculation of the intertemporal constants.

        Its only role is to preserve the appropriate information for benchmarking against Ox.
        &#34;&#34;&#34;
        return self._reference_h3t_used_to_compute_intertemporal_constants

    @property
    def reference_c4t_used_to_compute_intertemporal_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Equivalent to c4t in the Ox implementation
        Functions of current and future exogenous variables affecting ZE.
        This is the reference version of h3t, computed to calculation the projections
        for the base year that will be used as a reference projection when determining 
        the numeric derivatives for calculation of the intertemporal constants.

        Its only role is to preserve the appropriate information for benchmarking against Ox.
        &#34;&#34;&#34;
        return self._reference_c4t_used_to_compute_intertemporal_constants

    @property
    def x1_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to X1 to ensure projections equal observed values.
        Add any intertemporal constant values to the X1R difference to SSF equation 
        results with zero constants to get the combined set of constants.
        &#34;&#34;&#34;

        if hasattr(self, &#34;_x1_constants&#34;):
            return self._x1_constants

        result: np.ndarray = self.x1r_difference_from_ssf.copy()
        if not hasattr(self, &#34;intertemporal_constants&#34;):
            return result

        i = 0
        for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
            if variable_details[&#39;var_type&#39;] == &#39;x1l&#39;:
                result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
            i = i + 1

        self._x1_constants: np.ndarray = result
        return self._x1_constants

    @property
    def j1_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to J1 to ensure projections equal observed values.
        Add any intertemporal constant values to the X1R difference to SSF equation results with zero constants
        to get the combined set of constants.
        &#34;&#34;&#34;

        if hasattr(self, &#34;_j1_constants&#34;):
            return self._j1_constants

        result: np.ndarray = self.j1r_difference_from_ssf.copy()
        if not hasattr(self, &#34;intertemporal_constants&#34;):
            return result
        i = 0
        for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
            if variable_details[&#39;var_type&#39;] == &#39;j1l&#39;:
                result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
            i = i + 1

        self._j1_constants: np.ndarray = result
        return self._j1_constants

    @property
    def ze_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to ZE to ensure projections equal observed values.
        Add any intertemporal constant values to the X1R difference to SSF equation results with zero constants
        to get the combined set of constants.
        &#34;&#34;&#34;

        if hasattr(self, &#34;_ze_constants&#34;):
            return self._ze_constants

        result: np.ndarray = self.zer_difference_from_ssf.copy()
        if not hasattr(self, &#34;intertemporal_constants&#34;):
            return result

        i = 0
        for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
            if variable_details[&#39;var_type&#39;] == &#39;zel&#39;:
                logging.debug(
                    f&#34;At index {i} intertemporal constant is {self.intertemporal_constants.loc[variable_details[&#39;name&#39;],&#39;constant_value&#39;]} : shape is {self.intertemporal_constants.shape}&#34;)
                result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
            i = i + 1

        self._ze_constants: np.ndarray = result
        return self._ze_constants

    @property
    def z1_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to Z1 to ensure projections equal observed values.
        Add any intertemporal constant values to the X1R difference to SSF equation results with zero constants
        to get the combined set of constants.
        &#34;&#34;&#34;

        if hasattr(self, &#34;_z1_constants&#34;):
            return self._z1_constants

        result: np.ndarray = self.z1r_difference_from_ssf.copy()
        if not hasattr(self, &#34;intertemporal_constants&#34;):
            return result
        i = 0
        for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
            if variable_details[&#39;var_type&#39;] == &#39;z1l&#39;:
                result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
            i = i + 1

        self._z1_constants: np.ndarray = result
        return self._z1_constants

    def __create_exogenous_variable_projections(self):
        &#34;&#34;&#34;
        Populates the exogenous variable values through the projection years. 
        These values are determined outside the system.

        The rolling baseline projections just copy the exogenous values from the previous projections
        and use those as the starting point for the next round of projection generation.

        Otherwise, when initially setting up baseline projections, incorporate values from:
        - the database in the base projection year
        - effective labour productivity projections
        - energy efficiency improvement projections
        &#34;&#34;&#34;

        # If we are doing the baseline projections after rolling forward to a new base projection year,
        # just copy the database values for the exogenous variables over the projection years
        # and then we are done.
        if self.using_rolled_projections:
            matching_indices: pd.Index = self.sym_data.combined_variable_summary.loc[self.sym_data.combined_variable_summary.vector == &#39;exo&#39;, :].index
            self._exo_projections: pd.DataFrame = self.database.data.loc[matching_indices, self.projection_years_column_labels]
            return

        # We got here so we must be setting up the exogenous variable projections for the first time ...

        # Replicate projection base year values across all projection periods for all exogenous variables.
        projections: pd.DataFrame = pd.DataFrame(np.tile(self.first_projection_year_exo, (1, self.configuration.projection_years_count)))
        projections.columns = self.projection_years_column_labels
        projections.reset_index()

        # Add effective labour productivity and energy usage efficiency.
        effective_labour_productivity: EffectiveLabourProductivity = self.model.effective_labour_productivity
        rogy: pd.DataFrame = effective_labour_productivity.rogy
        energy_usage_efficiency: EnergyUsageEfficiency = self.model.energy_usage_efficiency
        for region in self.sym_data.regions_members:

            regional_effective_labour_productivity: pd.DataFrame = effective_labour_productivity.effective_productivity_deviations(region=region)
            regional_energy_usage_efficiency: pd.DataFrame = energy_usage_efficiency.sector_cumulative_energy_usage_efficiency_gains(region=region)
            consumption_energy_usage_efficiency: pd.DataFrame = energy_usage_efficiency.consumption_cumulative_energy_usage_efficiency_gains

            variable_prefix_ROGY: str = f&#34;ROGY&#34;
            rogy_name: str = f&#34;{variable_prefix_ROGY}({region})&#34;
            if self.sym_data.has_variables(variable_name_prefix=rogy_name):
                rogy_index: int = self.sym_data.variable_index(vector_name=&#39;exo&#39;, variable_name=rogy_name)
                rogy_units = self.sym_data.variable_units(vector_name=&#39;exo&#39;, variable_name_prefix=variable_prefix_ROGY)
                rogy_data: pd.DataFrame = rogy.loc[[region], self.projection_years_column_labels]
                if &#39;gdp&#39; in rogy_units:
                    raise Exception(f&#34;{rogy_name} has gdp units so shocks to that variable are not supported.&#34;)

                projections.loc[[rogy_index], :] = projections.loc[[rogy_index], :] + (rogy_data.to_numpy().flatten() / 100)
            # else:
            #     logging.warning(f&#34;{rogy_name} is not in the SYM model.&#34;)

            shefc_name_prefix: str = f&#34;SHEFC&#34;
            shefc_name: str = f&#34;{shefc_name_prefix}({region})&#34;
            if self.sym_data.has_variables(variable_name_prefix=shefc_name_prefix):
                shefc_index: int = self.sym_data.variable_index(vector_name=&#39;exo&#39;, variable_name=shefc_name)
                shefc_units = self.sym_data.variable_units(vector_name=&#39;exo&#39;, variable_name_prefix=shefc_name_prefix)
                shefc_data: pd.DataFrame = consumption_energy_usage_efficiency.loc[[region], self.projection_years_column_labels]
                if &#39;gdp&#39; in shefc_units:
                    raise Exception(f&#34;{shefc_name} has gdp units so shocks to that variable are not supported.&#34;)
                projections.loc[[shefc_index], :] = projections.loc[[shefc_index], :] + (shefc_data.to_numpy().flatten() / 100)
            # else:
            #     logging.warning(f&#34;{shefc_name} is not in the SYM model.&#34;)

            variable_prefix_SHL: str = &#39;SHL&#39;
            variable_prefix_SHEF: str = &#39;SHEF&#39;
            for sector in self.sym_data.sectors_members:

                shl_name: str = f&#34;{variable_prefix_SHL}({region},{sector})&#34;
                if self.sym_data.has_variables(variable_name_prefix=shl_name):
                    shl_index: int = self.sym_data.variable_index(vector_name=&#39;exo&#39;, variable_name=shl_name)
                    shl_units = self.sym_data.variable_units(vector_name=&#39;exo&#39;, variable_name_prefix=variable_prefix_SHL)
                    shl_data: pd.DataFrame = regional_effective_labour_productivity.loc[[sector], self.projection_years_column_labels]
                    if &#39;gdp&#39; in shl_units:
                        raise Exception(f&#34;{shl_name} has gdp units so shocks to that variable are not supported.&#34;)
                    projections.loc[[shl_index], :] = projections.loc[[
                        shl_index], :] + (shl_data.to_numpy().flatten() / 100)
                # else:
                #     logging.warning(f&#34;{shl_name} is not in the SYM model.&#34;)

                shef_name: str = f&#34;{variable_prefix_SHEF}({sector},{region})&#34;
                if self.sym_data.has_variables(variable_name_prefix=shef_name):
                    shef_index: int = self.sym_data.variable_index(vector_name=&#39;exo&#39;, variable_name=shef_name)
                    shef_units = self.sym_data.variable_units(vector_name=&#39;exo&#39;, variable_name_prefix=variable_prefix_SHEF)
                    shef_data: pd.DataFrame = regional_energy_usage_efficiency.loc[[sector], self.projection_years_column_labels]
                    if &#39;gdp&#39; in shef_units:
                        raise Exception(f&#34;{shef_name} has gdp units so shocks to that variable are not supported.&#34;)
                    projections.loc[[shef_index], :] = projections.loc[[shef_index], :] + (shef_data.to_numpy().flatten() / 100)
                # else:
                #     logging.warning(f&#34;{shef_shock_name} is not in the SYM model.&#34;)

        # Index with variable names.
        projections.index = self.sym_data.vector_variable_names(vector_name=&#39;exo&#39;)

        # Store the exogenous projections that will be augmented for other projections.
        self._exo_projections: pd.DataFrame = projections

    def __evaluate_first_projection_year_vector_projections(self):
        &#34;&#34;&#34;
        Computes the values of the model equation vectors in the first projection year, 
        using the functions of future exogenous variables, the stable manifold, etc
        &#34;&#34;&#34;

        self._exo_first_year_projections = self.exo_projections[:, [0]]

        self._yxr_first_year_projections = self.yxr_initial_values.to_numpy().copy()

        # er = h1t*x[][1] + h2t*exog[][1] + h3t[][1];
        self._yjr_first_year_projections = \
            self.stable_manifold.H1 @ self.yxr_first_year_projections + \
            self.stable_manifold.H2 @ self.exo_first_year_projections + \
            self._h3t[:, [0]]

        # tzl = mu1t*x[][1] + mu4t*exog[][1] + c4t[][1];
        self._exz_first_year_projections = \
            self.stable_manifold.mu1 @ self.yxr_first_year_projections + \
            self.stable_manifold.mu2 @ self.exo_first_year_projections + \
            self._c4t[:, [0]]

        # z1l projections = d5n*x[][1]+d7n*exog[][1]+d6n*er+d4n*tzl+cz6[][1]
        self._z1l_first_year_projections = \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;yxr&#39;) @ self.yxr_first_year_projections + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;exo&#39;) @ self.exo_first_year_projections + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;yjr&#39;) @ self.yjr_first_year_projections + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;exz&#39;) @ self.exz_first_year_projections + \
            self.z1r_difference_from_ssf

    @property
    def yxr_first_year_projections(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Projections of X1_t (yxr) in the first projection year
        &#34;&#34;&#34;
        return self._yxr_first_year_projections

    @property
    def yjr_first_year_projections(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Projections of J1_t (yjr) in the first projection year
        &#34;&#34;&#34;
        return self._yjr_first_year_projections

    @property
    def exz_first_year_projections(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Projections of ZE_t (exz) in the first projection year
        &#34;&#34;&#34;
        return self._exz_first_year_projections

    @property
    def z1l_first_year_projections(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Projections of Z1_t (z1l=z1r) in the first projection year
        &#34;&#34;&#34;
        return self._z1l_first_year_projections

    @property
    def exo_first_year_projections(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Projections of EXO_t in the first projection year
        &#34;&#34;&#34;
        return self._exo_first_year_projections

    @property
    def first_year_original_projections_of_variables_adjusted_by_intertemporal_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The first year projected values for the variables that are being
        adjusted by the intertemporal constants.

        The values are those for the projection that is not adjusted by intertemporal constants.
        &#34;&#34;&#34;
        return self._first_year_original_projections_of_variables_adjusted_by_intertemporal_constants

    @property
    def first_year_original_projections_of_yxr(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The first year projected values for the state variables.
        Required for benchmarking against Ox.
        &#34;&#34;&#34;
        return self._first_year_original_projections_of_yxr

    @property
    def first_year_original_projections_of_yjr(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The first year projected values for the costate variables.
        Required for benchmarking against Ox.
        &#34;&#34;&#34;
        return self._first_year_original_projections_of_yjr

    @property
    def first_year_original_projections_of_exz(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The first year projected values for the expected endogenous variables exz.
        Required for benchmarking against Ox.
        &#34;&#34;&#34;
        return self._first_year_original_projections_of_exz

    @property
    def first_year_original_projections_of_z1l(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The first year projected values for the endogenous variables.
        Required for benchmarking against Ox.
        &#34;&#34;&#34;
        return self._first_year_original_projections_of_z1l

    @property
    def first_year_observed_values_of_variables_adjusted_by_intertemporal_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Returns the observed values, in the first projection year, of the 
        variables that are adjusted by intertemporal constants.
        &#34;&#34;&#34;
        return self._first_year_observed_values_of_variables_adjusted_by_intertemporal_constants

    @property
    def intertemporal_constants(self) -&gt; pd.DataFrame:
        return self._intertemporal_constants

    @property
    def partial_derivatives_wrt_intertemporal_constants(self) -&gt; np.ndarray:
        return self._partial_derivatives

    def __calculate_intertemporal_constants(self):
        &#34;&#34;&#34;
        Computes the intertemporal constant adjustments to jump and other variables to align starting data
        values with model projections in the first year.

        Step 1.
        Compute functions of future exogenous variables through all years of the projection.

        Step 2.
        For the variables that are to be adjusted by the intertemporal
        constants, compute their projected values in the base projection year
        and store these values for comparison to perturbed base year projections so we can calculate
        the derivatives matrix needed to set the intertemporal constants.
        Also store the values of each of the 4 vectors in the model in the base year for benchmarking.

        Step 3.
        Initialise the partial derivatives matrix. This is the matrix of derivatives of each of the
        variables that is adjusted by intertemporal constants, with respect to each of the intertemporal
        constants.
        Iterate over the intertemporal constants, perturbing each and recalculating the base year projections
        of the variables that are adjusted by intertemporal constants so that we can 
        estimate the relevant numeric derivatives.
        &#34;&#34;&#34;

        # Step 1.
        self._compute_functions_of_future_exogenous_variables()
        self._reference_c4t_used_to_compute_intertemporal_constants = self.c4t.copy()
        self._reference_h3t_used_to_compute_intertemporal_constants = self.h3t.copy()

        # Step 2.
        self.__evaluate_first_projection_year_vector_projections()
        self._first_year_original_projections_of_yxr = self.yxr_first_year_projections.copy()
        self._first_year_original_projections_of_yjr = self.yjr_first_year_projections.copy()
        self._first_year_original_projections_of_exz = self.exz_first_year_projections.copy()
        self._first_year_original_projections_of_z1l = self.z1l_first_year_projections.copy()
        self._first_year_original_projections_of_variables_adjusted_by_intertemporal_constants = \
            self.first_year_projections_of_variables_adjusted_by_intertemporal_constants.copy()

        # Step 3.
        self._partial_derivatives = np.zeros(shape=(len(self.sym_data.intertemporal_constant_variables), len(
            self.sym_data.variables_adjusted_by_intertemporal_constants)))
        i = 0
        for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
            self.__update_perturbed_variable(variable_details=variable_details)
            self._compute_functions_of_future_exogenous_variables()
            self.__evaluate_first_projection_year_vector_projections()
            self._partial_derivatives[:, [i]] = (
                self.first_year_projections_of_variables_adjusted_by_intertemporal_constants -
                self._first_year_original_projections_of_variables_adjusted_by_intertemporal_constants) \
                / __class__.PERTURBATION
            i += 1

        # Get the unperturbed values of the variables in first projection year

        # Generate the baseline projection to use in computing partial derivatives
        # and to generate matrix values that are used later in projection processes.
        self.__update_perturbed_variable(variable_details=None)

        # Use newtons method adjustment to compute intertemporal constant values
        self._intertemporal_constants = self.sym_data.intertemporal_constant_variables
        values: np.ndarray = np.linalg.inv(self._partial_derivatives) @ \
            (self.first_year_observed_values_of_variables_adjusted_by_intertemporal_constants -
             self.first_year_original_projections_of_variables_adjusted_by_intertemporal_constants)
        values = values.reshape((len(self.intertemporal_constants.index), 1))
        self._intertemporal_constants[&#39;constant_value&#39;] = values
        logging.info(&#34;The intertemporal constants have been calibrated.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gcubed.projections.projections.Projections" href="projections.html#gcubed.projections.projections.Projections">Projections</a></li>
<li><a title="gcubed.base.Base" href="../base.html#gcubed.base.Base">Base</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.PERTURBATION"><code class="name">var <span class="ident">PERTURBATION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.database"><code class="name">var <span class="ident">database</span> : <a title="gcubed.data.gdp_scaled_database.GDPScaledDatabase" href="../data/gdp_scaled_database.html#gcubed.data.gdp_scaled_database.GDPScaledDatabase">GDPScaledDatabase</a></code></dt>
<dd>
<div class="desc"><p>The database used as the starting point for the projections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def database(self) -&gt; GDPScaledDatabase:
    &#34;&#34;&#34;
    The database used as the starting point for the projections.
    &#34;&#34;&#34;
    return self._database</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.exo_first_year_projections"><code class="name">var <span class="ident">exo_first_year_projections</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Projections of EXO_t in the first projection year</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def exo_first_year_projections(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Projections of EXO_t in the first projection year
    &#34;&#34;&#34;
    return self._exo_first_year_projections</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.exz_first_year_projections"><code class="name">var <span class="ident">exz_first_year_projections</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Projections of ZE_t (exz) in the first projection year</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def exz_first_year_projections(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Projections of ZE_t (exz) in the first projection year
    &#34;&#34;&#34;
    return self._exz_first_year_projections</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_exo"><code class="name">var <span class="ident">first_projection_year_exo</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>If the first projection year = t:
Returns the value of exo from the database as the value of exogenous variables (exo)
in period t</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def first_projection_year_exo(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    If the first projection year = t:
    Returns the value of exo from the database as the value of exogenous variables (exo)
    in period t
    &#34;&#34;&#34;
    return self._first_projection_year_exo</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_exz"><code class="name">var <span class="ident">first_projection_year_exz</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>If the first projection year = t:
Returns the value of exz from the database as the value of ze in period t+1</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def first_projection_year_exz(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    If the first projection year = t:
    Returns the value of exz from the database as the value of ze in period t+1
    &#34;&#34;&#34;
    return self._first_projection_year_exz</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_j1r"><code class="name">var <span class="ident">first_projection_year_j1r</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>If the first projection year = t:
Returns the value of j1r from the database as the value of j1 in period t+1</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def first_projection_year_j1r(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    If the first projection year = t:
    Returns the value of j1r from the database as the value of j1 in period t+1
    &#34;&#34;&#34;
    return self._first_projection_year_j1r</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_x1r"><code class="name">var <span class="ident">first_projection_year_x1r</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>If the first projection year = t:
Returns the value of x1r from the database as the value of x1 in period t+1</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def first_projection_year_x1r(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    If the first projection year = t:
    Returns the value of x1r from the database as the value of x1 in period t+1
    &#34;&#34;&#34;
    return self._first_projection_year_x1r</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_yjr"><code class="name">var <span class="ident">first_projection_year_yjr</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>If the first projection year = t:
Returns the value of yjr from the database as the value of j1 in period t</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def first_projection_year_yjr(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    If the first projection year = t:
    Returns the value of yjr from the database as the value of j1 in period t
    &#34;&#34;&#34;
    return self._first_projection_year_yjr</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_yxr"><code class="name">var <span class="ident">first_projection_year_yxr</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>If the first projection year = t:
Returns the value of yxr from the database as the value of x1 in period t</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def first_projection_year_yxr(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    If the first projection year = t:
    Returns the value of yxr from the database as the value of x1 in period t
    &#34;&#34;&#34;
    return self._first_projection_year_yxr</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_z1r"><code class="name">var <span class="ident">first_projection_year_z1r</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>If the first projection year = t:
Returns the value of z1r from the database as the value of z1 in period t</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def first_projection_year_z1r(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    If the first projection year = t:
    Returns the value of z1r from the database as the value of z1 in period t
    &#34;&#34;&#34;
    return self._first_projection_year_z1r</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_zer"><code class="name">var <span class="ident">first_projection_year_zer</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>If the first projection year = t:
Returns the value of zer from the database as the value of x1 in period t</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def first_projection_year_zer(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    If the first projection year = t:
    Returns the value of zer from the database as the value of x1 in period t
    &#34;&#34;&#34;
    return self._first_projection_year_zer</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.first_year_observed_values_of_variables_adjusted_by_intertemporal_constants"><code class="name">var <span class="ident">first_year_observed_values_of_variables_adjusted_by_intertemporal_constants</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Returns the observed values, in the first projection year, of the
variables that are adjusted by intertemporal constants.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def first_year_observed_values_of_variables_adjusted_by_intertemporal_constants(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Returns the observed values, in the first projection year, of the 
    variables that are adjusted by intertemporal constants.
    &#34;&#34;&#34;
    return self._first_year_observed_values_of_variables_adjusted_by_intertemporal_constants</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.first_year_original_projections_of_exz"><code class="name">var <span class="ident">first_year_original_projections_of_exz</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The first year projected values for the expected endogenous variables exz.
Required for benchmarking against Ox.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def first_year_original_projections_of_exz(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The first year projected values for the expected endogenous variables exz.
    Required for benchmarking against Ox.
    &#34;&#34;&#34;
    return self._first_year_original_projections_of_exz</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.first_year_original_projections_of_variables_adjusted_by_intertemporal_constants"><code class="name">var <span class="ident">first_year_original_projections_of_variables_adjusted_by_intertemporal_constants</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The first year projected values for the variables that are being
adjusted by the intertemporal constants.</p>
<p>The values are those for the projection that is not adjusted by intertemporal constants.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def first_year_original_projections_of_variables_adjusted_by_intertemporal_constants(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The first year projected values for the variables that are being
    adjusted by the intertemporal constants.

    The values are those for the projection that is not adjusted by intertemporal constants.
    &#34;&#34;&#34;
    return self._first_year_original_projections_of_variables_adjusted_by_intertemporal_constants</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.first_year_original_projections_of_yjr"><code class="name">var <span class="ident">first_year_original_projections_of_yjr</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The first year projected values for the costate variables.
Required for benchmarking against Ox.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def first_year_original_projections_of_yjr(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The first year projected values for the costate variables.
    Required for benchmarking against Ox.
    &#34;&#34;&#34;
    return self._first_year_original_projections_of_yjr</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.first_year_original_projections_of_yxr"><code class="name">var <span class="ident">first_year_original_projections_of_yxr</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The first year projected values for the state variables.
Required for benchmarking against Ox.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def first_year_original_projections_of_yxr(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The first year projected values for the state variables.
    Required for benchmarking against Ox.
    &#34;&#34;&#34;
    return self._first_year_original_projections_of_yxr</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.first_year_original_projections_of_z1l"><code class="name">var <span class="ident">first_year_original_projections_of_z1l</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The first year projected values for the endogenous variables.
Required for benchmarking against Ox.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def first_year_original_projections_of_z1l(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The first year projected values for the endogenous variables.
    Required for benchmarking against Ox.
    &#34;&#34;&#34;
    return self._first_year_original_projections_of_z1l</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.first_year_projections_of_variables_adjusted_by_intertemporal_constants"><code class="name">var <span class="ident">first_year_projections_of_variables_adjusted_by_intertemporal_constants</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The values of the variables that have been changed by the perturbation to
an intertemporal constant as part of computing partial derivatives for setting the
intertemporal constants appropriately. These values are a column vector
for the first projection year only.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def first_year_projections_of_variables_adjusted_by_intertemporal_constants(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The values of the variables that have been changed by the perturbation to 
    an intertemporal constant as part of computing partial derivatives for setting the
    intertemporal constants appropriately. These values are a column vector
    for the first projection year only.
    &#34;&#34;&#34;
    result = np.zeros(shape=(len(self.sym_data.variables_adjusted_by_intertemporal_constants), 1))
    i = 0
    for index, adjusted_variable_details in self.sym_data.variables_adjusted_by_intertemporal_constants.iterrows():
        sequence = adjusted_variable_details[&#39;sequence&#39;]
        match adjusted_variable_details[&#39;var_type&#39;]:
            case &#39;x1l&#39;:
                result[i, 0] = self.yxr_first_year_projections[[sequence]]
            case &#39;j1l&#39;:
                result[i, 0] = self.yjr_first_year_projections[[sequence]]
            case &#39;zel&#39;:
                result[i, 0] = self.exz_first_year_projections[[sequence]]
            case &#39;z1l&#39;:
                result[i, 0] = self.z1l_first_year_projections[[sequence]]
        i += 1
    return result</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.intertemporal_constants"><code class="name">var <span class="ident">intertemporal_constants</span> : pandas.core.frame.DataFrame</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def intertemporal_constants(self) -&gt; pd.DataFrame:
    return self._intertemporal_constants</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.j1_constants"><code class="name">var <span class="ident">j1_constants</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The constant adjustments to J1 to ensure projections equal observed values.
Add any intertemporal constant values to the X1R difference to SSF equation results with zero constants
to get the combined set of constants.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def j1_constants(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The constant adjustments to J1 to ensure projections equal observed values.
    Add any intertemporal constant values to the X1R difference to SSF equation results with zero constants
    to get the combined set of constants.
    &#34;&#34;&#34;

    if hasattr(self, &#34;_j1_constants&#34;):
        return self._j1_constants

    result: np.ndarray = self.j1r_difference_from_ssf.copy()
    if not hasattr(self, &#34;intertemporal_constants&#34;):
        return result
    i = 0
    for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
        if variable_details[&#39;var_type&#39;] == &#39;j1l&#39;:
            result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
        i = i + 1

    self._j1_constants: np.ndarray = result
    return self._j1_constants</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.j1r_difference_from_ssf"><code class="name">var <span class="ident">j1r_difference_from_ssf</span></code></dt>
<dd>
<div class="desc"><p>In Ox: decl cz4 = j1r - j1l</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def j1r_difference_from_ssf(self):
    &#34;&#34;&#34;
    In Ox: decl cz4 = j1r - j1l
    &#34;&#34;&#34;
    return self._j1r_difference_from_ssf</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.partial_derivatives_wrt_intertemporal_constants"><code class="name">var <span class="ident">partial_derivatives_wrt_intertemporal_constants</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def partial_derivatives_wrt_intertemporal_constants(self) -&gt; np.ndarray:
    return self._partial_derivatives</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.perturbed_variable_details"><code class="name">var <span class="ident">perturbed_variable_details</span> : pandas.core.series.Series</code></dt>
<dd>
<div class="desc"><p>The var_map details of the variable being perturbed to as part of computing
derivatives needed to set intertemporal constants or none if just doing projections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def perturbed_variable_details(self) -&gt; pd.Series:
    &#34;&#34;&#34;
    The var_map details of the variable being perturbed to as part of computing
    derivatives needed to set intertemporal constants or none if just doing projections.
    &#34;&#34;&#34;
    if hasattr(self, &#39;_perturbed_variable_details&#39;):
        return self._perturbed_variable_details
    return None</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.reference_c4t_used_to_compute_intertemporal_constants"><code class="name">var <span class="ident">reference_c4t_used_to_compute_intertemporal_constants</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Equivalent to c4t in the Ox implementation
Functions of current and future exogenous variables affecting ZE.
This is the reference version of h3t, computed to calculation the projections
for the base year that will be used as a reference projection when determining
the numeric derivatives for calculation of the intertemporal constants.</p>
<p>Its only role is to preserve the appropriate information for benchmarking against Ox.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def reference_c4t_used_to_compute_intertemporal_constants(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Equivalent to c4t in the Ox implementation
    Functions of current and future exogenous variables affecting ZE.
    This is the reference version of h3t, computed to calculation the projections
    for the base year that will be used as a reference projection when determining 
    the numeric derivatives for calculation of the intertemporal constants.

    Its only role is to preserve the appropriate information for benchmarking against Ox.
    &#34;&#34;&#34;
    return self._reference_c4t_used_to_compute_intertemporal_constants</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.reference_h3t_used_to_compute_intertemporal_constants"><code class="name">var <span class="ident">reference_h3t_used_to_compute_intertemporal_constants</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Equivalent to h3t in the Ox implementation
Functions of current and future exogenous variables affecting J1.
This is the reference version of h3t, computed to calculation the projections
for the base year that will be used as a reference projection when determining
the numeric derivatives for calculation of the intertemporal constants.</p>
<p>Its only role is to preserve the appropriate information for benchmarking against Ox.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def reference_h3t_used_to_compute_intertemporal_constants(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Equivalent to h3t in the Ox implementation
    Functions of current and future exogenous variables affecting J1.
    This is the reference version of h3t, computed to calculation the projections
    for the base year that will be used as a reference projection when determining 
    the numeric derivatives for calculation of the intertemporal constants.

    Its only role is to preserve the appropriate information for benchmarking against Ox.
    &#34;&#34;&#34;
    return self._reference_h3t_used_to_compute_intertemporal_constants</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.using_rolled_projections"><code class="name">var <span class="ident">using_rolled_projections</span> : bool</code></dt>
<dd>
<div class="desc"><p>True if these projections are building on
previous projections rather than just observed data.</p>
<p>This affects how the baseline projections are set up in terms
of the constants used.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def using_rolled_projections(self) -&gt; bool:
    &#34;&#34;&#34;
    True if these projections are building on
    previous projections rather than just observed data.

    This affects how the baseline projections are set up in terms
    of the constants used.
    &#34;&#34;&#34;
    return self.database.has_data_for_all_projection_years</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.x1_constants"><code class="name">var <span class="ident">x1_constants</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The constant adjustments to X1 to ensure projections equal observed values.
Add any intertemporal constant values to the X1R difference to SSF equation
results with zero constants to get the combined set of constants.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def x1_constants(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The constant adjustments to X1 to ensure projections equal observed values.
    Add any intertemporal constant values to the X1R difference to SSF equation 
    results with zero constants to get the combined set of constants.
    &#34;&#34;&#34;

    if hasattr(self, &#34;_x1_constants&#34;):
        return self._x1_constants

    result: np.ndarray = self.x1r_difference_from_ssf.copy()
    if not hasattr(self, &#34;intertemporal_constants&#34;):
        return result

    i = 0
    for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
        if variable_details[&#39;var_type&#39;] == &#39;x1l&#39;:
            result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
        i = i + 1

    self._x1_constants: np.ndarray = result
    return self._x1_constants</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.x1r_difference_from_ssf"><code class="name">var <span class="ident">x1r_difference_from_ssf</span></code></dt>
<dd>
<div class="desc"><p>In Ox: decl cz2 = x1r - x1l</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def x1r_difference_from_ssf(self):
    &#34;&#34;&#34;
    In Ox: decl cz2 = x1r - x1l
    &#34;&#34;&#34;
    return self._x1r_difference_from_ssf</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.yjr_first_year_projections"><code class="name">var <span class="ident">yjr_first_year_projections</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Projections of J1_t (yjr) in the first projection year</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def yjr_first_year_projections(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Projections of J1_t (yjr) in the first projection year
    &#34;&#34;&#34;
    return self._yjr_first_year_projections</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.yxr_first_year_projections"><code class="name">var <span class="ident">yxr_first_year_projections</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Projections of X1_t (yxr) in the first projection year</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def yxr_first_year_projections(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Projections of X1_t (yxr) in the first projection year
    &#34;&#34;&#34;
    return self._yxr_first_year_projections</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.z1_constants"><code class="name">var <span class="ident">z1_constants</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The constant adjustments to Z1 to ensure projections equal observed values.
Add any intertemporal constant values to the X1R difference to SSF equation results with zero constants
to get the combined set of constants.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def z1_constants(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The constant adjustments to Z1 to ensure projections equal observed values.
    Add any intertemporal constant values to the X1R difference to SSF equation results with zero constants
    to get the combined set of constants.
    &#34;&#34;&#34;

    if hasattr(self, &#34;_z1_constants&#34;):
        return self._z1_constants

    result: np.ndarray = self.z1r_difference_from_ssf.copy()
    if not hasattr(self, &#34;intertemporal_constants&#34;):
        return result
    i = 0
    for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
        if variable_details[&#39;var_type&#39;] == &#39;z1l&#39;:
            result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
        i = i + 1

    self._z1_constants: np.ndarray = result
    return self._z1_constants</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.z1l_first_year_projections"><code class="name">var <span class="ident">z1l_first_year_projections</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Projections of Z1_t (z1l=z1r) in the first projection year</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def z1l_first_year_projections(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Projections of Z1_t (z1l=z1r) in the first projection year
    &#34;&#34;&#34;
    return self._z1l_first_year_projections</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.z1r_difference_from_ssf"><code class="name">var <span class="ident">z1r_difference_from_ssf</span></code></dt>
<dd>
<div class="desc"><p>In Ox: decl cz6 = z1r - z1l</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def z1r_difference_from_ssf(self):
    &#34;&#34;&#34;
    In Ox: decl cz6 = z1r - z1l
    &#34;&#34;&#34;
    return self._z1r_difference_from_ssf</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.ze_constants"><code class="name">var <span class="ident">ze_constants</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The constant adjustments to ZE to ensure projections equal observed values.
Add any intertemporal constant values to the X1R difference to SSF equation results with zero constants
to get the combined set of constants.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ze_constants(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The constant adjustments to ZE to ensure projections equal observed values.
    Add any intertemporal constant values to the X1R difference to SSF equation results with zero constants
    to get the combined set of constants.
    &#34;&#34;&#34;

    if hasattr(self, &#34;_ze_constants&#34;):
        return self._ze_constants

    result: np.ndarray = self.zer_difference_from_ssf.copy()
    if not hasattr(self, &#34;intertemporal_constants&#34;):
        return result

    i = 0
    for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
        if variable_details[&#39;var_type&#39;] == &#39;zel&#39;:
            logging.debug(
                f&#34;At index {i} intertemporal constant is {self.intertemporal_constants.loc[variable_details[&#39;name&#39;],&#39;constant_value&#39;]} : shape is {self.intertemporal_constants.shape}&#34;)
            result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
        i = i + 1

    self._ze_constants: np.ndarray = result
    return self._ze_constants</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.zer_difference_from_ssf"><code class="name">var <span class="ident">zer_difference_from_ssf</span></code></dt>
<dd>
<div class="desc"><p>In Ox: decl cz5 = zer - zel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def zer_difference_from_ssf(self):
    &#34;&#34;&#34;
    In Ox: decl cz5 = zer - zel
    &#34;&#34;&#34;
    return self._zer_difference_from_ssf</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gcubed.projections.projections.Projections" href="projections.html#gcubed.projections.projections.Projections">Projections</a></b></code>:
<ul class="hlist">
<li><code><a title="gcubed.projections.projections.Projections.c4t" href="projections.html#gcubed.projections.projections.Projections.c4t">c4t</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.configuration" href="projections.html#gcubed.projections.projections.Projections.configuration">configuration</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.database_projections" href="projections.html#gcubed.projections.projections.Projections.database_projections">database_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.exo_projections" href="projections.html#gcubed.projections.projections.Projections.exo_projections">exo_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.exo_projections_as_dataframe" href="projections.html#gcubed.projections.projections.Projections.exo_projections_as_dataframe">exo_projections_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.exz_projections" href="projections.html#gcubed.projections.projections.Projections.exz_projections">exz_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.exz_projections_as_dataframe" href="projections.html#gcubed.projections.projections.Projections.exz_projections_as_dataframe">exz_projections_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.first_projection_year" href="projections.html#gcubed.projections.projections.Projections.first_projection_year">first_projection_year</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.get_differences_between_projections" href="projections.html#gcubed.projections.projections.Projections.get_differences_between_projections">get_differences_between_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.get_year_labels" href="../base.html#gcubed.base.Base.get_year_labels">get_year_labels</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.graphable_projections" href="projections.html#gcubed.projections.projections.Projections.graphable_projections">graphable_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.h3t" href="projections.html#gcubed.projections.projections.Projections.h3t">h3t</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.is_baseline_projections" href="projections.html#gcubed.projections.projections.Projections.is_baseline_projections">is_baseline_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.last_projection_year" href="projections.html#gcubed.projections.projections.Projections.last_projection_year">last_projection_year</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.load_data" href="../base.html#gcubed.base.Base.load_data">load_data</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.long_rate_constants" href="projections.html#gcubed.projections.projections.Projections.long_rate_constants">long_rate_constants</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.model" href="projections.html#gcubed.projections.projections.Projections.model">model</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.parameters" href="projections.html#gcubed.projections.projections.Projections.parameters">parameters</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.projection_years" href="projections.html#gcubed.projections.projections.Projections.projection_years">projection_years</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.projection_years_column_labels" href="projections.html#gcubed.projections.projections.Projections.projection_years_column_labels">projection_years_column_labels</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.projections" href="projections.html#gcubed.projections.projections.Projections.projections">projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.publishable_projections" href="projections.html#gcubed.projections.projections.Projections.publishable_projections">publishable_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.stable_manifold" href="projections.html#gcubed.projections.projections.Projections.stable_manifold">stable_manifold</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.state_space_form" href="projections.html#gcubed.projections.projections.Projections.state_space_form">state_space_form</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.sym_data" href="projections.html#gcubed.projections.projections.Projections.sym_data">sym_data</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.yjr_projections" href="projections.html#gcubed.projections.projections.Projections.yjr_projections">yjr_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.yjr_projections_as_dataframe" href="projections.html#gcubed.projections.projections.Projections.yjr_projections_as_dataframe">yjr_projections_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.yxr_initial_values" href="projections.html#gcubed.projections.projections.Projections.yxr_initial_values">yxr_initial_values</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.yxr_projections" href="projections.html#gcubed.projections.projections.Projections.yxr_projections">yxr_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.yxr_projections_as_dataframe" href="projections.html#gcubed.projections.projections.Projections.yxr_projections_as_dataframe">yxr_projections_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.z1l_projections" href="projections.html#gcubed.projections.projections.Projections.z1l_projections">z1l_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.z1l_projections_as_dataframe" href="projections.html#gcubed.projections.projections.Projections.z1l_projections_as_dataframe">z1l_projections_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.zel_projections" href="projections.html#gcubed.projections.projections.Projections.zel_projections">zel_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.zel_projections_as_dataframe" href="projections.html#gcubed.projections.projections.Projections.zel_projections_as_dataframe">zel_projections_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.zeros" href="../base.html#gcubed.base.Base.zeros">zeros</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gcubed.projections" href="index.html">gcubed.projections</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gcubed.projections.baseline_projections.BaselineProjections" href="#gcubed.projections.baseline_projections.BaselineProjections">BaselineProjections</a></code></h4>
<ul class="">
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.PERTURBATION" href="#gcubed.projections.baseline_projections.BaselineProjections.PERTURBATION">PERTURBATION</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.database" href="#gcubed.projections.baseline_projections.BaselineProjections.database">database</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.exo_first_year_projections" href="#gcubed.projections.baseline_projections.BaselineProjections.exo_first_year_projections">exo_first_year_projections</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.exz_first_year_projections" href="#gcubed.projections.baseline_projections.BaselineProjections.exz_first_year_projections">exz_first_year_projections</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_exo" href="#gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_exo">first_projection_year_exo</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_exz" href="#gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_exz">first_projection_year_exz</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_j1r" href="#gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_j1r">first_projection_year_j1r</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_x1r" href="#gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_x1r">first_projection_year_x1r</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_yjr" href="#gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_yjr">first_projection_year_yjr</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_yxr" href="#gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_yxr">first_projection_year_yxr</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_z1r" href="#gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_z1r">first_projection_year_z1r</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_zer" href="#gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_zer">first_projection_year_zer</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.first_year_observed_values_of_variables_adjusted_by_intertemporal_constants" href="#gcubed.projections.baseline_projections.BaselineProjections.first_year_observed_values_of_variables_adjusted_by_intertemporal_constants">first_year_observed_values_of_variables_adjusted_by_intertemporal_constants</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.first_year_original_projections_of_exz" href="#gcubed.projections.baseline_projections.BaselineProjections.first_year_original_projections_of_exz">first_year_original_projections_of_exz</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.first_year_original_projections_of_variables_adjusted_by_intertemporal_constants" href="#gcubed.projections.baseline_projections.BaselineProjections.first_year_original_projections_of_variables_adjusted_by_intertemporal_constants">first_year_original_projections_of_variables_adjusted_by_intertemporal_constants</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.first_year_original_projections_of_yjr" href="#gcubed.projections.baseline_projections.BaselineProjections.first_year_original_projections_of_yjr">first_year_original_projections_of_yjr</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.first_year_original_projections_of_yxr" href="#gcubed.projections.baseline_projections.BaselineProjections.first_year_original_projections_of_yxr">first_year_original_projections_of_yxr</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.first_year_original_projections_of_z1l" href="#gcubed.projections.baseline_projections.BaselineProjections.first_year_original_projections_of_z1l">first_year_original_projections_of_z1l</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.first_year_projections_of_variables_adjusted_by_intertemporal_constants" href="#gcubed.projections.baseline_projections.BaselineProjections.first_year_projections_of_variables_adjusted_by_intertemporal_constants">first_year_projections_of_variables_adjusted_by_intertemporal_constants</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.intertemporal_constants" href="#gcubed.projections.baseline_projections.BaselineProjections.intertemporal_constants">intertemporal_constants</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.j1_constants" href="#gcubed.projections.baseline_projections.BaselineProjections.j1_constants">j1_constants</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.j1r_difference_from_ssf" href="#gcubed.projections.baseline_projections.BaselineProjections.j1r_difference_from_ssf">j1r_difference_from_ssf</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.partial_derivatives_wrt_intertemporal_constants" href="#gcubed.projections.baseline_projections.BaselineProjections.partial_derivatives_wrt_intertemporal_constants">partial_derivatives_wrt_intertemporal_constants</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.perturbed_variable_details" href="#gcubed.projections.baseline_projections.BaselineProjections.perturbed_variable_details">perturbed_variable_details</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.reference_c4t_used_to_compute_intertemporal_constants" href="#gcubed.projections.baseline_projections.BaselineProjections.reference_c4t_used_to_compute_intertemporal_constants">reference_c4t_used_to_compute_intertemporal_constants</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.reference_h3t_used_to_compute_intertemporal_constants" href="#gcubed.projections.baseline_projections.BaselineProjections.reference_h3t_used_to_compute_intertemporal_constants">reference_h3t_used_to_compute_intertemporal_constants</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.using_rolled_projections" href="#gcubed.projections.baseline_projections.BaselineProjections.using_rolled_projections">using_rolled_projections</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.x1_constants" href="#gcubed.projections.baseline_projections.BaselineProjections.x1_constants">x1_constants</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.x1r_difference_from_ssf" href="#gcubed.projections.baseline_projections.BaselineProjections.x1r_difference_from_ssf">x1r_difference_from_ssf</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.yjr_first_year_projections" href="#gcubed.projections.baseline_projections.BaselineProjections.yjr_first_year_projections">yjr_first_year_projections</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.yxr_first_year_projections" href="#gcubed.projections.baseline_projections.BaselineProjections.yxr_first_year_projections">yxr_first_year_projections</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.z1_constants" href="#gcubed.projections.baseline_projections.BaselineProjections.z1_constants">z1_constants</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.z1l_first_year_projections" href="#gcubed.projections.baseline_projections.BaselineProjections.z1l_first_year_projections">z1l_first_year_projections</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.z1r_difference_from_ssf" href="#gcubed.projections.baseline_projections.BaselineProjections.z1r_difference_from_ssf">z1r_difference_from_ssf</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.ze_constants" href="#gcubed.projections.baseline_projections.BaselineProjections.ze_constants">ze_constants</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.zer_difference_from_ssf" href="#gcubed.projections.baseline_projections.BaselineProjections.zer_difference_from_ssf">zer_difference_from_ssf</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
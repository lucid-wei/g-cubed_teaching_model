<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gcubed.projections.baseline_projections API documentation</title>
<meta name="description" content="Contains the `BaselineProjections` class, used for doing baseline projections." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gcubed.projections.baseline_projections</code></h1>
</header>
<section id="section-intro">
<p>Contains the <code><a title="gcubed.projections.baseline_projections.BaselineProjections" href="#gcubed.projections.baseline_projections.BaselineProjections">BaselineProjections</a></code> class, used for doing baseline projections.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># ------------------------------------------------------------------
# Purpose: Compute and provide access to baseline projections.
# Author: Geoff Shuetrim
# ------------------------------------------------------------------
&#34;&#34;&#34;
Contains the `BaselineProjections` class, used for doing baseline projections.
&#34;&#34;&#34;
import logging
from typing import Optional # DO NOT DELETE THIS IMPORT it manages circular references.
import pandas as pd
import numpy as np
from gcubed.constants import Constants
from gcubed.linearisation.stable_manifold import StableManifold
from gcubed.data.gdp_scaled_database import GDPScaledDatabase
from gcubed.baseline.effective_labour_productivity import EffectiveLabourProductivity
from gcubed.baseline.energy_usage_efficiency import EnergyUsageEfficiency
from gcubed.projections.projections import Projections


class BaselineProjections(Projections):
    &#34;&#34;&#34;
    ### Overview

    Compute the baseline model projections over the projection horizon 
    from the first projection year (a year with available data to be 
    matched by the projections) through to the last projection year.

    &#34;&#34;&#34;

    def __init__(self, stable_manifold: StableManifold, start_from_neutral_real_interest_rate: bool = None) -&gt; None:
        &#34;&#34;&#34;
       ### Arguments

        `stable_manifold`: The stable manifold that provides access to all 
        of the model information required to produce projections.

        `start_from_neutral_real_interest_rate`: `True` if the baseline projections start from 
        the neutral real interest rate and `False` if they start from the observed real interest rates.
        This parameter defaults to a value of `None` which means that the baseline projections start
        from the neutral real interest rate if the linear model used for the
        projections was done at the neutral real interest rate.
        &#34;&#34;&#34;
        logging.info(&#34;Setting up the baseline projections.&#34;)

        super().__init__(stable_manifold=stable_manifold)
        self._is_baseline_projections = True

        # Determine whether the baseline projections start the projections from the neutral 
        # real interest rate or from the observed real interest rates.
        if start_from_neutral_real_interest_rate is None:
            self._start_from_neutral_real_interest_rate = self.stable_manifold.ssf.linear_model.use_neutral_real_interest_rate
        else:
            self._start_from_neutral_real_interest_rate = start_from_neutral_real_interest_rate
        
        self._database = GDPScaledDatabase(database=self.model.database, base_year=self.configuration.base_year)

        self.__set_first_projection_year_observed_values()

        self.__store_observed_yxr_values_in_first_projection_year()

        # Set up the exogenous variable projections
        self.__create_exogenous_variable_projections()

        self.__store_observed_values_of_variables_adjusted_by_intertemporal_constants_in_first_projection_year()
        self.__compute_first_projection_year_ssf_deviations_from_observed_values()

        # Set up the intertemporal constant variables
        self.__calculate_intertemporal_constants()

        # Generate the baseline projections
        self._generate_projections()

        # Generate the database projections
        self._generate_database_projections()

        # Generate publishable version of the projections
        self._generate_publishable_projections()

        self.__validate()


    def __validate(self):
        &#34;&#34;&#34;
        TODO:  Validate the projections: 
        1. check that they are available for the expected projection years.
        2. Check that the base year projections are equal to the base year data values.
        &#34;&#34;&#34;
        logging.info(&#34;The baseline projections have been generated.&#34;)

    @property
    def baseline_projections(self) -&gt; Optional[&#39;BaselineProjections&#39;]:
        return self

    @property
    def database(self) -&gt; GDPScaledDatabase:
        &#34;&#34;&#34;
        The database used as the starting point for the projections.
        &#34;&#34;&#34;
        return self._database

    @property
    def start_from_neutral_real_interest_rate(self) -&gt; bool:
        &#34;&#34;&#34;
        `True` if interest rates are set to the neutral real interest
        rate for the start of the baseline projections and `False` otherwise.
        &#34;&#34;&#34;
        return self._start_from_neutral_real_interest_rate

    def __update_perturbed_variable(self, variable_details: pd.Series):
        &#34;&#34;&#34;
        ### Overview

        For each variable that has an intertemporal constant, we need to compute
        numerical approximations to the partial derivatives of the model with respect
        to that constant. Those  partial derivatives are approximated by evaluating the 
        relevant equations in the model using the data in the first projection year and then 
        again evaluating those equations after perturbing the variable of interest by
        `Constants.DELTA`. The difference between the two evaluations is used
        to compute the partial derivatives for that constant.

        This function does the work of perturbing the intertemporal constant 
        associated with the variable, preparing for calculation of the partial 
        derivatives for that constant.

        The adjustment to the constant (the perturbation) is made by adjusting the
        constants associated with variables&#39; observed differences from their state 
        space form equation evaluations in the baseline&#39;s first projection year.

        The original value of that constant is tracked using the private property, 
        `_original_value`, so that it can be restored after the partial derivatives
        have been computed.

        This function is called once for each variable in the SYM table of intertemporal 
        constant variables, as part of computing the intertemporal constants.

        &#34;&#34;&#34;

        if hasattr(self, &#39;_perturbed_variable_details&#39;):
            sequence = self._perturbed_variable_details[&#39;sequence&#39;]
            match self._perturbed_variable_details[&#39;var_type&#39;]:
                case &#39;x1l&#39;:
                    self.x1r_difference_from_ssf[sequence] = self._original_value
                case &#39;j1l&#39;:
                    self.j1r_difference_from_ssf[sequence] = self._original_value
                case &#39;zel&#39;:
                    self.zer_difference_from_ssf[sequence] = self._original_value
                case &#39;z1l&#39;:
                    self.z1r_difference_from_ssf[sequence] = self._original_value
            delattr(self, &#39;_original_value&#39;)

        if variable_details is None:
            delattr(self, &#39;_perturbed_variable_details&#39;)
        else:
            sequence = variable_details[&#39;sequence&#39;]
            match variable_details[&#39;var_type&#39;]:
                case &#39;x1l&#39;:
                    self._original_value = float(self.x1r_difference_from_ssf[sequence])
                    self.x1r_difference_from_ssf[sequence] = self._original_value + Constants().DELTA
                case &#39;j1l&#39;:
                    self._original_value = float(self.j1r_difference_from_ssf[sequence])
                    self.j1r_difference_from_ssf[sequence] = self._original_value + Constants().DELTA
                case &#39;zel&#39;:
                    self._original_value = float(self.zer_difference_from_ssf[sequence])
                    self.zer_difference_from_ssf[sequence] = self._original_value + Constants().DELTA
                case &#39;z1l&#39;:
                    self._original_value = float(self.z1r_difference_from_ssf[sequence])
                    self.z1r_difference_from_ssf[sequence] = self._original_value + Constants().DELTA
            self._perturbed_variable_details = variable_details

    @property
    def perturbed_variable_details(self) -&gt; pd.Series:
        &#34;&#34;&#34;
        If computing intertemporal constants, 
        the var_map details (the row of the SYM var_map dataframe)
        for the variable being perturbed as part of computing
        derivatives needed to set intertemporal constants. Otherwise, this returns
        `None` if just producing the baseline projections.
        &#34;&#34;&#34;
        if hasattr(self, &#39;_perturbed_variable_details&#39;):
            return self._perturbed_variable_details
        return None

    @property
    def first_year_projections_of_variables_adjusted_by_intertemporal_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        An column vector of first year projection values for those variables that are adjusted
        by intertemporal constants.

        The vector is populated from the vectors of first year projections for 
        each of `x1l`, `j1l`, `zel`,  and `z1l`.
        &#34;&#34;&#34;
        result = np.zeros(shape=(len(self.sym_data.variables_adjusted_by_intertemporal_constants), 1))
        i = 0
        for index, adjusted_variable_details in self.sym_data.variables_adjusted_by_intertemporal_constants.iterrows():
            sequence = adjusted_variable_details[&#39;sequence&#39;]
            match adjusted_variable_details[&#39;var_type&#39;]:
                case &#39;x1l&#39;:
                    result[i, 0] = self.yxr_first_year_projections[[sequence]]
                case &#39;j1l&#39;:
                    result[i, 0] = self.yjr_first_year_projections[[sequence]]
                case &#39;zel&#39;:
                    result[i, 0] = self.exz_first_year_projections[[sequence]]
                case &#39;z1l&#39;:
                    result[i, 0] = self.z1l_first_year_projections[[sequence]]
            i += 1
        return result

    def __set_first_projection_year_observed_values(self):
        &#34;&#34;&#34;
        ### Overview

        Populates the model vectors using the database values associated with 
        the first projection year. 
        
        Note that some variables are populated iwth
        data from adjacent years. Review the `Database.rhs_vector_value` method
        for details. 
        
        Note also that there is the option to override real and 
        nominal interest rates with values associated with inflation neutrality.
        &#34;&#34;&#34;
        # RHS (identical to LHS) vector values to be compared to SSF calculated values
        self._first_projection_year_x1r: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;x1r&#39;, year=self.first_projection_year, use_neutral_real_interest_rate=self.start_from_neutral_real_interest_rate)  # t+1
        self._first_projection_year_j1r: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;j1r&#39;, year=self.first_projection_year, use_neutral_real_interest_rate=self.start_from_neutral_real_interest_rate)  # t+1
        self._first_projection_year_zer: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;zer&#39;, year=self.first_projection_year, use_neutral_real_interest_rate=self.start_from_neutral_real_interest_rate)  # t
        self._first_projection_year_z1r: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;z1r&#39;, year=self.first_projection_year, use_neutral_real_interest_rate=self.start_from_neutral_real_interest_rate)  # t

        # SSF RHS vector values
        self._first_projection_year_yxr: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;yxr&#39;, year=self.first_projection_year, use_neutral_real_interest_rate=self.start_from_neutral_real_interest_rate)  # t
        self._first_projection_year_yjr: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;yjr&#39;, year=self.first_projection_year, use_neutral_real_interest_rate=self.start_from_neutral_real_interest_rate)  # t
        self._first_projection_year_exz: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;exz&#39;, year=self.first_projection_year, use_neutral_real_interest_rate=self.start_from_neutral_real_interest_rate)  # t+1
        self._first_projection_year_exo: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;exo&#39;, year=self.first_projection_year, use_neutral_real_interest_rate=self.start_from_neutral_real_interest_rate)  # t

    def __store_observed_yxr_values_in_first_projection_year(self):
        &#34;&#34;&#34;
        ### Overview

        Save the values of the state vector (X1) in the first projection year to use in
        initiating the projection process.
        &#34;&#34;&#34;
        yxr_initial_values = pd.DataFrame(self.first_projection_year_yxr.copy())
        yxr_initial_values.index = self.sym_data.vector_variable_names(vector_name=&#39;yxr&#39;)
        yxr_initial_values.columns = [str(self.first_projection_year)]
        self._yxr_initial_values: pd.DataFrame = yxr_initial_values

    def __store_observed_values_of_variables_adjusted_by_intertemporal_constants_in_first_projection_year(self):
        &#34;&#34;&#34;
        ### Overview

        Save the database values of the variables
        that are adjusted by intertemporal constants so that we can use
        those as the values we adjust the variables to using the intertemporal
        constants.
        &#34;&#34;&#34;
        self._first_year_observed_values_of_variables_adjusted_by_intertemporal_constants: np.ndarray = \
            np.zeros(shape=(len(self.sym_data.variables_adjusted_by_intertemporal_constants), 1))
        i = 0
        for index, adjusted_variable_details in self.sym_data.variables_adjusted_by_intertemporal_constants.iterrows():
            sequence = adjusted_variable_details[&#39;sequence&#39;]
            match adjusted_variable_details[&#39;var_type&#39;]:
                case &#39;x1l&#39;:
                    self._first_year_observed_values_of_variables_adjusted_by_intertemporal_constants[i, 0] = self.first_projection_year_yxr[[sequence]]  # t = base year
                case &#39;j1l&#39;:
                    self._first_year_observed_values_of_variables_adjusted_by_intertemporal_constants[i, 0] = self.first_projection_year_yjr[[sequence]]  # t = base year
                case &#39;zel&#39;:
                    self._first_year_observed_values_of_variables_adjusted_by_intertemporal_constants[i, 0] = self.first_projection_year_exz[[sequence]]  # t+1 = year after base year
                case &#39;z1l&#39;:
                    self._first_year_observed_values_of_variables_adjusted_by_intertemporal_constants[i, 0] = self.first_projection_year_z1r[[sequence]]  # t = base year
            i += 1

    def __compute_first_projection_year_ssf_deviations_from_observed_values(self):
        &#34;&#34;&#34;
        ### Overview

        Step 1.
        Compute the state-space-form values for the LHS vectors  in  thefirst projection year 
        using the values from the database for the RHS vectors in the state space form.

        and 

        Step 2.
        Calculate the differences between the database values for the RHS vectors
        `x1r`, `j1r`, `zer`, and `z1r` and the values computed in Step 1. Store these
        as properties of the class instance. They become constant adjustments that are
        used in the projection process to ensure that the database values in 
        the first projection year match the baseline projections of those values.

        The differences are preserved as the database values minus projections.
        &#34;&#34;&#34;

        # Step 1.
        self.x1l_ssf_calculations_using_first_projection_year_data = self.state_space_form.delta(&#39;x1l&#39;, &#39;yxr&#39;) @ self.first_projection_year_yxr + \
            self.state_space_form.delta(&#39;x1l&#39;, &#39;yjr&#39;) @ self.first_projection_year_yjr + \
            self.state_space_form.delta(&#39;x1l&#39;, &#39;exz&#39;) @ self.first_projection_year_exz + \
            self.state_space_form.delta(&#39;x1l&#39;, &#39;exo&#39;) @ self.first_projection_year_exo

        self.j1l_ssf_calculations_using_first_projection_year_data = self.state_space_form.delta(&#39;j1l&#39;, &#39;yxr&#39;) @ self.first_projection_year_yxr + \
            self.state_space_form.delta(&#39;j1l&#39;, &#39;yjr&#39;) @ self.first_projection_year_yjr + \
            self.state_space_form.delta(&#39;j1l&#39;, &#39;exz&#39;) @ self.first_projection_year_exz + \
            self.state_space_form.delta(&#39;j1l&#39;, &#39;exo&#39;) @ self.first_projection_year_exo

        self.zel_ssf_calculations_using_first_projection_year_data = self.state_space_form.delta(&#39;zel&#39;, &#39;yxr&#39;) @ self.first_projection_year_yxr + \
            self.state_space_form.delta(&#39;zel&#39;, &#39;yjr&#39;) @ self.first_projection_year_yjr + \
            self.state_space_form.delta(&#39;zel&#39;, &#39;exz&#39;) @ self.first_projection_year_exz + \
            self.state_space_form.delta(&#39;zel&#39;, &#39;exo&#39;) @ self.first_projection_year_exo

        self.z1l_ssf_calculations_using_first_projection_year_data = self.state_space_form.delta(&#39;z1l&#39;, &#39;yxr&#39;) @ self.first_projection_year_yxr + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;yjr&#39;) @ self.first_projection_year_yjr + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;exz&#39;) @ self.first_projection_year_exz + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;exo&#39;) @ self.first_projection_year_exo

        # Step 2.
        self._x1r_difference_from_ssf = self.first_projection_year_x1r - self.x1l_ssf_calculations_using_first_projection_year_data  # t+1 = year after base year
        self._j1r_difference_from_ssf = self.first_projection_year_j1r - self.j1l_ssf_calculations_using_first_projection_year_data  # t+1 = year after base year
        self._zer_difference_from_ssf = self.first_projection_year_zer - self.zel_ssf_calculations_using_first_projection_year_data  # t = base year
        self._z1r_difference_from_ssf = self.first_projection_year_z1r - self.z1l_ssf_calculations_using_first_projection_year_data  # t = base year

    @property
    def first_projection_year_x1r(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The `x1r` vector populated with database values
        from the year after the first projection year.

        These values are not adjusted by any constants and are never
        altered after they are set.
        &#34;&#34;&#34;
        return self._first_projection_year_x1r

    @property
    def first_projection_year_j1r(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The `j1r` vector populated with database values
        from the year after the first projection year.
        
        These values are not adjusted by any constants and are never
        altered after they are set.
        &#34;&#34;&#34;
        return self._first_projection_year_j1r

    @property
    def first_projection_year_zer(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The `zer` vector populated with database values
        from the first projection year.
        
        These values are not adjusted by any constants and are never
        altered after they are set.
        &#34;&#34;&#34;
        return self._first_projection_year_zer

    @property
    def first_projection_year_z1r(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The `z1r` vector populated with database values
        from the first projection year.
        
        These values are not adjusted by any constants and are never
        altered after they are set.
        &#34;&#34;&#34;
        return self._first_projection_year_z1r

    @property
    def first_projection_year_yxr(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The `yxr` vector populated with database values
        from the first projection year.
        
        These values are not adjusted by any constants and are never
        altered after they are set.
        &#34;&#34;&#34;
        return self._first_projection_year_yxr

    @property
    def first_projection_year_yjr(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The `yjr` vector populated with database values
        from the first projection year.

        These values are not adjusted by any constants and are never
        altered after they are set.
        &#34;&#34;&#34;
        return self._first_projection_year_yjr

    @property
    def first_projection_year_exz(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The `exz` vector populated with database values
        from the year after the first projection year.

        These values are not adjusted by any constants and are never
        altered after they are set.
        &#34;&#34;&#34;
        return self._first_projection_year_exz

    @property
    def first_projection_year_exo(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The `exo` vector populated with database values
        from the first projection year.

        These values are not adjusted by any constants and are never
        altered after they are set.
        &#34;&#34;&#34;
        return self._first_projection_year_exo

    @property
    def x1r_difference_from_ssf(self):
        &#34;&#34;&#34;
        The difference between the database values of `x1r`
        and the raw baseline projections of those values,
        without making any constant adjustments at all.

        These differences are added to the constants that
        are used in the baseline projections to ensure that
        the projections in the first projection year match
        the database values in that year.
        &#34;&#34;&#34;
        return self._x1r_difference_from_ssf

    @property
    def j1r_difference_from_ssf(self):
        &#34;&#34;&#34;
        The difference between the database values of `j1r`
        and the raw baseline projections of those values,
        without making any constant adjustments at all.

        These differences are added to the constants that
        are used in the baseline projections to ensure that
        the projections in the first projection year match
        the database values in that year.

        &#34;&#34;&#34;
        return self._j1r_difference_from_ssf

    @property
    def zer_difference_from_ssf(self):
        &#34;&#34;&#34;
        The difference between the database values of `zer`
        and the raw baseline projections of those values,
        without making any constant adjustments at all.

        These differences are added to the constants that
        are used in the baseline projections to ensure that
        the projections in the first projection year match
        the database values in that year.
        &#34;&#34;&#34;
        return self._zer_difference_from_ssf

    @property
    def z1r_difference_from_ssf(self):
        &#34;&#34;&#34;
        The difference between the database values of `z1r`
        and the raw baseline projections of those values,
        without making any constant adjustments at all.

        These differences are added to the constants that
        are used in the baseline projections to ensure that
        the projections in the first projection year match
        the database values in that year.
        &#34;&#34;&#34;
        return self._z1r_difference_from_ssf

    @property
    def reference_h3t_used_to_compute_intertemporal_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Equivalent to h3t in the Ox implementation
        Functions of current and future exogenous variables affecting J1.
        This is the reference version of h3t, computed to calculation the projections
        for the base year that will be used as a reference projection when determining 
        the numeric derivatives for calculation of the intertemporal constants.

        Its only role is to preserve the appropriate information for benchmarking against Ox.
        &#34;&#34;&#34;
        return self._reference_h3t_used_to_compute_intertemporal_constants

    @property
    def reference_c4t_used_to_compute_intertemporal_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Equivalent to c4t in the Ox implementation
        Functions of current and future exogenous variables affecting ZE.
        This is the reference version of h3t, computed to calculation the projections
        for the base year that will be used as a reference projection when determining 
        the numeric derivatives for calculation of the intertemporal constants.

        Its only role is to preserve the appropriate information for benchmarking against Ox.
        &#34;&#34;&#34;
        return self._reference_c4t_used_to_compute_intertemporal_constants

    @property
    def x1_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to X1 to ensure projections equal observed values.
        Add any intertemporal constant values to the X1R difference to SSF equation 
        results with zero constants to get the combined set of constants.
        &#34;&#34;&#34;

        if hasattr(self, &#34;_x1_constants&#34;):
            return self._x1_constants

        result: np.ndarray = self.x1r_difference_from_ssf.copy()
        if not hasattr(self, &#34;intertemporal_constants&#34;):
            return result

        i = 0
        for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
            if variable_details[&#39;var_type&#39;] == &#39;x1l&#39;:
                result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
            i = i + 1

        self._x1_constants: np.ndarray = result
        return self._x1_constants

    @property
    def j1_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to J1 to ensure projections equal observed values.
        Add any intertemporal constant values to the X1R difference to SSF equation results with zero constants
        to get the combined set of constants.
        &#34;&#34;&#34;

        if hasattr(self, &#34;_j1_constants&#34;):
            return self._j1_constants

        result: np.ndarray = self.j1r_difference_from_ssf.copy()
        if not hasattr(self, &#34;intertemporal_constants&#34;):
            return result
        i = 0
        for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
            if variable_details[&#39;var_type&#39;] == &#39;j1l&#39;:
                result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
            i = i + 1

        self._j1_constants: np.ndarray = result
        return self._j1_constants

    @property
    def ze_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to ZE to ensure projections equal observed values.
        Add any intertemporal constant values to the X1R difference to SSF equation results with zero constants
        to get the combined set of constants.
        &#34;&#34;&#34;

        if hasattr(self, &#34;_ze_constants&#34;):
            return self._ze_constants

        result: np.ndarray = self.zer_difference_from_ssf.copy()
        if not hasattr(self, &#34;intertemporal_constants&#34;):
            return result

        i = 0
        for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
            if variable_details[&#39;var_type&#39;] == &#39;zel&#39;:
                logging.debug(
                    f&#34;At index {i} intertemporal constant is {self.intertemporal_constants.loc[variable_details[&#39;name&#39;],&#39;constant_value&#39;]} : shape is {self.intertemporal_constants.shape}&#34;)
                result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
            i = i + 1

        self._ze_constants: np.ndarray = result
        return self._ze_constants

    @property
    def z1_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to Z1 to ensure projections equal observed values.
        Add any intertemporal constant values to the X1R difference to SSF equation results with zero constants
        to get the combined set of constants.
        &#34;&#34;&#34;

        if hasattr(self, &#34;_z1_constants&#34;):
            return self._z1_constants

        result: np.ndarray = self.z1r_difference_from_ssf.copy()
        if not hasattr(self, &#34;intertemporal_constants&#34;):
            return result
        i = 0
        for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
            if variable_details[&#39;var_type&#39;] == &#39;z1l&#39;:
                result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
            i = i + 1

        self._z1_constants: np.ndarray = result
        return self._z1_constants

    def __create_exogenous_variable_projections(self):
        &#34;&#34;&#34;
        Populates the exogenous variable values through the projection years. 
        These values are determined outside of the model.

        When setting up baseline projections for exogenous variables, start by
        using the first projection year values for all of those variables and applying 
        them in all years through to the last projection year.
        
        Then adjust the database exogenous variable projections for:

        * effective labour productivity projections (based on population and productivity
        growth rates in each region)
        * energy efficiency improvement projections (based on projections of 
        autonomous energy efficiency improvements)
        &#34;&#34;&#34;

        # Replicate projection base year values across all projection periods for all exogenous variables.
        projections: pd.DataFrame = pd.DataFrame(np.tile(self.first_projection_year_exo, (1, self.configuration.projection_years_count)))
        projections.columns = self.projection_years_column_labels
        projections.reset_index()

        # Add effective labour productivity and energy usage efficiency.
        effective_labour_productivity: EffectiveLabourProductivity = self.model.effective_labour_productivity
        rogy: pd.DataFrame = effective_labour_productivity.rogy
        energy_usage_efficiency: EnergyUsageEfficiency = self.model.energy_usage_efficiency
        for region in self.sym_data.regions_members:

            regional_effective_labour_productivity: pd.DataFrame = effective_labour_productivity.effective_productivity_deviations(region=region)
            regional_energy_usage_efficiency: pd.DataFrame = energy_usage_efficiency.sector_cumulative_energy_usage_efficiency_gains(region=region)
            consumption_energy_usage_efficiency: pd.DataFrame = energy_usage_efficiency.consumption_cumulative_energy_usage_efficiency_gains

            variable_prefix_ROGY: str = f&#34;ROGY&#34;
            rogy_name: str = f&#34;{variable_prefix_ROGY}({region})&#34;
            if self.sym_data.has_variables(variable_name_prefix=rogy_name):
                rogy_index: int = self.sym_data.variable_index(vector_name=&#39;exo&#39;, variable_name=rogy_name)
                rogy_units = self.sym_data.units_for_variables_with_given_name_prefix(vector_name=&#39;exo&#39;, variable_name_prefix=variable_prefix_ROGY)
                rogy_data: pd.DataFrame = rogy.loc[[region], self.projection_years_column_labels]
                if &#39;gdp&#39; in rogy_units:
                    raise Exception(f&#34;{rogy_name} has gdp units so shocks to that variable are not supported.&#34;)

                projections.loc[[rogy_index], :] = projections.loc[[rogy_index], :] + (rogy_data.to_numpy().flatten() / 100)
            # else:
            #     logging.warning(f&#34;{rogy_name} is not in the SYM model.&#34;)

            shefc_name_prefix: str = f&#34;SHEFC&#34;
            shefc_name: str = f&#34;{shefc_name_prefix}({region})&#34;
            if self.sym_data.has_variables(variable_name_prefix=shefc_name_prefix):
                shefc_index: int = self.sym_data.variable_index(vector_name=&#39;exo&#39;, variable_name=shefc_name)
                shefc_units = self.sym_data.units_for_variables_with_given_name_prefix(vector_name=&#39;exo&#39;, variable_name_prefix=shefc_name_prefix)
                shefc_data: pd.DataFrame = consumption_energy_usage_efficiency.loc[[region], self.projection_years_column_labels]
                if &#39;gdp&#39; in shefc_units:
                    raise Exception(f&#34;{shefc_name} has gdp units so shocks to that variable are not supported.&#34;)
                projections.loc[[shefc_index], :] = projections.loc[[shefc_index], :] + (shefc_data.to_numpy().flatten() / 100)
            # else:
            #     logging.warning(f&#34;{shefc_name} is not in the SYM model.&#34;)

            variable_prefix_SHL: str = &#39;SHL&#39;
            variable_prefix_SHEF: str = &#39;SHEF&#39;
            for sector in self.sym_data.sectors_members:

                shl_name: str = f&#34;{variable_prefix_SHL}({region},{sector})&#34;
                if self.sym_data.has_variables(variable_name_prefix=shl_name):
                    shl_index: int = self.sym_data.variable_index(vector_name=&#39;exo&#39;, variable_name=shl_name)
                    shl_units = self.sym_data.units_for_variables_with_given_name_prefix(vector_name=&#39;exo&#39;, variable_name_prefix=variable_prefix_SHL)
                    shl_data: pd.DataFrame = regional_effective_labour_productivity.loc[[sector], self.projection_years_column_labels]
                    if &#39;gdp&#39; in shl_units:
                        raise Exception(f&#34;{shl_name} has gdp units so shocks to that variable are not supported.&#34;)
                    projections.loc[[shl_index], :] = projections.loc[[
                        shl_index], :] + (shl_data.to_numpy().flatten() / 100)
                # else:
                #     logging.warning(f&#34;{shl_name} is not in the SYM model.&#34;)

                shef_name: str = f&#34;{variable_prefix_SHEF}({sector},{region})&#34;
                if self.sym_data.has_variables(variable_name_prefix=shef_name):
                    shef_index: int = self.sym_data.variable_index(vector_name=&#39;exo&#39;, variable_name=shef_name)
                    shef_units = self.sym_data.units_for_variables_with_given_name_prefix(vector_name=&#39;exo&#39;, variable_name_prefix=variable_prefix_SHEF)
                    shef_data: pd.DataFrame = regional_energy_usage_efficiency.loc[[sector], self.projection_years_column_labels]
                    if &#39;gdp&#39; in shef_units:
                        raise Exception(f&#34;{shef_name} has gdp units so shocks to that variable are not supported.&#34;)
                    projections.loc[[shef_index], :] = projections.loc[[shef_index], :] + (shef_data.to_numpy().flatten() / 100)
                # else:
                #     logging.warning(f&#34;{shef_shock_name} is not in the SYM model.&#34;)

        # Index with variable names.
        projections.index = self.sym_data.vector_variable_names(vector_name=&#39;exo&#39;)

        # Store the exogenous projections that will be augmented for other projections.
        self._exo_projections: pd.DataFrame = projections

    def __evaluate_first_projection_year_vector_projections(self):
        &#34;&#34;&#34;
        Computes the values of the model equation vectors in the first projection year, 
        using the functions of future exogenous variables, the stable manifold, etc
        &#34;&#34;&#34;

        self._exo_first_year_projections = self.exo_projections.loc[:, [str(self.first_projection_year)]].to_numpy()

        self._yxr_first_year_projections = self.yxr_initial_values.to_numpy().copy()

        # er = h1t*x[][1] + h2t*exog[][1] + h3t[][1];
        self._yjr_first_year_projections = \
            self.stable_manifold.H1 @ self.yxr_first_year_projections + \
            self.stable_manifold.H2 @ self.exo_first_year_projections + \
            self._h3t[:, [0]]

        # tzl = mu1t*x[][1] + mu4t*exog[][1] + c4t[][1];
        self._exz_first_year_projections = \
            self.stable_manifold.mu1 @ self.yxr_first_year_projections + \
            self.stable_manifold.mu2 @ self.exo_first_year_projections + \
            self._c4t[:, [0]]

        # z1l projections = d5n*x[][1]+d7n*exog[][1]+d6n*er+d4n*tzl+cz6[][1]
        self._z1l_first_year_projections = \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;yxr&#39;) @ self.yxr_first_year_projections + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;exo&#39;) @ self.exo_first_year_projections + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;yjr&#39;) @ self.yjr_first_year_projections + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;exz&#39;) @ self.exz_first_year_projections + \
            self.z1r_difference_from_ssf

    @property
    def yxr_first_year_projections(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Projections of X1_t (yxr) in the first projection year
        &#34;&#34;&#34;
        return self._yxr_first_year_projections

    @property
    def yjr_first_year_projections(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Projections of J1_t (yjr) in the first projection year
        &#34;&#34;&#34;
        return self._yjr_first_year_projections

    @property
    def exz_first_year_projections(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Projections of ZE_t (exz) in the first projection year
        &#34;&#34;&#34;
        return self._exz_first_year_projections

    @property
    def z1l_first_year_projections(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Projections of Z1_t (z1l=z1r) in the first projection year
        &#34;&#34;&#34;
        return self._z1l_first_year_projections

    @property
    def exo_first_year_projections(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Projections of EXO_t in the first projection year
        &#34;&#34;&#34;
        return self._exo_first_year_projections

    @property
    def first_year_original_projections_of_variables_adjusted_by_intertemporal_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The first year projected values for the variables that are being
        adjusted by the intertemporal constants.

        The values are those for the projection that is not adjusted by intertemporal constants.

        It is used in the calculation of the intertemporal constants but it is only preserved
        as a property to facilitate benchmarking against Ox.
        &#34;&#34;&#34;
        return self._first_year_original_projections_of_variables_adjusted_by_intertemporal_constants

    @property
    def first_year_original_projections_of_yxr(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The first year projected values for the state variables.
        
        This is only required for benchmarking against Ox.
        &#34;&#34;&#34;
        return self._first_year_original_projections_of_yxr

    @property
    def first_year_original_projections_of_yjr(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The first year projected values for the costate variables.

        This is only required for benchmarking against Ox.
        &#34;&#34;&#34;
        return self._first_year_original_projections_of_yjr

    @property
    def first_year_original_projections_of_exz(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The first year projected values for the expected endogenous variables exz.

        This is only required for benchmarking against Ox.
        &#34;&#34;&#34;
        return self._first_year_original_projections_of_exz

    @property
    def first_year_original_projections_of_z1l(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The first year projected values for the endogenous variables.

        This is only required for benchmarking against Ox.
        &#34;&#34;&#34;
        return self._first_year_original_projections_of_z1l

    @property
    def first_year_observed_values_of_variables_adjusted_by_intertemporal_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Returns the observed values, in the first projection year, of the 
        variables that are adjusted by intertemporal constants.

        The values are not adjusted after they are initially set so they
        can be relied up and reused by the constant calculation process in this
        baseline projections and in any later relinearisation projections.
        &#34;&#34;&#34;
        return self._first_year_observed_values_of_variables_adjusted_by_intertemporal_constants

    @property
    def intertemporal_constants(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        The data frame of intertemporal constants information
        obtained from SYM but augmented with the values of the
        intertemporal constants.

        The dataframe is indexed by the variable names.

        The constant values are stored in a column called `constant_value`.
        &#34;&#34;&#34;
        return self._intertemporal_constants

    @property
    def partial_derivatives_wrt_intertemporal_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The matrix of partial derivatives used in Newton&#39;s method to
        compute the intertemporal constants.

        This is a property of the class just to support benchmarking against Ox.
        &#34;&#34;&#34;
        return self._partial_derivatives

    def __calculate_intertemporal_constants(self):
        &#34;&#34;&#34;
        ### Overview

        Computes the intertemporal constant adjustments to jump and other variables to align starting data
        values with model projections in the first year.

        Step 1.
        Compute functions of future exogenous variables through all years of the projection.

        Step 2.
        For the variables that are to be adjusted by the intertemporal
        constants, compute their projected values in the base projection year
        and store these values for comparison to perturbed base year projections so we can calculate
        the derivatives matrix needed to set the intertemporal constants.
        Also store the values of each of the 4 vectors in the model in the base year for benchmarking.

        Step 3.
        Initialise the partial derivatives matrix. This is the matrix of derivatives of each of the
        variables that is adjusted by intertemporal constants, with respect to each of the intertemporal
        constants, in the SSF equations (each of which is linear).

        Iterate over the intertemporal constants, perturbing each and recalculating the base year projections
        of the variables that are adjusted by intertemporal constants so that we can 
        estimate the relevant numeric derivatives.

        At the end of this step, update the perturbed variable details to `None` so that
        all constants associated with the difference between observed values and SSF calculated values
        are at their unpurturbed values when doing actual baseline projections.

        Step 4.
        Apply Newton&#39;s method to solve for the intertemporal constants.
        Multiply the difference between the observed values of the variables that are adjusted by
        the intertemporal constants and their original projected values, in the first projection year,
        by the inverse of the partial derivatives matrix.

        This only needs to be done once because the SSF of the model is linear so Newton&#39;s method
        gets to the solution in one iteration.
        &#34;&#34;&#34;

        # Step 1.
        self._compute_functions_of_future_exogenous_variables(exogenous_projections=self.exo_projections)
        self._reference_c4t_used_to_compute_intertemporal_constants = self.c4t.copy()
        self._reference_h3t_used_to_compute_intertemporal_constants = self.h3t.copy()

        # Step 2.
        
        # Compute the first year projections - noting that no intertemporal 
        # constant adjustments have been made yet.
        self.__evaluate_first_projection_year_vector_projections()

        # Capture the first year projections of the intertemporal variables. 
        # These are used in this function for Newton&#39;s method below
        # and they are also deep-copied and stored as a property of the 
        # class for benchmarking purposes.
        self._first_year_original_projections_of_variables_adjusted_by_intertemporal_constants = self.first_year_projections_of_variables_adjusted_by_intertemporal_constants.copy()

        # For benchmarking purposes only, preserve the original first year projections
        self._first_year_original_projections_of_yxr = self.yxr_first_year_projections.copy()
        self._first_year_original_projections_of_yjr = self.yjr_first_year_projections.copy()
        self._first_year_original_projections_of_exz = self.exz_first_year_projections.copy()
        self._first_year_original_projections_of_z1l = self.z1l_first_year_projections.copy()

        # Step 3.
        # Compute the partial derivatives matrix
        self._partial_derivatives = np.zeros(shape=(len(self.sym_data.intertemporal_constant_variables), len(
            self.sym_data.variables_adjusted_by_intertemporal_constants)))
        i = 0
        for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
            self.__update_perturbed_variable(variable_details=variable_details)
            self._compute_functions_of_future_exogenous_variables(exogenous_projections=self.exo_projections)
            self.__evaluate_first_projection_year_vector_projections()
            self._partial_derivatives[:, [i]] = (
                self.first_year_projections_of_variables_adjusted_by_intertemporal_constants -
                self._first_year_original_projections_of_variables_adjusted_by_intertemporal_constants) / Constants().DELTA
            i += 1

        # Generate the baseline projection to use in computing partial derivatives
        # and to generate matrix values that are used later in projection processes.
        self.__update_perturbed_variable(variable_details=None)

        # Step 4.
        # Use Newtons method adjustment to compute intertemporal constant values
        self._intertemporal_constants = self.sym_data.intertemporal_constant_variables
        values: np.ndarray = np.linalg.inv(self._partial_derivatives) @ \
            (self.first_year_observed_values_of_variables_adjusted_by_intertemporal_constants -
             self.first_year_original_projections_of_variables_adjusted_by_intertemporal_constants)
        values = values.reshape((len(self.intertemporal_constants.index), 1))
        self._intertemporal_constants[&#39;constant_value&#39;] = values

        logging.info(&#34;The intertemporal constants have been calibrated.&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gcubed.projections.baseline_projections.BaselineProjections"><code class="flex name class">
<span>class <span class="ident">BaselineProjections</span></span>
<span>(</span><span>stable_manifold:<a title="gcubed.linearisation.stable_manifold.StableManifold" href="../linearisation/stable_manifold.html#gcubed.linearisation.stable_manifold.StableManifold">StableManifold</a>, start_from_neutral_real_interest_rate:bool=None)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="overview">Overview</h3>
<p>Compute the baseline model projections over the projection horizon
from the first projection year (a year with available data to be
matched by the projections) through to the last projection year.</p>
<h3 id="arguments">Arguments</h3>
<p><code>stable_manifold</code>: The stable manifold that provides access to all
of the model information required to produce projections.</p>
<p><code>start_from_neutral_real_interest_rate</code>: <code>True</code> if the baseline projections start from
the neutral real interest rate and <code>False</code> if they start from the observed real interest rates.
This parameter defaults to a value of <code>None</code> which means that the baseline projections start
from the neutral real interest rate if the linear model used for the
projections was done at the neutral real interest rate.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaselineProjections(Projections):
    &#34;&#34;&#34;
    ### Overview

    Compute the baseline model projections over the projection horizon 
    from the first projection year (a year with available data to be 
    matched by the projections) through to the last projection year.

    &#34;&#34;&#34;

    def __init__(self, stable_manifold: StableManifold, start_from_neutral_real_interest_rate: bool = None) -&gt; None:
        &#34;&#34;&#34;
       ### Arguments

        `stable_manifold`: The stable manifold that provides access to all 
        of the model information required to produce projections.

        `start_from_neutral_real_interest_rate`: `True` if the baseline projections start from 
        the neutral real interest rate and `False` if they start from the observed real interest rates.
        This parameter defaults to a value of `None` which means that the baseline projections start
        from the neutral real interest rate if the linear model used for the
        projections was done at the neutral real interest rate.
        &#34;&#34;&#34;
        logging.info(&#34;Setting up the baseline projections.&#34;)

        super().__init__(stable_manifold=stable_manifold)
        self._is_baseline_projections = True

        # Determine whether the baseline projections start the projections from the neutral 
        # real interest rate or from the observed real interest rates.
        if start_from_neutral_real_interest_rate is None:
            self._start_from_neutral_real_interest_rate = self.stable_manifold.ssf.linear_model.use_neutral_real_interest_rate
        else:
            self._start_from_neutral_real_interest_rate = start_from_neutral_real_interest_rate
        
        self._database = GDPScaledDatabase(database=self.model.database, base_year=self.configuration.base_year)

        self.__set_first_projection_year_observed_values()

        self.__store_observed_yxr_values_in_first_projection_year()

        # Set up the exogenous variable projections
        self.__create_exogenous_variable_projections()

        self.__store_observed_values_of_variables_adjusted_by_intertemporal_constants_in_first_projection_year()
        self.__compute_first_projection_year_ssf_deviations_from_observed_values()

        # Set up the intertemporal constant variables
        self.__calculate_intertemporal_constants()

        # Generate the baseline projections
        self._generate_projections()

        # Generate the database projections
        self._generate_database_projections()

        # Generate publishable version of the projections
        self._generate_publishable_projections()

        self.__validate()


    def __validate(self):
        &#34;&#34;&#34;
        TODO:  Validate the projections: 
        1. check that they are available for the expected projection years.
        2. Check that the base year projections are equal to the base year data values.
        &#34;&#34;&#34;
        logging.info(&#34;The baseline projections have been generated.&#34;)

    @property
    def baseline_projections(self) -&gt; Optional[&#39;BaselineProjections&#39;]:
        return self

    @property
    def database(self) -&gt; GDPScaledDatabase:
        &#34;&#34;&#34;
        The database used as the starting point for the projections.
        &#34;&#34;&#34;
        return self._database

    @property
    def start_from_neutral_real_interest_rate(self) -&gt; bool:
        &#34;&#34;&#34;
        `True` if interest rates are set to the neutral real interest
        rate for the start of the baseline projections and `False` otherwise.
        &#34;&#34;&#34;
        return self._start_from_neutral_real_interest_rate

    def __update_perturbed_variable(self, variable_details: pd.Series):
        &#34;&#34;&#34;
        ### Overview

        For each variable that has an intertemporal constant, we need to compute
        numerical approximations to the partial derivatives of the model with respect
        to that constant. Those  partial derivatives are approximated by evaluating the 
        relevant equations in the model using the data in the first projection year and then 
        again evaluating those equations after perturbing the variable of interest by
        `Constants.DELTA`. The difference between the two evaluations is used
        to compute the partial derivatives for that constant.

        This function does the work of perturbing the intertemporal constant 
        associated with the variable, preparing for calculation of the partial 
        derivatives for that constant.

        The adjustment to the constant (the perturbation) is made by adjusting the
        constants associated with variables&#39; observed differences from their state 
        space form equation evaluations in the baseline&#39;s first projection year.

        The original value of that constant is tracked using the private property, 
        `_original_value`, so that it can be restored after the partial derivatives
        have been computed.

        This function is called once for each variable in the SYM table of intertemporal 
        constant variables, as part of computing the intertemporal constants.

        &#34;&#34;&#34;

        if hasattr(self, &#39;_perturbed_variable_details&#39;):
            sequence = self._perturbed_variable_details[&#39;sequence&#39;]
            match self._perturbed_variable_details[&#39;var_type&#39;]:
                case &#39;x1l&#39;:
                    self.x1r_difference_from_ssf[sequence] = self._original_value
                case &#39;j1l&#39;:
                    self.j1r_difference_from_ssf[sequence] = self._original_value
                case &#39;zel&#39;:
                    self.zer_difference_from_ssf[sequence] = self._original_value
                case &#39;z1l&#39;:
                    self.z1r_difference_from_ssf[sequence] = self._original_value
            delattr(self, &#39;_original_value&#39;)

        if variable_details is None:
            delattr(self, &#39;_perturbed_variable_details&#39;)
        else:
            sequence = variable_details[&#39;sequence&#39;]
            match variable_details[&#39;var_type&#39;]:
                case &#39;x1l&#39;:
                    self._original_value = float(self.x1r_difference_from_ssf[sequence])
                    self.x1r_difference_from_ssf[sequence] = self._original_value + Constants().DELTA
                case &#39;j1l&#39;:
                    self._original_value = float(self.j1r_difference_from_ssf[sequence])
                    self.j1r_difference_from_ssf[sequence] = self._original_value + Constants().DELTA
                case &#39;zel&#39;:
                    self._original_value = float(self.zer_difference_from_ssf[sequence])
                    self.zer_difference_from_ssf[sequence] = self._original_value + Constants().DELTA
                case &#39;z1l&#39;:
                    self._original_value = float(self.z1r_difference_from_ssf[sequence])
                    self.z1r_difference_from_ssf[sequence] = self._original_value + Constants().DELTA
            self._perturbed_variable_details = variable_details

    @property
    def perturbed_variable_details(self) -&gt; pd.Series:
        &#34;&#34;&#34;
        If computing intertemporal constants, 
        the var_map details (the row of the SYM var_map dataframe)
        for the variable being perturbed as part of computing
        derivatives needed to set intertemporal constants. Otherwise, this returns
        `None` if just producing the baseline projections.
        &#34;&#34;&#34;
        if hasattr(self, &#39;_perturbed_variable_details&#39;):
            return self._perturbed_variable_details
        return None

    @property
    def first_year_projections_of_variables_adjusted_by_intertemporal_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        An column vector of first year projection values for those variables that are adjusted
        by intertemporal constants.

        The vector is populated from the vectors of first year projections for 
        each of `x1l`, `j1l`, `zel`,  and `z1l`.
        &#34;&#34;&#34;
        result = np.zeros(shape=(len(self.sym_data.variables_adjusted_by_intertemporal_constants), 1))
        i = 0
        for index, adjusted_variable_details in self.sym_data.variables_adjusted_by_intertemporal_constants.iterrows():
            sequence = adjusted_variable_details[&#39;sequence&#39;]
            match adjusted_variable_details[&#39;var_type&#39;]:
                case &#39;x1l&#39;:
                    result[i, 0] = self.yxr_first_year_projections[[sequence]]
                case &#39;j1l&#39;:
                    result[i, 0] = self.yjr_first_year_projections[[sequence]]
                case &#39;zel&#39;:
                    result[i, 0] = self.exz_first_year_projections[[sequence]]
                case &#39;z1l&#39;:
                    result[i, 0] = self.z1l_first_year_projections[[sequence]]
            i += 1
        return result

    def __set_first_projection_year_observed_values(self):
        &#34;&#34;&#34;
        ### Overview

        Populates the model vectors using the database values associated with 
        the first projection year. 
        
        Note that some variables are populated iwth
        data from adjacent years. Review the `Database.rhs_vector_value` method
        for details. 
        
        Note also that there is the option to override real and 
        nominal interest rates with values associated with inflation neutrality.
        &#34;&#34;&#34;
        # RHS (identical to LHS) vector values to be compared to SSF calculated values
        self._first_projection_year_x1r: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;x1r&#39;, year=self.first_projection_year, use_neutral_real_interest_rate=self.start_from_neutral_real_interest_rate)  # t+1
        self._first_projection_year_j1r: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;j1r&#39;, year=self.first_projection_year, use_neutral_real_interest_rate=self.start_from_neutral_real_interest_rate)  # t+1
        self._first_projection_year_zer: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;zer&#39;, year=self.first_projection_year, use_neutral_real_interest_rate=self.start_from_neutral_real_interest_rate)  # t
        self._first_projection_year_z1r: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;z1r&#39;, year=self.first_projection_year, use_neutral_real_interest_rate=self.start_from_neutral_real_interest_rate)  # t

        # SSF RHS vector values
        self._first_projection_year_yxr: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;yxr&#39;, year=self.first_projection_year, use_neutral_real_interest_rate=self.start_from_neutral_real_interest_rate)  # t
        self._first_projection_year_yjr: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;yjr&#39;, year=self.first_projection_year, use_neutral_real_interest_rate=self.start_from_neutral_real_interest_rate)  # t
        self._first_projection_year_exz: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;exz&#39;, year=self.first_projection_year, use_neutral_real_interest_rate=self.start_from_neutral_real_interest_rate)  # t+1
        self._first_projection_year_exo: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;exo&#39;, year=self.first_projection_year, use_neutral_real_interest_rate=self.start_from_neutral_real_interest_rate)  # t

    def __store_observed_yxr_values_in_first_projection_year(self):
        &#34;&#34;&#34;
        ### Overview

        Save the values of the state vector (X1) in the first projection year to use in
        initiating the projection process.
        &#34;&#34;&#34;
        yxr_initial_values = pd.DataFrame(self.first_projection_year_yxr.copy())
        yxr_initial_values.index = self.sym_data.vector_variable_names(vector_name=&#39;yxr&#39;)
        yxr_initial_values.columns = [str(self.first_projection_year)]
        self._yxr_initial_values: pd.DataFrame = yxr_initial_values

    def __store_observed_values_of_variables_adjusted_by_intertemporal_constants_in_first_projection_year(self):
        &#34;&#34;&#34;
        ### Overview

        Save the database values of the variables
        that are adjusted by intertemporal constants so that we can use
        those as the values we adjust the variables to using the intertemporal
        constants.
        &#34;&#34;&#34;
        self._first_year_observed_values_of_variables_adjusted_by_intertemporal_constants: np.ndarray = \
            np.zeros(shape=(len(self.sym_data.variables_adjusted_by_intertemporal_constants), 1))
        i = 0
        for index, adjusted_variable_details in self.sym_data.variables_adjusted_by_intertemporal_constants.iterrows():
            sequence = adjusted_variable_details[&#39;sequence&#39;]
            match adjusted_variable_details[&#39;var_type&#39;]:
                case &#39;x1l&#39;:
                    self._first_year_observed_values_of_variables_adjusted_by_intertemporal_constants[i, 0] = self.first_projection_year_yxr[[sequence]]  # t = base year
                case &#39;j1l&#39;:
                    self._first_year_observed_values_of_variables_adjusted_by_intertemporal_constants[i, 0] = self.first_projection_year_yjr[[sequence]]  # t = base year
                case &#39;zel&#39;:
                    self._first_year_observed_values_of_variables_adjusted_by_intertemporal_constants[i, 0] = self.first_projection_year_exz[[sequence]]  # t+1 = year after base year
                case &#39;z1l&#39;:
                    self._first_year_observed_values_of_variables_adjusted_by_intertemporal_constants[i, 0] = self.first_projection_year_z1r[[sequence]]  # t = base year
            i += 1

    def __compute_first_projection_year_ssf_deviations_from_observed_values(self):
        &#34;&#34;&#34;
        ### Overview

        Step 1.
        Compute the state-space-form values for the LHS vectors  in  thefirst projection year 
        using the values from the database for the RHS vectors in the state space form.

        and 

        Step 2.
        Calculate the differences between the database values for the RHS vectors
        `x1r`, `j1r`, `zer`, and `z1r` and the values computed in Step 1. Store these
        as properties of the class instance. They become constant adjustments that are
        used in the projection process to ensure that the database values in 
        the first projection year match the baseline projections of those values.

        The differences are preserved as the database values minus projections.
        &#34;&#34;&#34;

        # Step 1.
        self.x1l_ssf_calculations_using_first_projection_year_data = self.state_space_form.delta(&#39;x1l&#39;, &#39;yxr&#39;) @ self.first_projection_year_yxr + \
            self.state_space_form.delta(&#39;x1l&#39;, &#39;yjr&#39;) @ self.first_projection_year_yjr + \
            self.state_space_form.delta(&#39;x1l&#39;, &#39;exz&#39;) @ self.first_projection_year_exz + \
            self.state_space_form.delta(&#39;x1l&#39;, &#39;exo&#39;) @ self.first_projection_year_exo

        self.j1l_ssf_calculations_using_first_projection_year_data = self.state_space_form.delta(&#39;j1l&#39;, &#39;yxr&#39;) @ self.first_projection_year_yxr + \
            self.state_space_form.delta(&#39;j1l&#39;, &#39;yjr&#39;) @ self.first_projection_year_yjr + \
            self.state_space_form.delta(&#39;j1l&#39;, &#39;exz&#39;) @ self.first_projection_year_exz + \
            self.state_space_form.delta(&#39;j1l&#39;, &#39;exo&#39;) @ self.first_projection_year_exo

        self.zel_ssf_calculations_using_first_projection_year_data = self.state_space_form.delta(&#39;zel&#39;, &#39;yxr&#39;) @ self.first_projection_year_yxr + \
            self.state_space_form.delta(&#39;zel&#39;, &#39;yjr&#39;) @ self.first_projection_year_yjr + \
            self.state_space_form.delta(&#39;zel&#39;, &#39;exz&#39;) @ self.first_projection_year_exz + \
            self.state_space_form.delta(&#39;zel&#39;, &#39;exo&#39;) @ self.first_projection_year_exo

        self.z1l_ssf_calculations_using_first_projection_year_data = self.state_space_form.delta(&#39;z1l&#39;, &#39;yxr&#39;) @ self.first_projection_year_yxr + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;yjr&#39;) @ self.first_projection_year_yjr + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;exz&#39;) @ self.first_projection_year_exz + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;exo&#39;) @ self.first_projection_year_exo

        # Step 2.
        self._x1r_difference_from_ssf = self.first_projection_year_x1r - self.x1l_ssf_calculations_using_first_projection_year_data  # t+1 = year after base year
        self._j1r_difference_from_ssf = self.first_projection_year_j1r - self.j1l_ssf_calculations_using_first_projection_year_data  # t+1 = year after base year
        self._zer_difference_from_ssf = self.first_projection_year_zer - self.zel_ssf_calculations_using_first_projection_year_data  # t = base year
        self._z1r_difference_from_ssf = self.first_projection_year_z1r - self.z1l_ssf_calculations_using_first_projection_year_data  # t = base year

    @property
    def first_projection_year_x1r(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The `x1r` vector populated with database values
        from the year after the first projection year.

        These values are not adjusted by any constants and are never
        altered after they are set.
        &#34;&#34;&#34;
        return self._first_projection_year_x1r

    @property
    def first_projection_year_j1r(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The `j1r` vector populated with database values
        from the year after the first projection year.
        
        These values are not adjusted by any constants and are never
        altered after they are set.
        &#34;&#34;&#34;
        return self._first_projection_year_j1r

    @property
    def first_projection_year_zer(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The `zer` vector populated with database values
        from the first projection year.
        
        These values are not adjusted by any constants and are never
        altered after they are set.
        &#34;&#34;&#34;
        return self._first_projection_year_zer

    @property
    def first_projection_year_z1r(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The `z1r` vector populated with database values
        from the first projection year.
        
        These values are not adjusted by any constants and are never
        altered after they are set.
        &#34;&#34;&#34;
        return self._first_projection_year_z1r

    @property
    def first_projection_year_yxr(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The `yxr` vector populated with database values
        from the first projection year.
        
        These values are not adjusted by any constants and are never
        altered after they are set.
        &#34;&#34;&#34;
        return self._first_projection_year_yxr

    @property
    def first_projection_year_yjr(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The `yjr` vector populated with database values
        from the first projection year.

        These values are not adjusted by any constants and are never
        altered after they are set.
        &#34;&#34;&#34;
        return self._first_projection_year_yjr

    @property
    def first_projection_year_exz(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The `exz` vector populated with database values
        from the year after the first projection year.

        These values are not adjusted by any constants and are never
        altered after they are set.
        &#34;&#34;&#34;
        return self._first_projection_year_exz

    @property
    def first_projection_year_exo(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The `exo` vector populated with database values
        from the first projection year.

        These values are not adjusted by any constants and are never
        altered after they are set.
        &#34;&#34;&#34;
        return self._first_projection_year_exo

    @property
    def x1r_difference_from_ssf(self):
        &#34;&#34;&#34;
        The difference between the database values of `x1r`
        and the raw baseline projections of those values,
        without making any constant adjustments at all.

        These differences are added to the constants that
        are used in the baseline projections to ensure that
        the projections in the first projection year match
        the database values in that year.
        &#34;&#34;&#34;
        return self._x1r_difference_from_ssf

    @property
    def j1r_difference_from_ssf(self):
        &#34;&#34;&#34;
        The difference between the database values of `j1r`
        and the raw baseline projections of those values,
        without making any constant adjustments at all.

        These differences are added to the constants that
        are used in the baseline projections to ensure that
        the projections in the first projection year match
        the database values in that year.

        &#34;&#34;&#34;
        return self._j1r_difference_from_ssf

    @property
    def zer_difference_from_ssf(self):
        &#34;&#34;&#34;
        The difference between the database values of `zer`
        and the raw baseline projections of those values,
        without making any constant adjustments at all.

        These differences are added to the constants that
        are used in the baseline projections to ensure that
        the projections in the first projection year match
        the database values in that year.
        &#34;&#34;&#34;
        return self._zer_difference_from_ssf

    @property
    def z1r_difference_from_ssf(self):
        &#34;&#34;&#34;
        The difference between the database values of `z1r`
        and the raw baseline projections of those values,
        without making any constant adjustments at all.

        These differences are added to the constants that
        are used in the baseline projections to ensure that
        the projections in the first projection year match
        the database values in that year.
        &#34;&#34;&#34;
        return self._z1r_difference_from_ssf

    @property
    def reference_h3t_used_to_compute_intertemporal_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Equivalent to h3t in the Ox implementation
        Functions of current and future exogenous variables affecting J1.
        This is the reference version of h3t, computed to calculation the projections
        for the base year that will be used as a reference projection when determining 
        the numeric derivatives for calculation of the intertemporal constants.

        Its only role is to preserve the appropriate information for benchmarking against Ox.
        &#34;&#34;&#34;
        return self._reference_h3t_used_to_compute_intertemporal_constants

    @property
    def reference_c4t_used_to_compute_intertemporal_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Equivalent to c4t in the Ox implementation
        Functions of current and future exogenous variables affecting ZE.
        This is the reference version of h3t, computed to calculation the projections
        for the base year that will be used as a reference projection when determining 
        the numeric derivatives for calculation of the intertemporal constants.

        Its only role is to preserve the appropriate information for benchmarking against Ox.
        &#34;&#34;&#34;
        return self._reference_c4t_used_to_compute_intertemporal_constants

    @property
    def x1_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to X1 to ensure projections equal observed values.
        Add any intertemporal constant values to the X1R difference to SSF equation 
        results with zero constants to get the combined set of constants.
        &#34;&#34;&#34;

        if hasattr(self, &#34;_x1_constants&#34;):
            return self._x1_constants

        result: np.ndarray = self.x1r_difference_from_ssf.copy()
        if not hasattr(self, &#34;intertemporal_constants&#34;):
            return result

        i = 0
        for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
            if variable_details[&#39;var_type&#39;] == &#39;x1l&#39;:
                result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
            i = i + 1

        self._x1_constants: np.ndarray = result
        return self._x1_constants

    @property
    def j1_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to J1 to ensure projections equal observed values.
        Add any intertemporal constant values to the X1R difference to SSF equation results with zero constants
        to get the combined set of constants.
        &#34;&#34;&#34;

        if hasattr(self, &#34;_j1_constants&#34;):
            return self._j1_constants

        result: np.ndarray = self.j1r_difference_from_ssf.copy()
        if not hasattr(self, &#34;intertemporal_constants&#34;):
            return result
        i = 0
        for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
            if variable_details[&#39;var_type&#39;] == &#39;j1l&#39;:
                result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
            i = i + 1

        self._j1_constants: np.ndarray = result
        return self._j1_constants

    @property
    def ze_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to ZE to ensure projections equal observed values.
        Add any intertemporal constant values to the X1R difference to SSF equation results with zero constants
        to get the combined set of constants.
        &#34;&#34;&#34;

        if hasattr(self, &#34;_ze_constants&#34;):
            return self._ze_constants

        result: np.ndarray = self.zer_difference_from_ssf.copy()
        if not hasattr(self, &#34;intertemporal_constants&#34;):
            return result

        i = 0
        for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
            if variable_details[&#39;var_type&#39;] == &#39;zel&#39;:
                logging.debug(
                    f&#34;At index {i} intertemporal constant is {self.intertemporal_constants.loc[variable_details[&#39;name&#39;],&#39;constant_value&#39;]} : shape is {self.intertemporal_constants.shape}&#34;)
                result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
            i = i + 1

        self._ze_constants: np.ndarray = result
        return self._ze_constants

    @property
    def z1_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to Z1 to ensure projections equal observed values.
        Add any intertemporal constant values to the X1R difference to SSF equation results with zero constants
        to get the combined set of constants.
        &#34;&#34;&#34;

        if hasattr(self, &#34;_z1_constants&#34;):
            return self._z1_constants

        result: np.ndarray = self.z1r_difference_from_ssf.copy()
        if not hasattr(self, &#34;intertemporal_constants&#34;):
            return result
        i = 0
        for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
            if variable_details[&#39;var_type&#39;] == &#39;z1l&#39;:
                result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
            i = i + 1

        self._z1_constants: np.ndarray = result
        return self._z1_constants

    def __create_exogenous_variable_projections(self):
        &#34;&#34;&#34;
        Populates the exogenous variable values through the projection years. 
        These values are determined outside of the model.

        When setting up baseline projections for exogenous variables, start by
        using the first projection year values for all of those variables and applying 
        them in all years through to the last projection year.
        
        Then adjust the database exogenous variable projections for:

        * effective labour productivity projections (based on population and productivity
        growth rates in each region)
        * energy efficiency improvement projections (based on projections of 
        autonomous energy efficiency improvements)
        &#34;&#34;&#34;

        # Replicate projection base year values across all projection periods for all exogenous variables.
        projections: pd.DataFrame = pd.DataFrame(np.tile(self.first_projection_year_exo, (1, self.configuration.projection_years_count)))
        projections.columns = self.projection_years_column_labels
        projections.reset_index()

        # Add effective labour productivity and energy usage efficiency.
        effective_labour_productivity: EffectiveLabourProductivity = self.model.effective_labour_productivity
        rogy: pd.DataFrame = effective_labour_productivity.rogy
        energy_usage_efficiency: EnergyUsageEfficiency = self.model.energy_usage_efficiency
        for region in self.sym_data.regions_members:

            regional_effective_labour_productivity: pd.DataFrame = effective_labour_productivity.effective_productivity_deviations(region=region)
            regional_energy_usage_efficiency: pd.DataFrame = energy_usage_efficiency.sector_cumulative_energy_usage_efficiency_gains(region=region)
            consumption_energy_usage_efficiency: pd.DataFrame = energy_usage_efficiency.consumption_cumulative_energy_usage_efficiency_gains

            variable_prefix_ROGY: str = f&#34;ROGY&#34;
            rogy_name: str = f&#34;{variable_prefix_ROGY}({region})&#34;
            if self.sym_data.has_variables(variable_name_prefix=rogy_name):
                rogy_index: int = self.sym_data.variable_index(vector_name=&#39;exo&#39;, variable_name=rogy_name)
                rogy_units = self.sym_data.units_for_variables_with_given_name_prefix(vector_name=&#39;exo&#39;, variable_name_prefix=variable_prefix_ROGY)
                rogy_data: pd.DataFrame = rogy.loc[[region], self.projection_years_column_labels]
                if &#39;gdp&#39; in rogy_units:
                    raise Exception(f&#34;{rogy_name} has gdp units so shocks to that variable are not supported.&#34;)

                projections.loc[[rogy_index], :] = projections.loc[[rogy_index], :] + (rogy_data.to_numpy().flatten() / 100)
            # else:
            #     logging.warning(f&#34;{rogy_name} is not in the SYM model.&#34;)

            shefc_name_prefix: str = f&#34;SHEFC&#34;
            shefc_name: str = f&#34;{shefc_name_prefix}({region})&#34;
            if self.sym_data.has_variables(variable_name_prefix=shefc_name_prefix):
                shefc_index: int = self.sym_data.variable_index(vector_name=&#39;exo&#39;, variable_name=shefc_name)
                shefc_units = self.sym_data.units_for_variables_with_given_name_prefix(vector_name=&#39;exo&#39;, variable_name_prefix=shefc_name_prefix)
                shefc_data: pd.DataFrame = consumption_energy_usage_efficiency.loc[[region], self.projection_years_column_labels]
                if &#39;gdp&#39; in shefc_units:
                    raise Exception(f&#34;{shefc_name} has gdp units so shocks to that variable are not supported.&#34;)
                projections.loc[[shefc_index], :] = projections.loc[[shefc_index], :] + (shefc_data.to_numpy().flatten() / 100)
            # else:
            #     logging.warning(f&#34;{shefc_name} is not in the SYM model.&#34;)

            variable_prefix_SHL: str = &#39;SHL&#39;
            variable_prefix_SHEF: str = &#39;SHEF&#39;
            for sector in self.sym_data.sectors_members:

                shl_name: str = f&#34;{variable_prefix_SHL}({region},{sector})&#34;
                if self.sym_data.has_variables(variable_name_prefix=shl_name):
                    shl_index: int = self.sym_data.variable_index(vector_name=&#39;exo&#39;, variable_name=shl_name)
                    shl_units = self.sym_data.units_for_variables_with_given_name_prefix(vector_name=&#39;exo&#39;, variable_name_prefix=variable_prefix_SHL)
                    shl_data: pd.DataFrame = regional_effective_labour_productivity.loc[[sector], self.projection_years_column_labels]
                    if &#39;gdp&#39; in shl_units:
                        raise Exception(f&#34;{shl_name} has gdp units so shocks to that variable are not supported.&#34;)
                    projections.loc[[shl_index], :] = projections.loc[[
                        shl_index], :] + (shl_data.to_numpy().flatten() / 100)
                # else:
                #     logging.warning(f&#34;{shl_name} is not in the SYM model.&#34;)

                shef_name: str = f&#34;{variable_prefix_SHEF}({sector},{region})&#34;
                if self.sym_data.has_variables(variable_name_prefix=shef_name):
                    shef_index: int = self.sym_data.variable_index(vector_name=&#39;exo&#39;, variable_name=shef_name)
                    shef_units = self.sym_data.units_for_variables_with_given_name_prefix(vector_name=&#39;exo&#39;, variable_name_prefix=variable_prefix_SHEF)
                    shef_data: pd.DataFrame = regional_energy_usage_efficiency.loc[[sector], self.projection_years_column_labels]
                    if &#39;gdp&#39; in shef_units:
                        raise Exception(f&#34;{shef_name} has gdp units so shocks to that variable are not supported.&#34;)
                    projections.loc[[shef_index], :] = projections.loc[[shef_index], :] + (shef_data.to_numpy().flatten() / 100)
                # else:
                #     logging.warning(f&#34;{shef_shock_name} is not in the SYM model.&#34;)

        # Index with variable names.
        projections.index = self.sym_data.vector_variable_names(vector_name=&#39;exo&#39;)

        # Store the exogenous projections that will be augmented for other projections.
        self._exo_projections: pd.DataFrame = projections

    def __evaluate_first_projection_year_vector_projections(self):
        &#34;&#34;&#34;
        Computes the values of the model equation vectors in the first projection year, 
        using the functions of future exogenous variables, the stable manifold, etc
        &#34;&#34;&#34;

        self._exo_first_year_projections = self.exo_projections.loc[:, [str(self.first_projection_year)]].to_numpy()

        self._yxr_first_year_projections = self.yxr_initial_values.to_numpy().copy()

        # er = h1t*x[][1] + h2t*exog[][1] + h3t[][1];
        self._yjr_first_year_projections = \
            self.stable_manifold.H1 @ self.yxr_first_year_projections + \
            self.stable_manifold.H2 @ self.exo_first_year_projections + \
            self._h3t[:, [0]]

        # tzl = mu1t*x[][1] + mu4t*exog[][1] + c4t[][1];
        self._exz_first_year_projections = \
            self.stable_manifold.mu1 @ self.yxr_first_year_projections + \
            self.stable_manifold.mu2 @ self.exo_first_year_projections + \
            self._c4t[:, [0]]

        # z1l projections = d5n*x[][1]+d7n*exog[][1]+d6n*er+d4n*tzl+cz6[][1]
        self._z1l_first_year_projections = \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;yxr&#39;) @ self.yxr_first_year_projections + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;exo&#39;) @ self.exo_first_year_projections + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;yjr&#39;) @ self.yjr_first_year_projections + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;exz&#39;) @ self.exz_first_year_projections + \
            self.z1r_difference_from_ssf

    @property
    def yxr_first_year_projections(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Projections of X1_t (yxr) in the first projection year
        &#34;&#34;&#34;
        return self._yxr_first_year_projections

    @property
    def yjr_first_year_projections(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Projections of J1_t (yjr) in the first projection year
        &#34;&#34;&#34;
        return self._yjr_first_year_projections

    @property
    def exz_first_year_projections(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Projections of ZE_t (exz) in the first projection year
        &#34;&#34;&#34;
        return self._exz_first_year_projections

    @property
    def z1l_first_year_projections(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Projections of Z1_t (z1l=z1r) in the first projection year
        &#34;&#34;&#34;
        return self._z1l_first_year_projections

    @property
    def exo_first_year_projections(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Projections of EXO_t in the first projection year
        &#34;&#34;&#34;
        return self._exo_first_year_projections

    @property
    def first_year_original_projections_of_variables_adjusted_by_intertemporal_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The first year projected values for the variables that are being
        adjusted by the intertemporal constants.

        The values are those for the projection that is not adjusted by intertemporal constants.

        It is used in the calculation of the intertemporal constants but it is only preserved
        as a property to facilitate benchmarking against Ox.
        &#34;&#34;&#34;
        return self._first_year_original_projections_of_variables_adjusted_by_intertemporal_constants

    @property
    def first_year_original_projections_of_yxr(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The first year projected values for the state variables.
        
        This is only required for benchmarking against Ox.
        &#34;&#34;&#34;
        return self._first_year_original_projections_of_yxr

    @property
    def first_year_original_projections_of_yjr(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The first year projected values for the costate variables.

        This is only required for benchmarking against Ox.
        &#34;&#34;&#34;
        return self._first_year_original_projections_of_yjr

    @property
    def first_year_original_projections_of_exz(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The first year projected values for the expected endogenous variables exz.

        This is only required for benchmarking against Ox.
        &#34;&#34;&#34;
        return self._first_year_original_projections_of_exz

    @property
    def first_year_original_projections_of_z1l(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The first year projected values for the endogenous variables.

        This is only required for benchmarking against Ox.
        &#34;&#34;&#34;
        return self._first_year_original_projections_of_z1l

    @property
    def first_year_observed_values_of_variables_adjusted_by_intertemporal_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Returns the observed values, in the first projection year, of the 
        variables that are adjusted by intertemporal constants.

        The values are not adjusted after they are initially set so they
        can be relied up and reused by the constant calculation process in this
        baseline projections and in any later relinearisation projections.
        &#34;&#34;&#34;
        return self._first_year_observed_values_of_variables_adjusted_by_intertemporal_constants

    @property
    def intertemporal_constants(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        The data frame of intertemporal constants information
        obtained from SYM but augmented with the values of the
        intertemporal constants.

        The dataframe is indexed by the variable names.

        The constant values are stored in a column called `constant_value`.
        &#34;&#34;&#34;
        return self._intertemporal_constants

    @property
    def partial_derivatives_wrt_intertemporal_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The matrix of partial derivatives used in Newton&#39;s method to
        compute the intertemporal constants.

        This is a property of the class just to support benchmarking against Ox.
        &#34;&#34;&#34;
        return self._partial_derivatives

    def __calculate_intertemporal_constants(self):
        &#34;&#34;&#34;
        ### Overview

        Computes the intertemporal constant adjustments to jump and other variables to align starting data
        values with model projections in the first year.

        Step 1.
        Compute functions of future exogenous variables through all years of the projection.

        Step 2.
        For the variables that are to be adjusted by the intertemporal
        constants, compute their projected values in the base projection year
        and store these values for comparison to perturbed base year projections so we can calculate
        the derivatives matrix needed to set the intertemporal constants.
        Also store the values of each of the 4 vectors in the model in the base year for benchmarking.

        Step 3.
        Initialise the partial derivatives matrix. This is the matrix of derivatives of each of the
        variables that is adjusted by intertemporal constants, with respect to each of the intertemporal
        constants, in the SSF equations (each of which is linear).

        Iterate over the intertemporal constants, perturbing each and recalculating the base year projections
        of the variables that are adjusted by intertemporal constants so that we can 
        estimate the relevant numeric derivatives.

        At the end of this step, update the perturbed variable details to `None` so that
        all constants associated with the difference between observed values and SSF calculated values
        are at their unpurturbed values when doing actual baseline projections.

        Step 4.
        Apply Newton&#39;s method to solve for the intertemporal constants.
        Multiply the difference between the observed values of the variables that are adjusted by
        the intertemporal constants and their original projected values, in the first projection year,
        by the inverse of the partial derivatives matrix.

        This only needs to be done once because the SSF of the model is linear so Newton&#39;s method
        gets to the solution in one iteration.
        &#34;&#34;&#34;

        # Step 1.
        self._compute_functions_of_future_exogenous_variables(exogenous_projections=self.exo_projections)
        self._reference_c4t_used_to_compute_intertemporal_constants = self.c4t.copy()
        self._reference_h3t_used_to_compute_intertemporal_constants = self.h3t.copy()

        # Step 2.
        
        # Compute the first year projections - noting that no intertemporal 
        # constant adjustments have been made yet.
        self.__evaluate_first_projection_year_vector_projections()

        # Capture the first year projections of the intertemporal variables. 
        # These are used in this function for Newton&#39;s method below
        # and they are also deep-copied and stored as a property of the 
        # class for benchmarking purposes.
        self._first_year_original_projections_of_variables_adjusted_by_intertemporal_constants = self.first_year_projections_of_variables_adjusted_by_intertemporal_constants.copy()

        # For benchmarking purposes only, preserve the original first year projections
        self._first_year_original_projections_of_yxr = self.yxr_first_year_projections.copy()
        self._first_year_original_projections_of_yjr = self.yjr_first_year_projections.copy()
        self._first_year_original_projections_of_exz = self.exz_first_year_projections.copy()
        self._first_year_original_projections_of_z1l = self.z1l_first_year_projections.copy()

        # Step 3.
        # Compute the partial derivatives matrix
        self._partial_derivatives = np.zeros(shape=(len(self.sym_data.intertemporal_constant_variables), len(
            self.sym_data.variables_adjusted_by_intertemporal_constants)))
        i = 0
        for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
            self.__update_perturbed_variable(variable_details=variable_details)
            self._compute_functions_of_future_exogenous_variables(exogenous_projections=self.exo_projections)
            self.__evaluate_first_projection_year_vector_projections()
            self._partial_derivatives[:, [i]] = (
                self.first_year_projections_of_variables_adjusted_by_intertemporal_constants -
                self._first_year_original_projections_of_variables_adjusted_by_intertemporal_constants) / Constants().DELTA
            i += 1

        # Generate the baseline projection to use in computing partial derivatives
        # and to generate matrix values that are used later in projection processes.
        self.__update_perturbed_variable(variable_details=None)

        # Step 4.
        # Use Newtons method adjustment to compute intertemporal constant values
        self._intertemporal_constants = self.sym_data.intertemporal_constant_variables
        values: np.ndarray = np.linalg.inv(self._partial_derivatives) @ \
            (self.first_year_observed_values_of_variables_adjusted_by_intertemporal_constants -
             self.first_year_original_projections_of_variables_adjusted_by_intertemporal_constants)
        values = values.reshape((len(self.intertemporal_constants.index), 1))
        self._intertemporal_constants[&#39;constant_value&#39;] = values

        logging.info(&#34;The intertemporal constants have been calibrated.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gcubed.projections.projections.Projections" href="projections.html#gcubed.projections.projections.Projections">Projections</a></li>
<li><a title="gcubed.base.Base" href="../base.html#gcubed.base.Base">Base</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.baseline_projections"><code class="name">var <span class="ident">baseline_projections</span> :Optional[<a title="gcubed.projections.baseline_projections.BaselineProjections" href="#gcubed.projections.baseline_projections.BaselineProjections">BaselineProjections</a>]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def baseline_projections(self) -&gt; Optional[&#39;BaselineProjections&#39;]:
    return self</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.database"><code class="name">var <span class="ident">database</span> :<a title="gcubed.data.gdp_scaled_database.GDPScaledDatabase" href="../data/gdp_scaled_database.html#gcubed.data.gdp_scaled_database.GDPScaledDatabase">GDPScaledDatabase</a></code></dt>
<dd>
<div class="desc"><p>The database used as the starting point for the projections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def database(self) -&gt; GDPScaledDatabase:
    &#34;&#34;&#34;
    The database used as the starting point for the projections.
    &#34;&#34;&#34;
    return self._database</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.exo_first_year_projections"><code class="name">var <span class="ident">exo_first_year_projections</span> :numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Projections of EXO_t in the first projection year</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def exo_first_year_projections(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Projections of EXO_t in the first projection year
    &#34;&#34;&#34;
    return self._exo_first_year_projections</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.exz_first_year_projections"><code class="name">var <span class="ident">exz_first_year_projections</span> :numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Projections of ZE_t (exz) in the first projection year</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def exz_first_year_projections(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Projections of ZE_t (exz) in the first projection year
    &#34;&#34;&#34;
    return self._exz_first_year_projections</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_exo"><code class="name">var <span class="ident">first_projection_year_exo</span> :numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The <code>exo</code> vector populated with database values
from the first projection year.</p>
<p>These values are not adjusted by any constants and are never
altered after they are set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def first_projection_year_exo(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The `exo` vector populated with database values
    from the first projection year.

    These values are not adjusted by any constants and are never
    altered after they are set.
    &#34;&#34;&#34;
    return self._first_projection_year_exo</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_exz"><code class="name">var <span class="ident">first_projection_year_exz</span> :numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The <code>exz</code> vector populated with database values
from the year after the first projection year.</p>
<p>These values are not adjusted by any constants and are never
altered after they are set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def first_projection_year_exz(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The `exz` vector populated with database values
    from the year after the first projection year.

    These values are not adjusted by any constants and are never
    altered after they are set.
    &#34;&#34;&#34;
    return self._first_projection_year_exz</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_j1r"><code class="name">var <span class="ident">first_projection_year_j1r</span> :numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The <code>j1r</code> vector populated with database values
from the year after the first projection year.</p>
<p>These values are not adjusted by any constants and are never
altered after they are set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def first_projection_year_j1r(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The `j1r` vector populated with database values
    from the year after the first projection year.
    
    These values are not adjusted by any constants and are never
    altered after they are set.
    &#34;&#34;&#34;
    return self._first_projection_year_j1r</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_x1r"><code class="name">var <span class="ident">first_projection_year_x1r</span> :numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The <code>x1r</code> vector populated with database values
from the year after the first projection year.</p>
<p>These values are not adjusted by any constants and are never
altered after they are set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def first_projection_year_x1r(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The `x1r` vector populated with database values
    from the year after the first projection year.

    These values are not adjusted by any constants and are never
    altered after they are set.
    &#34;&#34;&#34;
    return self._first_projection_year_x1r</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_yjr"><code class="name">var <span class="ident">first_projection_year_yjr</span> :numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The <code>yjr</code> vector populated with database values
from the first projection year.</p>
<p>These values are not adjusted by any constants and are never
altered after they are set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def first_projection_year_yjr(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The `yjr` vector populated with database values
    from the first projection year.

    These values are not adjusted by any constants and are never
    altered after they are set.
    &#34;&#34;&#34;
    return self._first_projection_year_yjr</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_yxr"><code class="name">var <span class="ident">first_projection_year_yxr</span> :numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The <code>yxr</code> vector populated with database values
from the first projection year.</p>
<p>These values are not adjusted by any constants and are never
altered after they are set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def first_projection_year_yxr(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The `yxr` vector populated with database values
    from the first projection year.
    
    These values are not adjusted by any constants and are never
    altered after they are set.
    &#34;&#34;&#34;
    return self._first_projection_year_yxr</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_z1r"><code class="name">var <span class="ident">first_projection_year_z1r</span> :numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The <code>z1r</code> vector populated with database values
from the first projection year.</p>
<p>These values are not adjusted by any constants and are never
altered after they are set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def first_projection_year_z1r(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The `z1r` vector populated with database values
    from the first projection year.
    
    These values are not adjusted by any constants and are never
    altered after they are set.
    &#34;&#34;&#34;
    return self._first_projection_year_z1r</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_zer"><code class="name">var <span class="ident">first_projection_year_zer</span> :numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The <code>zer</code> vector populated with database values
from the first projection year.</p>
<p>These values are not adjusted by any constants and are never
altered after they are set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def first_projection_year_zer(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The `zer` vector populated with database values
    from the first projection year.
    
    These values are not adjusted by any constants and are never
    altered after they are set.
    &#34;&#34;&#34;
    return self._first_projection_year_zer</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.first_year_observed_values_of_variables_adjusted_by_intertemporal_constants"><code class="name">var <span class="ident">first_year_observed_values_of_variables_adjusted_by_intertemporal_constants</span> :numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Returns the observed values, in the first projection year, of the
variables that are adjusted by intertemporal constants.</p>
<p>The values are not adjusted after they are initially set so they
can be relied up and reused by the constant calculation process in this
baseline projections and in any later relinearisation projections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def first_year_observed_values_of_variables_adjusted_by_intertemporal_constants(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Returns the observed values, in the first projection year, of the 
    variables that are adjusted by intertemporal constants.

    The values are not adjusted after they are initially set so they
    can be relied up and reused by the constant calculation process in this
    baseline projections and in any later relinearisation projections.
    &#34;&#34;&#34;
    return self._first_year_observed_values_of_variables_adjusted_by_intertemporal_constants</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.first_year_original_projections_of_exz"><code class="name">var <span class="ident">first_year_original_projections_of_exz</span> :numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The first year projected values for the expected endogenous variables exz.</p>
<p>This is only required for benchmarking against Ox.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def first_year_original_projections_of_exz(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The first year projected values for the expected endogenous variables exz.

    This is only required for benchmarking against Ox.
    &#34;&#34;&#34;
    return self._first_year_original_projections_of_exz</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.first_year_original_projections_of_variables_adjusted_by_intertemporal_constants"><code class="name">var <span class="ident">first_year_original_projections_of_variables_adjusted_by_intertemporal_constants</span> :numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The first year projected values for the variables that are being
adjusted by the intertemporal constants.</p>
<p>The values are those for the projection that is not adjusted by intertemporal constants.</p>
<p>It is used in the calculation of the intertemporal constants but it is only preserved
as a property to facilitate benchmarking against Ox.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def first_year_original_projections_of_variables_adjusted_by_intertemporal_constants(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The first year projected values for the variables that are being
    adjusted by the intertemporal constants.

    The values are those for the projection that is not adjusted by intertemporal constants.

    It is used in the calculation of the intertemporal constants but it is only preserved
    as a property to facilitate benchmarking against Ox.
    &#34;&#34;&#34;
    return self._first_year_original_projections_of_variables_adjusted_by_intertemporal_constants</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.first_year_original_projections_of_yjr"><code class="name">var <span class="ident">first_year_original_projections_of_yjr</span> :numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The first year projected values for the costate variables.</p>
<p>This is only required for benchmarking against Ox.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def first_year_original_projections_of_yjr(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The first year projected values for the costate variables.

    This is only required for benchmarking against Ox.
    &#34;&#34;&#34;
    return self._first_year_original_projections_of_yjr</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.first_year_original_projections_of_yxr"><code class="name">var <span class="ident">first_year_original_projections_of_yxr</span> :numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The first year projected values for the state variables.</p>
<p>This is only required for benchmarking against Ox.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def first_year_original_projections_of_yxr(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The first year projected values for the state variables.
    
    This is only required for benchmarking against Ox.
    &#34;&#34;&#34;
    return self._first_year_original_projections_of_yxr</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.first_year_original_projections_of_z1l"><code class="name">var <span class="ident">first_year_original_projections_of_z1l</span> :numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The first year projected values for the endogenous variables.</p>
<p>This is only required for benchmarking against Ox.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def first_year_original_projections_of_z1l(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The first year projected values for the endogenous variables.

    This is only required for benchmarking against Ox.
    &#34;&#34;&#34;
    return self._first_year_original_projections_of_z1l</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.first_year_projections_of_variables_adjusted_by_intertemporal_constants"><code class="name">var <span class="ident">first_year_projections_of_variables_adjusted_by_intertemporal_constants</span> :numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>An column vector of first year projection values for those variables that are adjusted
by intertemporal constants.</p>
<p>The vector is populated from the vectors of first year projections for
each of <code>x1l</code>, <code>j1l</code>, <code>zel</code>,
and <code>z1l</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def first_year_projections_of_variables_adjusted_by_intertemporal_constants(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    An column vector of first year projection values for those variables that are adjusted
    by intertemporal constants.

    The vector is populated from the vectors of first year projections for 
    each of `x1l`, `j1l`, `zel`,  and `z1l`.
    &#34;&#34;&#34;
    result = np.zeros(shape=(len(self.sym_data.variables_adjusted_by_intertemporal_constants), 1))
    i = 0
    for index, adjusted_variable_details in self.sym_data.variables_adjusted_by_intertemporal_constants.iterrows():
        sequence = adjusted_variable_details[&#39;sequence&#39;]
        match adjusted_variable_details[&#39;var_type&#39;]:
            case &#39;x1l&#39;:
                result[i, 0] = self.yxr_first_year_projections[[sequence]]
            case &#39;j1l&#39;:
                result[i, 0] = self.yjr_first_year_projections[[sequence]]
            case &#39;zel&#39;:
                result[i, 0] = self.exz_first_year_projections[[sequence]]
            case &#39;z1l&#39;:
                result[i, 0] = self.z1l_first_year_projections[[sequence]]
        i += 1
    return result</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.intertemporal_constants"><code class="name">var <span class="ident">intertemporal_constants</span> :pandas.core.frame.DataFrame</code></dt>
<dd>
<div class="desc"><p>The data frame of intertemporal constants information
obtained from SYM but augmented with the values of the
intertemporal constants.</p>
<p>The dataframe is indexed by the variable names.</p>
<p>The constant values are stored in a column called <code>constant_value</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def intertemporal_constants(self) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    The data frame of intertemporal constants information
    obtained from SYM but augmented with the values of the
    intertemporal constants.

    The dataframe is indexed by the variable names.

    The constant values are stored in a column called `constant_value`.
    &#34;&#34;&#34;
    return self._intertemporal_constants</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.j1_constants"><code class="name">var <span class="ident">j1_constants</span> :numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The constant adjustments to J1 to ensure projections equal observed values.
Add any intertemporal constant values to the X1R difference to SSF equation results with zero constants
to get the combined set of constants.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def j1_constants(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The constant adjustments to J1 to ensure projections equal observed values.
    Add any intertemporal constant values to the X1R difference to SSF equation results with zero constants
    to get the combined set of constants.
    &#34;&#34;&#34;

    if hasattr(self, &#34;_j1_constants&#34;):
        return self._j1_constants

    result: np.ndarray = self.j1r_difference_from_ssf.copy()
    if not hasattr(self, &#34;intertemporal_constants&#34;):
        return result
    i = 0
    for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
        if variable_details[&#39;var_type&#39;] == &#39;j1l&#39;:
            result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
        i = i + 1

    self._j1_constants: np.ndarray = result
    return self._j1_constants</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.j1r_difference_from_ssf"><code class="name">var <span class="ident">j1r_difference_from_ssf</span></code></dt>
<dd>
<div class="desc"><p>The difference between the database values of <code>j1r</code>
and the raw baseline projections of those values,
without making any constant adjustments at all.</p>
<p>These differences are added to the constants that
are used in the baseline projections to ensure that
the projections in the first projection year match
the database values in that year.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def j1r_difference_from_ssf(self):
    &#34;&#34;&#34;
    The difference between the database values of `j1r`
    and the raw baseline projections of those values,
    without making any constant adjustments at all.

    These differences are added to the constants that
    are used in the baseline projections to ensure that
    the projections in the first projection year match
    the database values in that year.

    &#34;&#34;&#34;
    return self._j1r_difference_from_ssf</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.partial_derivatives_wrt_intertemporal_constants"><code class="name">var <span class="ident">partial_derivatives_wrt_intertemporal_constants</span> :numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The matrix of partial derivatives used in Newton's method to
compute the intertemporal constants.</p>
<p>This is a property of the class just to support benchmarking against Ox.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def partial_derivatives_wrt_intertemporal_constants(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The matrix of partial derivatives used in Newton&#39;s method to
    compute the intertemporal constants.

    This is a property of the class just to support benchmarking against Ox.
    &#34;&#34;&#34;
    return self._partial_derivatives</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.perturbed_variable_details"><code class="name">var <span class="ident">perturbed_variable_details</span> :pandas.core.series.Series</code></dt>
<dd>
<div class="desc"><p>If computing intertemporal constants,
the var_map details (the row of the SYM var_map dataframe)
for the variable being perturbed as part of computing
derivatives needed to set intertemporal constants. Otherwise, this returns
<code>None</code> if just producing the baseline projections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def perturbed_variable_details(self) -&gt; pd.Series:
    &#34;&#34;&#34;
    If computing intertemporal constants, 
    the var_map details (the row of the SYM var_map dataframe)
    for the variable being perturbed as part of computing
    derivatives needed to set intertemporal constants. Otherwise, this returns
    `None` if just producing the baseline projections.
    &#34;&#34;&#34;
    if hasattr(self, &#39;_perturbed_variable_details&#39;):
        return self._perturbed_variable_details
    return None</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.reference_c4t_used_to_compute_intertemporal_constants"><code class="name">var <span class="ident">reference_c4t_used_to_compute_intertemporal_constants</span> :numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Equivalent to c4t in the Ox implementation
Functions of current and future exogenous variables affecting ZE.
This is the reference version of h3t, computed to calculation the projections
for the base year that will be used as a reference projection when determining
the numeric derivatives for calculation of the intertemporal constants.</p>
<p>Its only role is to preserve the appropriate information for benchmarking against Ox.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def reference_c4t_used_to_compute_intertemporal_constants(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Equivalent to c4t in the Ox implementation
    Functions of current and future exogenous variables affecting ZE.
    This is the reference version of h3t, computed to calculation the projections
    for the base year that will be used as a reference projection when determining 
    the numeric derivatives for calculation of the intertemporal constants.

    Its only role is to preserve the appropriate information for benchmarking against Ox.
    &#34;&#34;&#34;
    return self._reference_c4t_used_to_compute_intertemporal_constants</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.reference_h3t_used_to_compute_intertemporal_constants"><code class="name">var <span class="ident">reference_h3t_used_to_compute_intertemporal_constants</span> :numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Equivalent to h3t in the Ox implementation
Functions of current and future exogenous variables affecting J1.
This is the reference version of h3t, computed to calculation the projections
for the base year that will be used as a reference projection when determining
the numeric derivatives for calculation of the intertemporal constants.</p>
<p>Its only role is to preserve the appropriate information for benchmarking against Ox.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def reference_h3t_used_to_compute_intertemporal_constants(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Equivalent to h3t in the Ox implementation
    Functions of current and future exogenous variables affecting J1.
    This is the reference version of h3t, computed to calculation the projections
    for the base year that will be used as a reference projection when determining 
    the numeric derivatives for calculation of the intertemporal constants.

    Its only role is to preserve the appropriate information for benchmarking against Ox.
    &#34;&#34;&#34;
    return self._reference_h3t_used_to_compute_intertemporal_constants</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.start_from_neutral_real_interest_rate"><code class="name">var <span class="ident">start_from_neutral_real_interest_rate</span> :bool</code></dt>
<dd>
<div class="desc"><p><code>True</code> if interest rates are set to the neutral real interest
rate for the start of the baseline projections and <code>False</code> otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def start_from_neutral_real_interest_rate(self) -&gt; bool:
    &#34;&#34;&#34;
    `True` if interest rates are set to the neutral real interest
    rate for the start of the baseline projections and `False` otherwise.
    &#34;&#34;&#34;
    return self._start_from_neutral_real_interest_rate</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.x1_constants"><code class="name">var <span class="ident">x1_constants</span> :numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The constant adjustments to X1 to ensure projections equal observed values.
Add any intertemporal constant values to the X1R difference to SSF equation
results with zero constants to get the combined set of constants.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def x1_constants(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The constant adjustments to X1 to ensure projections equal observed values.
    Add any intertemporal constant values to the X1R difference to SSF equation 
    results with zero constants to get the combined set of constants.
    &#34;&#34;&#34;

    if hasattr(self, &#34;_x1_constants&#34;):
        return self._x1_constants

    result: np.ndarray = self.x1r_difference_from_ssf.copy()
    if not hasattr(self, &#34;intertemporal_constants&#34;):
        return result

    i = 0
    for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
        if variable_details[&#39;var_type&#39;] == &#39;x1l&#39;:
            result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
        i = i + 1

    self._x1_constants: np.ndarray = result
    return self._x1_constants</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.x1r_difference_from_ssf"><code class="name">var <span class="ident">x1r_difference_from_ssf</span></code></dt>
<dd>
<div class="desc"><p>The difference between the database values of <code>x1r</code>
and the raw baseline projections of those values,
without making any constant adjustments at all.</p>
<p>These differences are added to the constants that
are used in the baseline projections to ensure that
the projections in the first projection year match
the database values in that year.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def x1r_difference_from_ssf(self):
    &#34;&#34;&#34;
    The difference between the database values of `x1r`
    and the raw baseline projections of those values,
    without making any constant adjustments at all.

    These differences are added to the constants that
    are used in the baseline projections to ensure that
    the projections in the first projection year match
    the database values in that year.
    &#34;&#34;&#34;
    return self._x1r_difference_from_ssf</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.yjr_first_year_projections"><code class="name">var <span class="ident">yjr_first_year_projections</span> :numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Projections of J1_t (yjr) in the first projection year</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def yjr_first_year_projections(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Projections of J1_t (yjr) in the first projection year
    &#34;&#34;&#34;
    return self._yjr_first_year_projections</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.yxr_first_year_projections"><code class="name">var <span class="ident">yxr_first_year_projections</span> :numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Projections of X1_t (yxr) in the first projection year</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def yxr_first_year_projections(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Projections of X1_t (yxr) in the first projection year
    &#34;&#34;&#34;
    return self._yxr_first_year_projections</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.z1_constants"><code class="name">var <span class="ident">z1_constants</span> :numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The constant adjustments to Z1 to ensure projections equal observed values.
Add any intertemporal constant values to the X1R difference to SSF equation results with zero constants
to get the combined set of constants.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def z1_constants(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The constant adjustments to Z1 to ensure projections equal observed values.
    Add any intertemporal constant values to the X1R difference to SSF equation results with zero constants
    to get the combined set of constants.
    &#34;&#34;&#34;

    if hasattr(self, &#34;_z1_constants&#34;):
        return self._z1_constants

    result: np.ndarray = self.z1r_difference_from_ssf.copy()
    if not hasattr(self, &#34;intertemporal_constants&#34;):
        return result
    i = 0
    for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
        if variable_details[&#39;var_type&#39;] == &#39;z1l&#39;:
            result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
        i = i + 1

    self._z1_constants: np.ndarray = result
    return self._z1_constants</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.z1l_first_year_projections"><code class="name">var <span class="ident">z1l_first_year_projections</span> :numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Projections of Z1_t (z1l=z1r) in the first projection year</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def z1l_first_year_projections(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Projections of Z1_t (z1l=z1r) in the first projection year
    &#34;&#34;&#34;
    return self._z1l_first_year_projections</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.z1r_difference_from_ssf"><code class="name">var <span class="ident">z1r_difference_from_ssf</span></code></dt>
<dd>
<div class="desc"><p>The difference between the database values of <code>z1r</code>
and the raw baseline projections of those values,
without making any constant adjustments at all.</p>
<p>These differences are added to the constants that
are used in the baseline projections to ensure that
the projections in the first projection year match
the database values in that year.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def z1r_difference_from_ssf(self):
    &#34;&#34;&#34;
    The difference between the database values of `z1r`
    and the raw baseline projections of those values,
    without making any constant adjustments at all.

    These differences are added to the constants that
    are used in the baseline projections to ensure that
    the projections in the first projection year match
    the database values in that year.
    &#34;&#34;&#34;
    return self._z1r_difference_from_ssf</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.ze_constants"><code class="name">var <span class="ident">ze_constants</span> :numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The constant adjustments to ZE to ensure projections equal observed values.
Add any intertemporal constant values to the X1R difference to SSF equation results with zero constants
to get the combined set of constants.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ze_constants(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The constant adjustments to ZE to ensure projections equal observed values.
    Add any intertemporal constant values to the X1R difference to SSF equation results with zero constants
    to get the combined set of constants.
    &#34;&#34;&#34;

    if hasattr(self, &#34;_ze_constants&#34;):
        return self._ze_constants

    result: np.ndarray = self.zer_difference_from_ssf.copy()
    if not hasattr(self, &#34;intertemporal_constants&#34;):
        return result

    i = 0
    for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
        if variable_details[&#39;var_type&#39;] == &#39;zel&#39;:
            logging.debug(
                f&#34;At index {i} intertemporal constant is {self.intertemporal_constants.loc[variable_details[&#39;name&#39;],&#39;constant_value&#39;]} : shape is {self.intertemporal_constants.shape}&#34;)
            result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
        i = i + 1

    self._ze_constants: np.ndarray = result
    return self._ze_constants</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.zer_difference_from_ssf"><code class="name">var <span class="ident">zer_difference_from_ssf</span></code></dt>
<dd>
<div class="desc"><p>The difference between the database values of <code>zer</code>
and the raw baseline projections of those values,
without making any constant adjustments at all.</p>
<p>These differences are added to the constants that
are used in the baseline projections to ensure that
the projections in the first projection year match
the database values in that year.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def zer_difference_from_ssf(self):
    &#34;&#34;&#34;
    The difference between the database values of `zer`
    and the raw baseline projections of those values,
    without making any constant adjustments at all.

    These differences are added to the constants that
    are used in the baseline projections to ensure that
    the projections in the first projection year match
    the database values in that year.
    &#34;&#34;&#34;
    return self._zer_difference_from_ssf</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gcubed.projections.projections.Projections" href="projections.html#gcubed.projections.projections.Projections">Projections</a></b></code>:
<ul class="hlist">
<li><code><a title="gcubed.projections.projections.Projections.annotated_database_projections" href="projections.html#gcubed.projections.projections.Projections.annotated_database_projections">annotated_database_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.annotated_projections" href="projections.html#gcubed.projections.projections.Projections.annotated_projections">annotated_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.annotated_publishable_projections" href="projections.html#gcubed.projections.projections.Projections.annotated_publishable_projections">annotated_publishable_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.c4t" href="projections.html#gcubed.projections.projections.Projections.c4t">c4t</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.c4t_as_dataframe" href="projections.html#gcubed.projections.projections.Projections.c4t_as_dataframe">c4t_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.configuration" href="projections.html#gcubed.projections.projections.Projections.configuration">configuration</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.database_projections" href="projections.html#gcubed.projections.projections.Projections.database_projections">database_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.exo_projections" href="projections.html#gcubed.projections.projections.Projections.exo_projections">exo_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.exz_projections" href="projections.html#gcubed.projections.projections.Projections.exz_projections">exz_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.exz_projections_as_dataframe" href="projections.html#gcubed.projections.projections.Projections.exz_projections_as_dataframe">exz_projections_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.first_projection_year" href="projections.html#gcubed.projections.projections.Projections.first_projection_year">first_projection_year</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.get_differences_between_projections" href="projections.html#gcubed.projections.projections.Projections.get_differences_between_projections">get_differences_between_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.get_year_labels" href="../base.html#gcubed.base.Base.get_year_labels">get_year_labels</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.h3t" href="projections.html#gcubed.projections.projections.Projections.h3t">h3t</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.h3t_as_dataframe" href="projections.html#gcubed.projections.projections.Projections.h3t_as_dataframe">h3t_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.is_baseline_projections" href="projections.html#gcubed.projections.projections.Projections.is_baseline_projections">is_baseline_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.last_projection_year" href="projections.html#gcubed.projections.projections.Projections.last_projection_year">last_projection_year</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.load_data" href="../base.html#gcubed.base.Base.load_data">load_data</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.long_rate_constants" href="projections.html#gcubed.projections.projections.Projections.long_rate_constants">long_rate_constants</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.model" href="projections.html#gcubed.projections.projections.Projections.model">model</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.now" href="../base.html#gcubed.base.Base.now">now</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.parameters" href="projections.html#gcubed.projections.projections.Projections.parameters">parameters</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.previous_projections" href="projections.html#gcubed.projections.projections.Projections.previous_projections">previous_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.projection_years" href="projections.html#gcubed.projections.projections.Projections.projection_years">projection_years</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.projection_years_column_labels" href="projections.html#gcubed.projections.projections.Projections.projection_years_column_labels">projection_years_column_labels</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.projections" href="projections.html#gcubed.projections.projections.Projections.projections">projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.publishable_projections" href="projections.html#gcubed.projections.projections.Projections.publishable_projections">publishable_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.stable_manifold" href="projections.html#gcubed.projections.projections.Projections.stable_manifold">stable_manifold</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.state_space_form" href="projections.html#gcubed.projections.projections.Projections.state_space_form">state_space_form</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.sym_data" href="projections.html#gcubed.projections.projections.Projections.sym_data">sym_data</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.yjr_projections" href="projections.html#gcubed.projections.projections.Projections.yjr_projections">yjr_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.yjr_projections_as_dataframe" href="projections.html#gcubed.projections.projections.Projections.yjr_projections_as_dataframe">yjr_projections_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.yxr_initial_values" href="projections.html#gcubed.projections.projections.Projections.yxr_initial_values">yxr_initial_values</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.yxr_projections" href="projections.html#gcubed.projections.projections.Projections.yxr_projections">yxr_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.yxr_projections_as_dataframe" href="projections.html#gcubed.projections.projections.Projections.yxr_projections_as_dataframe">yxr_projections_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.z1l_projections" href="projections.html#gcubed.projections.projections.Projections.z1l_projections">z1l_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.z1l_projections_as_dataframe" href="projections.html#gcubed.projections.projections.Projections.z1l_projections_as_dataframe">z1l_projections_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.zel_projections" href="projections.html#gcubed.projections.projections.Projections.zel_projections">zel_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.zel_projections_as_dataframe" href="projections.html#gcubed.projections.projections.Projections.zel_projections_as_dataframe">zel_projections_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.zeros" href="../base.html#gcubed.base.Base.zeros">zeros</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gcubed.projections" href="index.html">gcubed.projections</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gcubed.projections.baseline_projections.BaselineProjections" href="#gcubed.projections.baseline_projections.BaselineProjections">BaselineProjections</a></code></h4>
<ul class="">
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.baseline_projections" href="#gcubed.projections.baseline_projections.BaselineProjections.baseline_projections">baseline_projections</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.database" href="#gcubed.projections.baseline_projections.BaselineProjections.database">database</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.exo_first_year_projections" href="#gcubed.projections.baseline_projections.BaselineProjections.exo_first_year_projections">exo_first_year_projections</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.exz_first_year_projections" href="#gcubed.projections.baseline_projections.BaselineProjections.exz_first_year_projections">exz_first_year_projections</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_exo" href="#gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_exo">first_projection_year_exo</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_exz" href="#gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_exz">first_projection_year_exz</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_j1r" href="#gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_j1r">first_projection_year_j1r</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_x1r" href="#gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_x1r">first_projection_year_x1r</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_yjr" href="#gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_yjr">first_projection_year_yjr</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_yxr" href="#gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_yxr">first_projection_year_yxr</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_z1r" href="#gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_z1r">first_projection_year_z1r</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_zer" href="#gcubed.projections.baseline_projections.BaselineProjections.first_projection_year_zer">first_projection_year_zer</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.first_year_observed_values_of_variables_adjusted_by_intertemporal_constants" href="#gcubed.projections.baseline_projections.BaselineProjections.first_year_observed_values_of_variables_adjusted_by_intertemporal_constants">first_year_observed_values_of_variables_adjusted_by_intertemporal_constants</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.first_year_original_projections_of_exz" href="#gcubed.projections.baseline_projections.BaselineProjections.first_year_original_projections_of_exz">first_year_original_projections_of_exz</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.first_year_original_projections_of_variables_adjusted_by_intertemporal_constants" href="#gcubed.projections.baseline_projections.BaselineProjections.first_year_original_projections_of_variables_adjusted_by_intertemporal_constants">first_year_original_projections_of_variables_adjusted_by_intertemporal_constants</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.first_year_original_projections_of_yjr" href="#gcubed.projections.baseline_projections.BaselineProjections.first_year_original_projections_of_yjr">first_year_original_projections_of_yjr</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.first_year_original_projections_of_yxr" href="#gcubed.projections.baseline_projections.BaselineProjections.first_year_original_projections_of_yxr">first_year_original_projections_of_yxr</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.first_year_original_projections_of_z1l" href="#gcubed.projections.baseline_projections.BaselineProjections.first_year_original_projections_of_z1l">first_year_original_projections_of_z1l</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.first_year_projections_of_variables_adjusted_by_intertemporal_constants" href="#gcubed.projections.baseline_projections.BaselineProjections.first_year_projections_of_variables_adjusted_by_intertemporal_constants">first_year_projections_of_variables_adjusted_by_intertemporal_constants</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.intertemporal_constants" href="#gcubed.projections.baseline_projections.BaselineProjections.intertemporal_constants">intertemporal_constants</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.j1_constants" href="#gcubed.projections.baseline_projections.BaselineProjections.j1_constants">j1_constants</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.j1r_difference_from_ssf" href="#gcubed.projections.baseline_projections.BaselineProjections.j1r_difference_from_ssf">j1r_difference_from_ssf</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.partial_derivatives_wrt_intertemporal_constants" href="#gcubed.projections.baseline_projections.BaselineProjections.partial_derivatives_wrt_intertemporal_constants">partial_derivatives_wrt_intertemporal_constants</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.perturbed_variable_details" href="#gcubed.projections.baseline_projections.BaselineProjections.perturbed_variable_details">perturbed_variable_details</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.reference_c4t_used_to_compute_intertemporal_constants" href="#gcubed.projections.baseline_projections.BaselineProjections.reference_c4t_used_to_compute_intertemporal_constants">reference_c4t_used_to_compute_intertemporal_constants</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.reference_h3t_used_to_compute_intertemporal_constants" href="#gcubed.projections.baseline_projections.BaselineProjections.reference_h3t_used_to_compute_intertemporal_constants">reference_h3t_used_to_compute_intertemporal_constants</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.start_from_neutral_real_interest_rate" href="#gcubed.projections.baseline_projections.BaselineProjections.start_from_neutral_real_interest_rate">start_from_neutral_real_interest_rate</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.x1_constants" href="#gcubed.projections.baseline_projections.BaselineProjections.x1_constants">x1_constants</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.x1r_difference_from_ssf" href="#gcubed.projections.baseline_projections.BaselineProjections.x1r_difference_from_ssf">x1r_difference_from_ssf</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.yjr_first_year_projections" href="#gcubed.projections.baseline_projections.BaselineProjections.yjr_first_year_projections">yjr_first_year_projections</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.yxr_first_year_projections" href="#gcubed.projections.baseline_projections.BaselineProjections.yxr_first_year_projections">yxr_first_year_projections</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.z1_constants" href="#gcubed.projections.baseline_projections.BaselineProjections.z1_constants">z1_constants</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.z1l_first_year_projections" href="#gcubed.projections.baseline_projections.BaselineProjections.z1l_first_year_projections">z1l_first_year_projections</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.z1r_difference_from_ssf" href="#gcubed.projections.baseline_projections.BaselineProjections.z1r_difference_from_ssf">z1r_difference_from_ssf</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.ze_constants" href="#gcubed.projections.baseline_projections.BaselineProjections.ze_constants">ze_constants</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.zer_difference_from_ssf" href="#gcubed.projections.baseline_projections.BaselineProjections.zer_difference_from_ssf">zer_difference_from_ssf</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
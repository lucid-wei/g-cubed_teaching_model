<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gcubed.projections.baseline_projections API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gcubed.projections.baseline_projections</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># ------------------------------------------------------------------
# Purpose: Compute and provide access to baseline projections.
# Author: Geoff Shuetrim
# ------------------------------------------------------------------
import logging
import os
import pandas as pd
import numpy as np
import gcubed.constants as CONSTANTS
from gcubed.stable_manifold import StableManifold
from gcubed.model import Model
from gcubed.state_space_form import StateSpaceForm
from gcubed.sym_data import SymData
from gcubed.model_parameters.parameters import Parameters
from gcubed.model_configuration import ModelConfiguration
from gcubed.data.gdp_scaled_database import GDPScaledDatabase
from gcubed.baseline.effective_labour_productivity import EffectiveLabourProductivity
from gcubed.baseline.energy_usage_efficiency import EnergyUsageEfficiency
from gcubed.projections.base_projections import BaseProjections
from gcubed.projections.simulation_layer_definitions import SimulationLayerDefinitions
from gcubed.projections.simulation_layer_definition import SimulationLayerDefinition


class BaselineProjections(BaseProjections):
    &#34;&#34;&#34;
    Compute the baseline model projections over the projection horizon 
    from the base projection year (the last year with available data)
    through to the last projection year.
    &#34;&#34;&#34;

    # The perturbation to use when computing partial derivatives for intertemporal constant determination.
    PERTURBATION = 0.0001

    def __init__(self, stable_manifold: StableManifold, simulation_layer_definitions: SimulationLayerDefinitions = None) -&gt; None:
        &#34;&#34;&#34;
        Arguments:

        stable_manifold: The stable manifold that provides access to all of the model information required to produce projections.

        simulation_layer_definitions: An optional input that provides an ordered list of simulation layer definitions 
        that can be used to augment the initial state vector and the exogenous variable projections that underpin the projections. 
        The simulation layers are ignored if they have an event year that is not equal to the base projection year.
        &#34;&#34;&#34;
        super().__init__(stable_manifold=stable_manifold)

        self._simulation_layer_definitions = simulation_layer_definitions

        self._database = GDPScaledDatabase(database=self.model.database, base_year=self.configuration.projection_base_year)

        self._event_year = self.base_year

        self.__set_base_year_observed_values()

        self.__store_observed_x1_values()

        # Set up the exogenous variable projections
        self.__create_exogenous_variable_projections()

        # Adjust the exogenous projections and initial state vector for any relevant simulation layers
        self.__apply_simulation_layers()

        self.__store_observed_values_of_variables_adjusted_by_intertemporal_constants()
        self.__compute_base_year_ssf_deviations_from_observed_values()

        if not self.using_rolled_projections:
            self.__calculate_intertemporal_constants()

        # Generate the baseline projections
        self.__generate_projections()

        # Generate the database projections
        self.generate_database_projections()

        # Generate publishable version of the projections
        self.generate_publishable_projections()

        self.__validate()

        logging.info(&#34;The baseline projections have been generated.&#34;)

    def __validate(self):
        &#34;&#34;&#34;
        TODO:  Validate the projections: 
        1. check that they are available for the expected projection years.
        2. Check that the base year projections are equal to the base year data values.
        &#34;&#34;&#34;
        pass

    @property
    def stable_manifold(self) -&gt; StableManifold:
        return self._stable_manifold

    @property
    def state_space_form(self) -&gt; StateSpaceForm:
        return self.stable_manifold.ssf

    @property
    def model(self) -&gt; Model:
        return self.state_space_form.model

    @property
    def sym_data(self) -&gt; SymData:
        return self.model.sym_data

    @property
    def parameters(self) -&gt; Parameters:
        return self.model.parameters

    @property
    def configuration(self) -&gt; ModelConfiguration:
        return self.sym_data.configuration

    @property
    def database(self) -&gt; GDPScaledDatabase:
        return self._database

    @property
    def base_year(self) -&gt; int:
        return self.configuration.projection_base_year

    @property
    def simulation_layer_definitions(self) -&gt; SimulationLayerDefinitions:
        return self._simulation_layer_definitions

    @property
    def has_simulation_layer_definitions(self) -&gt; bool:
        return (self.simulation_layer_definitions is not None)

    @property
    def using_rolled_projections(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns true if these projections are building on
        previous projections rather than just observed data.
        This affects how the baseline projections are set up in terms
        of the constants used 
        &#34;&#34;&#34;
        return self.database.has_data_for_all_projection_years

    def __update_perturbed_variable(self, variable_details: pd.Series):
        &#34;&#34;&#34;
        Change the perturbed variable, preparing for the next evaluation of the values needed to compute
        partial derivatives relevant to the determination of the intertemporal constants.
        &#34;&#34;&#34;

        if hasattr(self, &#39;_perturbed_variable_details&#39;):
            sequence = self._perturbed_variable_details[&#39;sequence&#39;]
            match self._perturbed_variable_details[&#39;var_type&#39;]:
                case &#39;x1l&#39;:
                    self.x1r_difference_from_ssf[sequence] = self._original_value
                case &#39;j1l&#39;:
                    self.j1r_difference_from_ssf[sequence] = self._original_value
                case &#39;zel&#39;:
                    self.zer_difference_from_ssf[sequence] = self._original_value
                case &#39;z1l&#39;:
                    self.z1r_difference_from_ssf[sequence] = self._original_value
            delattr(self, &#39;_original_value&#39;)

        if variable_details is None:
            delattr(self, &#39;_perturbed_variable_details&#39;)
        else:
            sequence = variable_details[&#39;sequence&#39;]
            match variable_details[&#39;var_type&#39;]:
                case &#39;x1l&#39;:
                    self._original_value = float(self.x1r_difference_from_ssf[sequence])
                    self.x1r_difference_from_ssf[sequence] = self._original_value + __class__.PERTURBATION
                case &#39;j1l&#39;:
                    self._original_value = float(self.j1r_difference_from_ssf[sequence])
                    self.j1r_difference_from_ssf[sequence] = self._original_value + __class__.PERTURBATION
                case &#39;zel&#39;:
                    self._original_value = float(self.zer_difference_from_ssf[sequence])
                    self.zer_difference_from_ssf[sequence] = self._original_value + __class__.PERTURBATION
                case &#39;z1l&#39;:
                    self._original_value = float(self.z1r_difference_from_ssf[sequence])
                    self.z1r_difference_from_ssf[sequence] = self._original_value + __class__.PERTURBATION
            self._perturbed_variable_details = variable_details

    @property
    def perturbed_variable_details(self) -&gt; pd.Series:
        &#34;&#34;&#34;
        Returns the var_map details of the variable being perturbed to as part of computing
        derivatives needed to set intertemporal constants or none if just doing projections.
        &#34;&#34;&#34;
        if hasattr(self, &#39;_perturbed_variable_details&#39;):
            return self._perturbed_variable_details
        return None

    @property
    def base_year_projections_of_variables_adjusted_by_intertemporal_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Extract the values of the variables that have been changed by the perturbation to 
        an intertemporal constant as part of computing partial derivatives for setting the
        intertemporal constants appropriately. These values are a column vector
        for the base project year only.
        &#34;&#34;&#34;
        result = np.zeros(shape=(len(self.sym_data.variables_adjusted_by_intertemporal_constants), 1))
        i = 0
        for index, adjusted_variable_details in self.sym_data.variables_adjusted_by_intertemporal_constants.iterrows():
            sequence = adjusted_variable_details[&#39;sequence&#39;]
            match adjusted_variable_details[&#39;var_type&#39;]:
                case &#39;x1l&#39;:
                    result[i, 0] = self.yxr_base_year_projections[[sequence]]
                case &#39;j1l&#39;:
                    result[i, 0] = self.yjr_base_year_projections[[sequence]]
                case &#39;zel&#39;:
                    result[i, 0] = self.exz_base_year_projections[[sequence]]
                case &#39;z1l&#39;:
                    result[i, 0] = self.z1l_base_year_projections[[sequence]]
            i += 1
        return result

    def __set_base_year_observed_values(self):
        &#34;&#34;&#34;
        Get the database values for the various vectors in the model in the projection base year.
        &#34;&#34;&#34;
        # RHS (identical to LHS) vector values to be compared to SSF calculated values
        self._base_year_x1r: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;x1r&#39;, year=self.base_year, use_neutral_real_interest_rate=True)  # t+1
        self._base_year_j1r: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;j1r&#39;, year=self.base_year, use_neutral_real_interest_rate=True)  # t+1
        self._base_year_zer: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;zer&#39;, year=self.base_year, use_neutral_real_interest_rate=True)  # t
        self._base_year_z1r: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;z1r&#39;, year=self.base_year, use_neutral_real_interest_rate=True)  # t

        # SSF RHS vector values
        self._base_year_yxr: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;yxr&#39;, year=self.base_year, use_neutral_real_interest_rate=True)  # t
        self._base_year_yjr: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;yjr&#39;, year=self.base_year, use_neutral_real_interest_rate=True)  # t
        self._base_year_exz: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;exz&#39;, year=self.base_year, use_neutral_real_interest_rate=True)  # t+1
        self._base_year_exo: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;exo&#39;, year=self.base_year, use_neutral_real_interest_rate=True)  # t

    def __store_observed_x1_values(self):
        &#34;&#34;&#34;
        Save the values of the state vector in the base projection year to use in
        initiating the projection process.
        &#34;&#34;&#34;
        self._x1_observed_values_in_base_projection_year = self.base_year_yxr.copy()

    def __store_observed_values_of_variables_adjusted_by_intertemporal_constants(self):
        &#34;&#34;&#34;
        Save the database values of the variables
        that are adjusted by intertemporal constants so that we can use
        those as the values we adjust the variables to using the intertemporal
        constants.
        &#34;&#34;&#34;
        self._base_year_observed_values_of_variables_adjusted_by_intertemporal_constants: np.ndarray = \
            np.zeros(shape=(len(self.sym_data.variables_adjusted_by_intertemporal_constants), 1))
        i = 0
        for index, adjusted_variable_details in self.sym_data.variables_adjusted_by_intertemporal_constants.iterrows():
            sequence = adjusted_variable_details[&#39;sequence&#39;]
            match adjusted_variable_details[&#39;var_type&#39;]:
                case &#39;x1l&#39;:
                    self._base_year_observed_values_of_variables_adjusted_by_intertemporal_constants[i, 0] = self.base_year_yxr[[sequence]]  # t = base year
                case &#39;j1l&#39;:
                    self._base_year_observed_values_of_variables_adjusted_by_intertemporal_constants[i, 0] = self.base_year_yjr[[sequence]]  # t = base year
                case &#39;zel&#39;:
                    self._base_year_observed_values_of_variables_adjusted_by_intertemporal_constants[i, 0] = self.base_year_exz[[
                        sequence]]  # t+1 = year after base year
                case &#39;z1l&#39;:
                    self._base_year_observed_values_of_variables_adjusted_by_intertemporal_constants[i, 0] = self.base_year_z1r[[sequence]]  # t = base year
            i += 1

    def __compute_base_year_ssf_deviations_from_observed_values(self):
        &#34;&#34;&#34;
        Compute the SSF values for the base projection year and calculate the differences from
        observed variable values for all system-determined variables (not the exogenous ones).
        See setconSYMBL.ox for details of the Ox implementation.

        Compute values for LHS variables based on RHS variable values in the projection base year 
        based on the SSF model. Then determine the difference between these LHS variables 
        (model predictions) and the actual values.

        Results are saved as data minus projections for all vectors.
        &#34;&#34;&#34;

        # No constant adjustments for differences from SSF when doing rolling baseline projections
        if self.using_rolled_projections:
            self._x1r_difference_from_ssf = np.zeros((self.sym_data.vector_length(vector_name=&#39;x1r&#39;), 1))
            self._j1r_difference_from_ssf = np.zeros((self.sym_data.vector_length(vector_name=&#39;j1r&#39;), 1))
            self._zer_difference_from_ssf = np.zeros((self.sym_data.vector_length(vector_name=&#39;zer&#39;), 1))
            self._z1r_difference_from_ssf = np.zeros((self.sym_data.vector_length(vector_name=&#39;z1r&#39;), 1))
            return

        # We got here so we must be done the initial baseline projections that require a constant adjustment
        # for the SSF differences from observed data values in the base projection year.

        self.x1l_ssf_calculations_using_base_year_data = self.state_space_form.delta(&#39;x1l&#39;, &#39;yxr&#39;) @ self.base_year_yxr + \
            self.state_space_form.delta(&#39;x1l&#39;, &#39;yjr&#39;) @ self.base_year_yjr + \
            self.state_space_form.delta(&#39;x1l&#39;, &#39;exz&#39;) @ self.base_year_exz + \
            self.state_space_form.delta(&#39;x1l&#39;, &#39;exo&#39;) @ self.base_year_exo

        self.j1l_ssf_calculations_using_base_year_data = self.state_space_form.delta(&#39;j1l&#39;, &#39;yxr&#39;) @ self.base_year_yxr + \
            self.state_space_form.delta(&#39;j1l&#39;, &#39;yjr&#39;) @ self.base_year_yjr + \
            self.state_space_form.delta(&#39;j1l&#39;, &#39;exz&#39;) @ self.base_year_exz + \
            self.state_space_form.delta(&#39;j1l&#39;, &#39;exo&#39;) @ self.base_year_exo

        self.zel_ssf_calculations_using_base_year_data = self.state_space_form.delta(&#39;zel&#39;, &#39;yxr&#39;) @ self.base_year_yxr + \
            self.state_space_form.delta(&#39;zel&#39;, &#39;yjr&#39;) @ self.base_year_yjr + \
            self.state_space_form.delta(&#39;zel&#39;, &#39;exz&#39;) @ self.base_year_exz + \
            self.state_space_form.delta(&#39;zel&#39;, &#39;exo&#39;) @ self.base_year_exo

        self.z1l_ssf_calculations_using_base_year_data = self.state_space_form.delta(&#39;z1l&#39;, &#39;yxr&#39;) @ self.base_year_yxr + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;yjr&#39;) @ self.base_year_yjr + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;exz&#39;) @ self.base_year_exz + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;exo&#39;) @ self.base_year_exo

        self._x1r_difference_from_ssf = self.base_year_x1r - self.x1l_ssf_calculations_using_base_year_data  # t+1 = year after base year
        self._j1r_difference_from_ssf = self.base_year_j1r - self.j1l_ssf_calculations_using_base_year_data  # t+1 = year after base year
        self._zer_difference_from_ssf = self.base_year_zer - self.zel_ssf_calculations_using_base_year_data  # t = base year
        self._z1r_difference_from_ssf = self.base_year_z1r - self.z1l_ssf_calculations_using_base_year_data  # t = base year

    @property
    def base_year_x1r(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        If the base year = t:
        Returns the value of x1r from the database as the value of x1 in period t+1
        &#34;&#34;&#34;
        return self._base_year_x1r

    @property
    def base_year_j1r(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        If the base year = t:
        Returns the value of j1r from the database as the value of j1 in period t+1
        &#34;&#34;&#34;
        return self._base_year_j1r

    @property
    def base_year_zer(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        If the base year = t:
        Returns the value of zer from the database as the value of x1 in period t
        &#34;&#34;&#34;
        return self._base_year_zer

    @property
    def base_year_z1r(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        If the base year = t:
        Returns the value of z1r from the database as the value of z1 in period t
        &#34;&#34;&#34;
        return self._base_year_z1r

    @property
    def base_year_yxr(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        If the base year = t:
        Returns the value of yxr from the database as the value of x1 in period t
        &#34;&#34;&#34;
        return self._base_year_yxr

    @property
    def base_year_yjr(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        If the base year = t:
        Returns the value of yjr from the database as the value of j1 in period t
        &#34;&#34;&#34;
        return self._base_year_yjr

    @property
    def base_year_exz(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        If the base year = t:
        Returns the value of exz from the database as the value of ze in period t+1
        &#34;&#34;&#34;
        return self._base_year_exz

    @property
    def base_year_exo(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        If the base year = t:
        Returns the value of exo from the database as the value of exogenous variables (exo)
        in period t
        &#34;&#34;&#34;
        return self._base_year_exo

    @property
    def x1r_difference_from_ssf(self):
        &#34;&#34;&#34;
        In Ox: decl cz2 = x1r - x1l
        &#34;&#34;&#34;
        return self._x1r_difference_from_ssf

    @property
    def j1r_difference_from_ssf(self):
        &#34;&#34;&#34;
        In Ox: decl cz4 = j1r - j1l
        &#34;&#34;&#34;
        return self._j1r_difference_from_ssf

    @property
    def zer_difference_from_ssf(self):
        &#34;&#34;&#34;
        In Ox: decl cz5 = zer - zel
        &#34;&#34;&#34;
        return self._zer_difference_from_ssf

    @property
    def z1r_difference_from_ssf(self):
        &#34;&#34;&#34;
        In Ox: decl cz6 = z1r - z1l
        &#34;&#34;&#34;
        return self._z1r_difference_from_ssf

    @property
    def x1_observed_values_in_base_projection_year(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Returns the observed values of the state variables in the base projection year.
        &#34;&#34;&#34;
        return self._x1_observed_values_in_base_projection_year

    def compute_functions_of_future_exogenous_variables(self):
        &#34;&#34;&#34;
        The rules governing the dynamic behaviour of variables depend on functions of the current and future exogenous variables.
        These functions are evaluated and the results are stored in numpy matrices that match the number of rows
        for the related vector of variables and that have a column for each year from the base projection year to the
        last year in the projections.
        &#34;&#34;&#34;

        # Set up the arrays that will be populated and initialise them to zeros.

        # // setup for baseline with optimization
        # decl id=invert(unit(nez)-c4n);
        # c4t=id*cz5;

        # decl mu2t=id*c6n;

        # id=invert(unit(njm)-ff-we*mu2t);
        # c6t=id*(cz4+we*c4t);

        # c4t=c4t+mu2t*c6t;
        # c4t=ones(rows(c4t),nobs).*c4t;
        # c6t=ones(rows(c6t),nobs).*c6t;
        # c2t=h2t*exog+c6t+bt2t*gam3t;

        # This is equivalent to h3t in the newsetsymbl.ox script (j by 1 dimensions)
        h3t: np.ndarray = np.zeros(shape=(self.sym_data.vector_length(vector_name=&#39;j1l&#39;), self.projection_years_count))

        # Populate for period T.

        # c4t=invert(unit(nez)-zel_exz_ssf)*cz5   (r by 1 dimensions)
        interim_calculation = self.stable_manifold.Gamma_rT @ self.ze_constants

        # c6t = invert(unit(j)-j1l_yjr_ssf-j1l_exz_ssf*mu2t) * (cz4+j1l_exz_ssf*c4t)
        #     = Gamma_jT (cz4+j1l_exz_ssf*interim_calculation)
        c6T_column = self.stable_manifold.Gamma_jT @ (self.j1_constants + self.state_space_form.delta(&#39;j1l&#39;, &#39;exz&#39;) @ interim_calculation)

        # c4t = c4t + mu2t * c6t (r by 1 dimensions)
        c4T_column = interim_calculation + self.stable_manifold.psi_rj @ c6T_column

        # c4t=ones(rows(c4t),nobs).*c4t (r by T dimensions)
        c4t: np.ndarray = np.tile(c4T_column, (1, self.projection_years_count))

        # c6t=ones(rows(c6t),nobs).*c6t (j by T dimensions)
        c6t: np.ndarray = np.tile(c6T_column, (1, self.projection_years_count))

        # c2t=h2t*exog+c6t    (j by T dimensions)
        c2t: np.ndarray = self.stable_manifold.H2 @ self.exo_projections + c6t

        # (s by T dimensions)
        c5t: np.ndarray = np.zeros(shape=(self.sym_data.vector_length(vector_name=&#39;x1l&#39;), self.projection_years_count))

        # (j by T dimensions)
        c2t_lead: np.ndarray = c2t.copy()
        c4t_lead: np.ndarray = c4t.copy()

        # Populate for earlier periods.
        j = self.projection_years_count-1
        for k in range(self.projection_years_count-1, -1, -1):

            # c5t[][k] = wvi*(x1l_exz_ssf*c4tl[][j] + cz2)          (s by 1 : note no need for T columns)
            c5t: np.ndarray = self.stable_manifold.Gamma_st @ (self.state_space_form.delta(&#39;x1l&#39;, &#39;exz&#39;) @ c4t_lead[:, [j]] + self.x1_constants)

            # c6t[][k] = fdeltinv*(th6t*c5t[][k] - j1l_exz_ssf*c4tl[][j] + c2tl[][j] - cz4)         (j rows)
            c6t[:, [k]] = self.stable_manifold.Gamma_jt @ (self.stable_manifold.common_factor @ c5t - self.state_space_form.delta(
                &#39;j1l&#39;, &#39;exz&#39;) @ c4t_lead[:, [j]] + c2t_lead[:, [j]] - self.j1_constants)

            # c5t[][k] = c5t[][k] + th2t*c6t[][k]
            c5t = c5t + self.stable_manifold.tau_sjt @ c6t[:, [k]]

            # c4t[][k] = mu1tl*c5t[][k] + c4tl[][j]
            c4t[:, [k]] = self.stable_manifold.M1_lead @ c5t + c4t_lead[:, [j]]

            # h3t[][k] = c6t[][k]
            h3t[:, [k]] = c6t[:, [k]].copy()

            # c2t[][k] = h2t*exog[][k] + h3t[][k]
            c2t[:, [k]] = self.stable_manifold.H2 @ self.exo_projections[:, [k]] + h3t[:, [k]]

            # c4tl[][k] = nmu4t*exog[][k] + zel_yjr_ssf*h3t[][k] + zel_exz_ssf*c4t[][k] + cz5
            c4t_lead[:, [k]] = self.stable_manifold.M2 @ self.exo_projections[:, [k]] + \
                self.state_space_form.delta(&#39;zel&#39;, &#39;yjr&#39;) @ h3t[:, [k]] + \
                self.state_space_form.delta(&#39;zel&#39;, &#39;exz&#39;) @ c4t[:, [k]] + \
                self.ze_constants

            c2t_lead = c2t.copy()

            j = k

        # Store the functions of future exogenous variables to access when doing projections.
        self._h3t = h3t.copy()
        self._c4t = c4t.copy()

    @property
    def h3t(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Equivalent to h3t in the Ox implementation
        
        Returns constants and the functions of current and future exogenous variables affecting J1.
        &#34;&#34;&#34;
        return self._h3t

    @property
    def c4t(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Equivalent to c4t in the Ox implementation
        
        Returns constants and the functions of current and future exogenous variables affecting ZE.
        &#34;&#34;&#34;
        return self._c4t

    @property
    def reference_h3t_used_to_compute_intertemporal_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Equivalent to h3t in the Ox implementation
        Functions of current and future exogenous variables affecting J1.
        This is the reference version of h3t, computed to calculation the projections
        for the base year that will be used as a reference projection when determining 
        the numeric derivatives for calculation of the intertemporal constants.

        Its only role is to preserve the appropriate information for benchmarking against Ox.
        &#34;&#34;&#34;
        return self._reference_h3t_used_to_compute_intertemporal_constants

    @property
    def reference_c4t_used_to_compute_intertemporal_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Equivalent to c4t in the Ox implementation
        Functions of current and future exogenous variables affecting ZE.
        This is the reference version of h3t, computed to calculation the projections
        for the base year that will be used as a reference projection when determining 
        the numeric derivatives for calculation of the intertemporal constants.

        Its only role is to preserve the appropriate information for benchmarking against Ox.
        &#34;&#34;&#34;
        return self._reference_c4t_used_to_compute_intertemporal_constants

    @property
    def x1_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to X1 to ensure projections equal observed values.
        Add any intertemporal constant values to the X1R difference to SSF equation 
        results with zero constants to get the combined set of constants.
        &#34;&#34;&#34;

        if hasattr(self, &#34;_x1_constants&#34;):
            return self._x1_constants

        result: np.ndarray = self.x1r_difference_from_ssf.copy()
        if not hasattr(self, &#34;intertemporal_constants&#34;):
            return result

        i = 0
        for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
            if variable_details[&#39;var_type&#39;] == &#39;x1l&#39;:
                result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
            i = i + 1

        self._x1_constants: np.ndarray = result
        return self._x1_constants

    @property
    def j1_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to J1 to ensure projections equal observed values.
        Add any intertemporal constant values to the X1R difference to SSF equation results with zero constants
        to get the combined set of constants.
        &#34;&#34;&#34;

        if hasattr(self, &#34;_j1_constants&#34;):
            return self._j1_constants

        result: np.ndarray = self.j1r_difference_from_ssf.copy()
        if not hasattr(self, &#34;intertemporal_constants&#34;):
            return result
        i = 0
        for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
            if variable_details[&#39;var_type&#39;] == &#39;j1l&#39;:
                result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
            i = i + 1

        self._j1_constants: np.ndarray = result
        return self._j1_constants

    @property
    def ze_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to ZE to ensure projections equal observed values.
        Add any intertemporal constant values to the X1R difference to SSF equation results with zero constants
        to get the combined set of constants.
        &#34;&#34;&#34;

        if hasattr(self, &#34;_ze_constants&#34;):
            return self._ze_constants

        result: np.ndarray = self.zer_difference_from_ssf.copy()
        if not hasattr(self, &#34;intertemporal_constants&#34;):
            return result

        i = 0
        for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
            if variable_details[&#39;var_type&#39;] == &#39;zel&#39;:
                logging.debug(
                    f&#34;At index {i} intertemporal constant is {self.intertemporal_constants.loc[variable_details[&#39;name&#39;],&#39;constant_value&#39;]} : shape is {self.intertemporal_constants.shape}&#34;)
                result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
            i = i + 1

        self._ze_constants: np.ndarray = result
        return self._ze_constants

    @property
    def z1_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to Z1 to ensure projections equal observed values.
        Add any intertemporal constant values to the X1R difference to SSF equation results with zero constants
        to get the combined set of constants.
        &#34;&#34;&#34;

        if hasattr(self, &#34;_z1_constants&#34;):
            return self._z1_constants

        result: np.ndarray = self.z1r_difference_from_ssf.copy()
        if not hasattr(self, &#34;intertemporal_constants&#34;):
            return result
        i = 0
        for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
            if variable_details[&#39;var_type&#39;] == &#39;z1l&#39;:
                result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
            i = i + 1

        self._z1_constants: np.ndarray = result
        return self._z1_constants

    def __create_exogenous_variable_projections(self):
        &#34;&#34;&#34;
        Populates the exogenous variable values through the projection years. 
        These values are determined outside the system.

        The rolling baseline projections just copy the exogenous values from the previous projections
        and use those as the starting point for the next round of projection generation.

        Otherwise, when initially setting up baseline projections, incorporate values from:
        - the database in the base projection year
        - effective labour productivity projections
        - energy efficiency improvement projections
        &#34;&#34;&#34;

        # If we are doing the baseline projections after rolling forward to a new base projection year,
        # just copy the database values for the exogenous variables over the projection years
        # and then we are done.
        if self.using_rolled_projections:
            matching_indices: pd.Index = self.sym_data.combined_variable_summary.loc[self.sym_data.combined_variable_summary.vector == &#39;exo&#39;, :].index
            self._exo_projections: pd.DataFrame = self.database.data.loc[matching_indices, self.configuration.base_and_projection_years_column_labels]
            return

        # We got here so we must be setting up the exogenous variable projections for the first time ...

        # Replicate projection base year values across all projection periods for all exogenous variables.
        base_year_values: np.ndarray = self.base_year_exo
        projections: pd.DataFrame = pd.DataFrame(np.tile(base_year_values, (1, self.configuration.base_and_projection_year_count)))
        projections.columns = self.configuration.base_and_projection_years_column_labels
        projections.reset_index()

        # Add effective labour productivity and energy usage efficiency.
        effective_labour_productivity: EffectiveLabourProductivity = self.model.effective_labour_productivity
        rogy: pd.DataFrame = effective_labour_productivity.rogy
        energy_usage_efficiency: EnergyUsageEfficiency = self.model.energy_usage_efficiency
        for region in self.sym_data.regions_members:

            regional_effective_labour_productivity: pd.DataFrame = effective_labour_productivity.effective_productivity_deviations(region=region)
            regional_energy_usage_efficiency: pd.DataFrame = energy_usage_efficiency.sector_cumulative_energy_usage_efficiency_gains(region=region)
            consumption_energy_usage_efficiency: pd.DataFrame = energy_usage_efficiency.consumption_cumulative_energy_usage_efficiency_gains

            variable_prefix_ROGY: str = f&#34;ROGY&#34;
            rogy_name: str = f&#34;{variable_prefix_ROGY}({region})&#34;
            if self.sym_data.has_variables(variable_name_prefix=rogy_name):
                rogy_index: int = self.sym_data.variable_index(vector_name=&#39;exo&#39;, variable_name=rogy_name)
                rogy_units = self.sym_data.variable_units(vector_name=&#39;exo&#39;, variable_name_prefix=variable_prefix_ROGY)
                rogy_data: pd.DataFrame = rogy.loc[[region], self.configuration.base_and_projection_years_column_labels]
                if &#39;gdp&#39; in rogy_units:
                    raise Exception(f&#34;{rogy_name} has gdp units so shocks to that variable are not supported.&#34;)

                projections.loc[[rogy_index], :] = projections.loc[[rogy_index], :] + (rogy_data.to_numpy().flatten() / 100)
            # else:
            #     logging.warning(f&#34;{rogy_name} is not in the SYM model.&#34;)

            shefc_name_prefix: str = f&#34;SHEFC&#34;
            shefc_name: str = f&#34;{shefc_name_prefix}({region})&#34;
            if self.sym_data.has_variables(variable_name_prefix=shefc_name_prefix):
                shefc_index: int = self.sym_data.variable_index(vector_name=&#39;exo&#39;, variable_name=shefc_name)
                shefc_units = self.sym_data.variable_units(vector_name=&#39;exo&#39;, variable_name_prefix=shefc_name_prefix)
                shefc_data: pd.DataFrame = consumption_energy_usage_efficiency.loc[[region], self.configuration.base_and_projection_years_column_labels]
                if &#39;gdp&#39; in shefc_units:
                    raise Exception(f&#34;{shefc_name} has gdp units so shocks to that variable are not supported.&#34;)
                projections.loc[[shefc_index], :] = projections.loc[[shefc_index], :] + (shefc_data.to_numpy().flatten() / 100)
            # else:
            #     logging.warning(f&#34;{shefc_name} is not in the SYM model.&#34;)

            variable_prefix_SHL: str = &#39;SHL&#39;
            variable_prefix_SHEF: str = &#39;SHEF&#39;
            for sector in self.sym_data.sectors_members:

                shl_name: str = f&#34;{variable_prefix_SHL}({region},{sector})&#34;
                if self.sym_data.has_variables(variable_name_prefix=shl_name):
                    shl_index: int = self.sym_data.variable_index(vector_name=&#39;exo&#39;, variable_name=shl_name)
                    shl_units = self.sym_data.variable_units(vector_name=&#39;exo&#39;, variable_name_prefix=variable_prefix_SHL)
                    shl_data: pd.DataFrame = regional_effective_labour_productivity.loc[[sector], self.configuration.base_and_projection_years_column_labels]
                    if &#39;gdp&#39; in shl_units:
                        raise Exception(f&#34;{shl_name} has gdp units so shocks to that variable are not supported.&#34;)
                    projections.loc[[shl_index], :] = projections.loc[[
                        shl_index], :] + (shl_data.to_numpy().flatten() / 100)
                # else:
                #     logging.warning(f&#34;{shl_name} is not in the SYM model.&#34;)

                shef_name: str = f&#34;{variable_prefix_SHEF}({sector},{region})&#34;
                if self.sym_data.has_variables(variable_name_prefix=shef_name):
                    shef_index: int = self.sym_data.variable_index(vector_name=&#39;exo&#39;, variable_name=shef_name)
                    shef_units = self.sym_data.variable_units(vector_name=&#39;exo&#39;, variable_name_prefix=variable_prefix_SHEF)
                    shef_data: pd.DataFrame = regional_energy_usage_efficiency.loc[[sector], self.configuration.base_and_projection_years_column_labels]
                    if &#39;gdp&#39; in shef_units:
                        raise Exception(f&#34;{shef_name} has gdp units so shocks to that variable are not supported.&#34;)
                    projections.loc[[shef_index], :] = projections.loc[[shef_index], :] + (shef_data.to_numpy().flatten() / 100)
                # else:
                #     logging.warning(f&#34;{shef_shock_name} is not in the SYM model.&#34;)

            # THIS IS OBSOLETE.
            # See https://bitbucket.org/msgpl/gcubedcode/issues/140/prodmat-file-for-20r-is-missing-some
            # for sector in self.sym_data.capital_sectors_members:
            #     variable_prefix_SHL_capital = f&#34;SHL{sector}&#34;
            #     shl_name: str = f&#34;{variable_prefix_SHL_capital}({region})&#34;
            #     if self.sym_data.has_variables(variable_name_prefix=variable_prefix_SHL_capital):
            #         shl_index: int = self.sym_data.variable_index(vector_name=&#39;exo&#39;, variable_name=shl_name)
            #         shl_units = self.sym_data.variable_units(vector_name=&#39;exo&#39;, variable_name_prefix=variable_prefix_SHL_capital)
            #         shl_data: pd.DataFrame = regional_effective_labour_productivity.loc[[sector], self.configuration.base_and_projection_years_column_labels]
            #         if &#39;gdp&#39; in shl_units:
            #             raise Exception(f&#34;{shl_name} has gdp units so shocks to that variable are not supported.&#34;)
            #         projections.loc[[shl_index], :] = projections.loc[[shl_index], :] + (shl_data.to_numpy().flatten() / 100)
            #     # else:
            #     #     logging.warning(f&#34;{shl_name} is not in the SYM model.&#34;)

        # Index with variable names.
        projections.index = self.sym_data.vector_variable_names(vector_name=&#39;exo&#39;)

        # Store the exogenous projections that will be augmented for other projections.
        self._exo_projections: pd.DataFrame = projections

    def __apply_simulation_layers(self):
        &#34;&#34;&#34;
        Apply adjustments to exogenous variables and any state variables for any simulation layers
        that have their event year matching the base year of these baseline projections.
        &#34;&#34;&#34;

        if not self.has_simulation_layer_definitions:
            return
        for simulation_layer_definition in self.simulation_layer_definitions:
            self.__apply_simulation_layer(simulation_layer_definition=simulation_layer_definition)

    def __apply_simulation_layer(self, simulation_layer_definition: SimulationLayerDefinition):
        &#34;&#34;&#34;
        Apply adjustments to exogenous variables and any state variables for the given simulation layer
        &#34;&#34;&#34;
        if simulation_layer_definition.event_year != self.base_year:
            return

        filename: str = simulation_layer_definition.data_filename
        assert os.path.isfile(filename)
        (self._simulation_variables, self._simulation_data) = self.load_data(filename)
        self._simulation_variables.columns = [&#39;name&#39;]
        self._simulation_variables.index = self._simulation_variables.name
        self._simulation_data = self._simulation_data.astype(float)
        self._simulation_data.index = self._simulation_variables.name
        try:
            self._simulation_data = self._simulation_data.loc[:, self.configuration.base_and_projection_years_column_labels]
        except:
            raise Exception(f&#34;The simulation data in {self.simulation_file} should have data from {self.event_year} to {self.end_year}&#34;)
        yratr: pd.DataFrame = self.database.get_data(name_regular_expression=f&#34;^{CONSTANTS.US_REAL_GDP_RATIO_PREFIX}\(&#34;, years=[self.base_year])
        yratr.index = self.sym_data.regions_members

        for variable_name in self._simulation_variables.index:
            variable_region: str = str(self.database.variables.loc[variable_name, &#39;region&#39;])
            variable_units: str = str(self.sym_data.combined_variable_summary.loc[variable_name, &#39;units&#39;])
            data: pd.DataFrame = self._simulation_data.loc[[variable_name], :] / 100
            vector_name = self.sym_data.projection_vector_for_variable(variable_name=variable_name)
            yratr_for_region: float = float(yratr.loc[variable_region, :])
            match variable_units:
                case &#39;gdp&#39;:
                    data = data * yratr_for_region
                case &#39;mmgdp&#39;:
                    data = data * yratr_for_region
                case &#39;btugdp&#39;:
                    data = data * yratr_for_region
                case &#39;gwhgdp&#39;:
                    data = data * yratr_for_region
                case _:
                    pass

            match vector_name:
                case &#39;exo&#39;:
                    self.exo_projections_as_dataframe.loc[[variable_name], self.configuration.base_and_projection_years_column_labels] += data
                    pass

                case &#39;x1l&#39;:
                    self.x1_observed_values_in_base_projection_year.loc[[variable_name], [str(self.base_year)]] += float(data[0])
                    pass

    def __evaluate_base_year_vector_projections(self):
        &#34;&#34;&#34;
        Computes the values of the model equation vectors in the first period of the projection, 
        using the functions of future exogenous variables, the stable manifold, and ...
        &#34;&#34;&#34;

        self._exo_base_year_projections = self.exo_projections[:, [0]]

        self._yxr_base_year_projections = self.x1_observed_values_in_base_projection_year.copy()

        # er = h1t*x[][1] + h2t*exog[][1] + h3t[][1];
        self._yjr_base_year_projections = \
            self.stable_manifold.H1 @ self.yxr_base_year_projections + \
            self.stable_manifold.H2 @ self.exo_base_year_projections + \
            self._h3t[:, [0]]

        # tzl = mu1t*x[][1] + mu4t*exog[][1] + c4t[][1];
        self._exz_base_year_projections = \
            self.stable_manifold.mu1 @ self.yxr_base_year_projections + \
            self.stable_manifold.mu2 @ self.exo_base_year_projections + \
            self._c4t[:, [0]]

        # z1l projections = d5n*x[][1]+d7n*exog[][1]+d6n*er+d4n*tzl+cz6[][1]
        self._z1l_base_year_projections = \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;yxr&#39;) @ self.yxr_base_year_projections + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;exo&#39;) @ self.exo_base_year_projections + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;yjr&#39;) @ self.yjr_base_year_projections + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;exz&#39;) @ self.exz_base_year_projections + \
            self.z1r_difference_from_ssf

    @property
    def yxr_base_year_projections(self):
        &#34;&#34;&#34;
        Projections of X1_t (yxr) in the base year
        &#34;&#34;&#34;
        return self._yxr_base_year_projections

    @property
    def yjr_base_year_projections(self):
        &#34;&#34;&#34;
        Projections of J1_t (yjr) in the base year
        &#34;&#34;&#34;
        return self._yjr_base_year_projections

    @property
    def exz_base_year_projections(self):
        &#34;&#34;&#34;
        Projections of ZE_t (exz) in the base year
        &#34;&#34;&#34;
        return self._exz_base_year_projections

    @property
    def z1l_base_year_projections(self):
        &#34;&#34;&#34;
        Projections of Z1_t (z1l=z1r) in the base year
        &#34;&#34;&#34;
        return self._z1l_base_year_projections

    @property
    def exo_base_year_projections(self):
        &#34;&#34;&#34;
        Projections of EXO_t in the base year
        &#34;&#34;&#34;
        return self._exo_base_year_projections

    @property
    def base_year_original_projections_of_variables_adjusted_by_intertemporal_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The base year projected values for the variables that are being
        adjusted by the intertemporal constants.

        The values are those for the projection that is not adjusted by intertemporal constants.
        &#34;&#34;&#34;
        return self._base_year_original_projections_of_variables_adjusted_by_intertemporal_constants

    @property
    def base_year_original_projections_of_yxr(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The base year projected values for the state variables.
        Required for benchmarking against Ox.
        &#34;&#34;&#34;
        return self._base_year_original_projections_of_yxr

    @property
    def base_year_original_projections_of_yjr(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The base year projected values for the costate variables.
        Required for benchmarking against Ox.
        &#34;&#34;&#34;
        return self._base_year_original_projections_of_yjr

    @property
    def base_year_original_projections_of_exz(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The base year projected values for the expected endogenous variables exz.
        Required for benchmarking against Ox.
        &#34;&#34;&#34;
        return self._base_year_original_projections_of_exz

    @property
    def base_year_original_projections_of_z1l(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The base year projected values for the endogenous variables.
        Required for benchmarking against Ox.
        &#34;&#34;&#34;
        return self._base_year_original_projections_of_z1l

    @property
    def base_year_observed_values_of_variables_adjusted_by_intertemporal_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Returns the observed values in the base projection year of the 
        variables that are adjusted by intertemporal constants.
        &#34;&#34;&#34;
        return self._base_year_observed_values_of_variables_adjusted_by_intertemporal_constants

    @property
    def base_year_lhs_values(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Values selected from base year SSF-generated LHS vectors using RHS vector values as inputs.
        &#34;&#34;&#34;
        return self._base_year_lhs_values

    @property
    def intertemporal_constants(self) -&gt; pd.DataFrame:
        return self._intertemporal_constants

    @property
    def partial_derivatives_wrt_intertemporal_constants(self) -&gt; np.ndarray:
        return self._partial_derivatives

    def __calculate_intertemporal_constants(self):
        &#34;&#34;&#34;
        Computes the intertemporal constant adjustments to jump and other variables to align starting data
        values with model projections in the first year.

        Step 1.
        Compute functions of future exogenous variables through all years of the projection.

        Step 2.
        For the variables that are to be adjusted by the intertemporal
        constants, compute their projected values in the base projection year
        and store these values for comparison to perturbed base year projections so we can calculate
        the derivatives matrix needed to set the intertemporal constants.
        Also store the values of each of the 4 vectors in the model in the base year for benchmarking.

        Step 3.
        Initialise the partial derivatives matrix. This is the matrix of derivatives of each of the
        variables that is adjusted by intertemporal constants, with respect to each of the intertemporal
        constants.
        Iterate over the intertemporal constants, perturbing each and recalculating the base year projections
        of the variables that are adjusted by intertemporal constants so that we can 
        estimate the relevant numeric derivatives.
        &#34;&#34;&#34;

        # Step 1.
        self.compute_functions_of_future_exogenous_variables()
        self._reference_c4t_used_to_compute_intertemporal_constants = self.c4t.copy()
        self._reference_h3t_used_to_compute_intertemporal_constants = self.h3t.copy()

        # Step 2.
        self.__evaluate_base_year_vector_projections()
        self._base_year_original_projections_of_yxr = self.yxr_base_year_projections.copy()
        self._base_year_original_projections_of_yjr = self.yjr_base_year_projections.copy()
        self._base_year_original_projections_of_exz = self.exz_base_year_projections.copy()
        self._base_year_original_projections_of_z1l = self.z1l_base_year_projections.copy()
        self._base_year_original_projections_of_variables_adjusted_by_intertemporal_constants = \
            self.base_year_projections_of_variables_adjusted_by_intertemporal_constants.copy()

        # Step 3.
        self._partial_derivatives = np.zeros(shape=(len(self.sym_data.intertemporal_constant_variables), len(
            self.sym_data.variables_adjusted_by_intertemporal_constants)))
        i = 0
        for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
            self.__update_perturbed_variable(variable_details=variable_details)
            self.compute_functions_of_future_exogenous_variables()
            self.__evaluate_base_year_vector_projections()
            self._partial_derivatives[:, [i]] = (
                self.base_year_projections_of_variables_adjusted_by_intertemporal_constants -
                self._base_year_original_projections_of_variables_adjusted_by_intertemporal_constants) \
                / __class__.PERTURBATION
            i += 1

        # Get the unperturbed values of the start year variables

        # Generate the baseline projection to use in computing partial derivatives
        # and to generate matrix values that are used later in projection processes.
        self.__update_perturbed_variable(variable_details=None)

        # Use newtons method adjustment to compute intertemporal constant values
        self._intertemporal_constants = self.sym_data.intertemporal_constant_variables
        values: np.ndarray = np.linalg.inv(self._partial_derivatives) @ \
            (self.base_year_observed_values_of_variables_adjusted_by_intertemporal_constants -
             self.base_year_original_projections_of_variables_adjusted_by_intertemporal_constants)
        values = values.reshape((len(self.intertemporal_constants.index), 1))
        self._intertemporal_constants[&#39;constant_value&#39;] = values
        logging.info(&#34;The intertemporal constants have been calibrated.&#34;)

    def __generate_projections(self):
        &#34;&#34;&#34;
        Implements the projection logic in msgsimBL.ox. This runs the various equations
        to project variables based on the starting state vector and the values of
        exogenous variables in all years. The steps are as follows:

        Step 1.
        Recalculate the functions of future exogenous variables, incorporating 
        the updated exogenous variable projections and all constant adjustments: 
        the intertemporal constants and the other constants  capturing the difference 
        between the SSF equation results in the base year and the observed 
        values in the base year.
        
        Step 2.
        Project the state vector. (x_t+1 as a function of x_t and exogenous variables and constant adjustments)
        This uses the Anew and Znew matrices computed as part of getting the stable manifold.

        Step 3. 
        Combine all variable projections into a single data frame.

        Step 4.
        Sort the variables in the projection dataframe into the same order as the original database.
        &#34;&#34;&#34;

        # Step 1.
        self.compute_functions_of_future_exogenous_variables()

        # Step 2.
        constantBL: pd.DataFrame = pd.DataFrame(
            self.stable_manifold.Znew @ self.exo_projections +
            self.state_space_form.delta(&#39;x1l&#39;, &#39;yjr&#39;) @ self.h3t +
            self.state_space_form.delta(&#39;x1l&#39;, &#39;exz&#39;) @ self.c4t +
            self.x1_constants)
        constantBL.columns = self.configuration.base_and_projection_years_column_labels
        constantBL.index = self.sym_data.vector_variable_names(vector_name=&#39;x1l&#39;)
        yxr: pd.DataFrame = pd.DataFrame(index=self.sym_data.vector_variable_names(vector_name=&#39;x1l&#39;),
                                         columns=self.configuration.base_and_projection_years_column_labels)
        yxr.loc[:, [str(self.configuration.projection_base_year)]] = self.x1_observed_values_in_base_projection_year
        previous_year_label = str(self.configuration.projection_base_year)
        for year in self.configuration.projection_years_column_labels:
            yxr.loc[:, [year]] = self.stable_manifold.Anew @ yxr.loc[:, [previous_year_label]].to_numpy() + constantBL.loc[:, [previous_year_label]].to_numpy()
            previous_year_label = year
        self._yxr_projections = yxr

        # Project J1
        # er = h1t*x + h2t*exog[][1:nobs] + h3t
        # yjr: pd.DataFrame = pd.DataFrame(self.stable_manifold.H1 @ (yxr.to_numpy()))
        yjr: pd.DataFrame = pd.DataFrame(self.stable_manifold.H1 @ (yxr.to_numpy()) + self.stable_manifold.H2 @ self.exo_projections + self._h3t)
        yjr.columns = self.configuration.base_and_projection_years_column_labels
        yjr.index = self.sym_data.vector_variable_names(vector_name=&#39;j1l&#39;)
        self._yjr_projections = yjr

        # Project time t expected value of ZE in period t+1 (EXZ)
        # Project time t expected value of ZE in period t+1 (EXZ)
        # tzl = mu1t*x + mu4t*exog[][1:nobs] + c4t
        exz: pd.DataFrame = pd.DataFrame(
            self.stable_manifold.mu1 @ yxr.to_numpy() +
            self.stable_manifold.mu2 @ self.exo_projections +
            self._c4t
        )
        exz.columns = self.configuration.base_and_projection_years_column_labels
        exz.index = self.sym_data.vector_variable_names(vector_name=&#39;zer&#39;)
        self._exz_projections = exz

        # Project time t values of ZE using the SSF equation (this should be done with M1 and M2?)
        # What about the functions of future exogenous variables and the constant adjustments
        zel: pd.DataFrame = pd.DataFrame(
            self.state_space_form.delta(&#39;zel&#39;, &#39;yxr&#39;) @ self.yxr_projections +
            self.state_space_form.delta(&#39;zel&#39;, &#39;exz&#39;) @ self.exz_projections +
            self.state_space_form.delta(&#39;zel&#39;, &#39;yjr&#39;) @ self.yjr_projections +
            self.state_space_form.delta(&#39;zel&#39;, &#39;exo&#39;) @ self.exo_projections)
        zel.columns = self.configuration.base_and_projection_years_column_labels
        zel.index = self.sym_data.vector_variable_names(vector_name=&#39;zel&#39;)
        self._zel_projections = zel + self.ze_constants

        # Project Z1 using the SSF equation
        z1l: pd.DataFrame = pd.DataFrame(
            self.state_space_form.delta(&#39;z1l&#39;, &#39;yxr&#39;) @ self.yxr_projections +
            self.state_space_form.delta(&#39;z1l&#39;, &#39;exz&#39;) @ self.exz_projections +
            self.state_space_form.delta(&#39;z1l&#39;, &#39;yjr&#39;) @ self.yjr_projections +
            self.state_space_form.delta(&#39;z1l&#39;, &#39;exo&#39;) @ self.exo_projections)
        z1l.columns = self.configuration.base_and_projection_years_column_labels
        z1l.index = self.sym_data.vector_variable_names(vector_name=&#39;z1l&#39;)
        self._z1l_projections = z1l + self.z1_constants

        # Combine the projections into a single dataframe in the same order as the database
        self._projections = pd.concat([
            self.yxr_projections_as_dataframe,
            self.z1l_projections_as_dataframe,
            self.zel_projections_as_dataframe,
            self.yjr_projections_as_dataframe,
            self.exo_projections_as_dataframe])
        database_ordered_variable_list: pd.DataFrame = self.database.variables.name
        self._projections = pd.concat([database_ordered_variable_list, self._projections], axis=1)
        self._projections.drop(&#39;name&#39;, inplace=True, axis=1)

        # timeshift forward the special state variables by 1 period.
        for variable_name_prefix in CONSTANTS.STATE_LEAD_VARIABLES:
            matching_variables = self._projections.index.str.startswith(variable_name_prefix)
            self._projections.iloc[matching_variables, 0:-2] = self._projections.iloc[matching_variables, 1:-1]
            self._projections.iloc[matching_variables, -1] = 0  # TODO: Once we are past benchmarking against Ox, set this equal to NaN.

        self._projections = self._projections.astype(float)

    @property
    def publishable_data(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Transforms the data so that it can be compared with publishable projections.

        Step 1.
        Get a copy of the raw data.

        Step 2.
        Divide the projections by YRATR/100 in the projection base year for every variable that has units of:
            gdp
            mmtgdp
            btugdp
            gwhgdp

        Step 3.
        Multiply values by 100

        Step 4.
        Get LGDPR data in the projection base year for each region and apply labgrow growth rates to translate
        across database years.

        Step 5.
        For all projections with units equal to usgdp, multiply the projection by the US LGDPR projection computed in step 4.

        Step 6.
        For all projections with units equal to &#39;gdp&#39;, multiply the projection by the associated
        region&#39;s LGDPR projection computed in step 4.

        These publishable projections should then be associated with the publication_units of measurement
        available from the sym_data variable summary.
        The units changes are as follows:
            del -&gt; pct
            pct -&gt; Index
            mmtgdp -&gt; mmt
            btugdp -&gt; btu
            gwhgdp -&gt; gwh
            mmtusgdp -&gt; mmt
            btuusgdp -&gt; btu
            usgdp -&gt; $US Bil
            gdp -&gt; $US Bil

        Saves the result in the _publishable_data property.

        &#34;&#34;&#34;

        # Step 1.
        publication_data: pd.DataFrame = self.database.data.copy()

        # Step 2.
        yratr_data: pd.DataFrame = self.database.data.loc[self.database.variables.name.str.startswith(&#34;YRATR(&#34;), str(self.configuration.base_year)].copy()
        yratr_data.index = self.sym_data.regions_members
        for variable_name in publication_data.index:
            units: str = str(self.database.variables.loc[variable_name, &#39;units&#39;])
            match units:
                case &#39;gdp&#39; | &#39;btugdp&#39; | &#39;mmtgdp&#39; | &#39;gwhgdp&#39;:
                    variable_region: str = str(self.database.variables.loc[variable_name, &#39;region&#39;])
                    factor: float = yratr_data.loc[variable_region]
                    publication_data.loc[[variable_name], :] /= factor

        # Step 3.
        publication_data *= 100.0

        # Step 4.
        # TODO: refactor out this calculation so it is not being done each time we convert to publishable projections
        lgdpr_in_base_year: pd.DataFrame = self.database.data.loc[self.database.variables.name.str.startswith(&#34;LGDPR(&#34;), [str(self.base_year)]].copy() / 100
        us_long_run_growth_rate: float = float(self.parameters.parameter(parameter_name=&#34;labgrow&#34;).loc[:, self.sym_data.us_region].values[0])
        scale_factor = pd.DataFrame(index=[&#39;values&#39;], columns=self.database.data.columns)
        scale_factor.loc[&#39;values&#39;, str(self.configuration.projection_base_year)] = 1
        for year in range(self.configuration.projection_base_year+1, int(self.database.data.columns[-1]) + 1):
            scale_factor.loc[&#39;values&#39;, str(year)] = scale_factor.loc[&#39;values&#39;, str(year-1)] * (1+us_long_run_growth_rate)
        for year in range(self.configuration.projection_base_year-1, int(self.database.data.columns[0]) - 1, -1):
            scale_factor.loc[&#39;values&#39;, str(year)] = scale_factor.loc[&#39;values&#39;, str(year+1)] / (1+us_long_run_growth_rate)
        lgdpr_data: pd.DataFrame = pd.DataFrame(lgdpr_in_base_year.values * scale_factor.values)
        lgdpr_data.index = self.sym_data.regions_members
        lgdpr_data.columns = publication_data.columns

        # Step 5 and 6.
        for variable_name in publication_data.index:
            variable_units: str = str(self.database.variables.loc[variable_name, &#39;units&#39;])
            match variable_units:
                case &#39;usgdp&#39;:
                    publication_data.loc[[variable_name], :] *= lgdpr_data.loc[[CONSTANTS.USA_REGION_CODE], :].values
                case &#39;mmtusgdp&#39;:
                    publication_data.loc[[variable_name], :] *= lgdpr_data.loc[[CONSTANTS.USA_REGION_CODE], :].values
                case &#39;btuusgdp&#39;:
                    publication_data.loc[[variable_name], :] *= lgdpr_data.loc[[CONSTANTS.USA_REGION_CODE], :].values
                case &#39;gdp&#39;:
                    variable_region: str = str(self.database.variables.loc[variable_name, &#39;region&#39;])
                    publication_data.loc[[variable_name], :] *= lgdpr_data.loc[[variable_region], :].values
                case &#39;mmtgdp&#39;:
                    variable_region: str = str(self.database.variables.loc[variable_name, &#39;region&#39;])
                    publication_data.loc[[variable_name], :] *= lgdpr_data.loc[[variable_region], :].values
                case &#39;btugdp&#39;:
                    variable_region: str = str(self.database.variables.loc[variable_name, &#39;region&#39;])
                    publication_data.loc[[variable_name], :] *= lgdpr_data.loc[[variable_region], :].values
                case &#39;gwhgdp&#39;:
                    variable_region: str = str(self.database.variables.loc[variable_name, &#39;region&#39;])
                    publication_data.loc[[variable_name], :] *= lgdpr_data.loc[[variable_region], :].values

        return publication_data.astype(float)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gcubed.projections.baseline_projections.BaselineProjections"><code class="flex name class">
<span>class <span class="ident">BaselineProjections</span></span>
<span>(</span><span>stable_manifold: <a title="gcubed.stable_manifold.StableManifold" href="../stable_manifold.html#gcubed.stable_manifold.StableManifold">StableManifold</a>, simulation_layer_definitions: <a title="gcubed.projections.simulation_layer_definitions.SimulationLayerDefinitions" href="simulation_layer_definitions.html#gcubed.projections.simulation_layer_definitions.SimulationLayerDefinitions">SimulationLayerDefinitions</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the baseline model projections over the projection horizon
from the base projection year (the last year with available data)
through to the last projection year.</p>
<p>Arguments:</p>
<p>stable_manifold: The stable manifold that provides access to all of the model information required to produce projections.</p>
<p>simulation_layer_definitions: An optional input that provides an ordered list of simulation layer definitions
that can be used to augment the initial state vector and the exogenous variable projections that underpin the projections.
The simulation layers are ignored if they have an event year that is not equal to the base projection year.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaselineProjections(BaseProjections):
    &#34;&#34;&#34;
    Compute the baseline model projections over the projection horizon 
    from the base projection year (the last year with available data)
    through to the last projection year.
    &#34;&#34;&#34;

    # The perturbation to use when computing partial derivatives for intertemporal constant determination.
    PERTURBATION = 0.0001

    def __init__(self, stable_manifold: StableManifold, simulation_layer_definitions: SimulationLayerDefinitions = None) -&gt; None:
        &#34;&#34;&#34;
        Arguments:

        stable_manifold: The stable manifold that provides access to all of the model information required to produce projections.

        simulation_layer_definitions: An optional input that provides an ordered list of simulation layer definitions 
        that can be used to augment the initial state vector and the exogenous variable projections that underpin the projections. 
        The simulation layers are ignored if they have an event year that is not equal to the base projection year.
        &#34;&#34;&#34;
        super().__init__(stable_manifold=stable_manifold)

        self._simulation_layer_definitions = simulation_layer_definitions

        self._database = GDPScaledDatabase(database=self.model.database, base_year=self.configuration.projection_base_year)

        self._event_year = self.base_year

        self.__set_base_year_observed_values()

        self.__store_observed_x1_values()

        # Set up the exogenous variable projections
        self.__create_exogenous_variable_projections()

        # Adjust the exogenous projections and initial state vector for any relevant simulation layers
        self.__apply_simulation_layers()

        self.__store_observed_values_of_variables_adjusted_by_intertemporal_constants()
        self.__compute_base_year_ssf_deviations_from_observed_values()

        if not self.using_rolled_projections:
            self.__calculate_intertemporal_constants()

        # Generate the baseline projections
        self.__generate_projections()

        # Generate the database projections
        self.generate_database_projections()

        # Generate publishable version of the projections
        self.generate_publishable_projections()

        self.__validate()

        logging.info(&#34;The baseline projections have been generated.&#34;)

    def __validate(self):
        &#34;&#34;&#34;
        TODO:  Validate the projections: 
        1. check that they are available for the expected projection years.
        2. Check that the base year projections are equal to the base year data values.
        &#34;&#34;&#34;
        pass

    @property
    def stable_manifold(self) -&gt; StableManifold:
        return self._stable_manifold

    @property
    def state_space_form(self) -&gt; StateSpaceForm:
        return self.stable_manifold.ssf

    @property
    def model(self) -&gt; Model:
        return self.state_space_form.model

    @property
    def sym_data(self) -&gt; SymData:
        return self.model.sym_data

    @property
    def parameters(self) -&gt; Parameters:
        return self.model.parameters

    @property
    def configuration(self) -&gt; ModelConfiguration:
        return self.sym_data.configuration

    @property
    def database(self) -&gt; GDPScaledDatabase:
        return self._database

    @property
    def base_year(self) -&gt; int:
        return self.configuration.projection_base_year

    @property
    def simulation_layer_definitions(self) -&gt; SimulationLayerDefinitions:
        return self._simulation_layer_definitions

    @property
    def has_simulation_layer_definitions(self) -&gt; bool:
        return (self.simulation_layer_definitions is not None)

    @property
    def using_rolled_projections(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns true if these projections are building on
        previous projections rather than just observed data.
        This affects how the baseline projections are set up in terms
        of the constants used 
        &#34;&#34;&#34;
        return self.database.has_data_for_all_projection_years

    def __update_perturbed_variable(self, variable_details: pd.Series):
        &#34;&#34;&#34;
        Change the perturbed variable, preparing for the next evaluation of the values needed to compute
        partial derivatives relevant to the determination of the intertemporal constants.
        &#34;&#34;&#34;

        if hasattr(self, &#39;_perturbed_variable_details&#39;):
            sequence = self._perturbed_variable_details[&#39;sequence&#39;]
            match self._perturbed_variable_details[&#39;var_type&#39;]:
                case &#39;x1l&#39;:
                    self.x1r_difference_from_ssf[sequence] = self._original_value
                case &#39;j1l&#39;:
                    self.j1r_difference_from_ssf[sequence] = self._original_value
                case &#39;zel&#39;:
                    self.zer_difference_from_ssf[sequence] = self._original_value
                case &#39;z1l&#39;:
                    self.z1r_difference_from_ssf[sequence] = self._original_value
            delattr(self, &#39;_original_value&#39;)

        if variable_details is None:
            delattr(self, &#39;_perturbed_variable_details&#39;)
        else:
            sequence = variable_details[&#39;sequence&#39;]
            match variable_details[&#39;var_type&#39;]:
                case &#39;x1l&#39;:
                    self._original_value = float(self.x1r_difference_from_ssf[sequence])
                    self.x1r_difference_from_ssf[sequence] = self._original_value + __class__.PERTURBATION
                case &#39;j1l&#39;:
                    self._original_value = float(self.j1r_difference_from_ssf[sequence])
                    self.j1r_difference_from_ssf[sequence] = self._original_value + __class__.PERTURBATION
                case &#39;zel&#39;:
                    self._original_value = float(self.zer_difference_from_ssf[sequence])
                    self.zer_difference_from_ssf[sequence] = self._original_value + __class__.PERTURBATION
                case &#39;z1l&#39;:
                    self._original_value = float(self.z1r_difference_from_ssf[sequence])
                    self.z1r_difference_from_ssf[sequence] = self._original_value + __class__.PERTURBATION
            self._perturbed_variable_details = variable_details

    @property
    def perturbed_variable_details(self) -&gt; pd.Series:
        &#34;&#34;&#34;
        Returns the var_map details of the variable being perturbed to as part of computing
        derivatives needed to set intertemporal constants or none if just doing projections.
        &#34;&#34;&#34;
        if hasattr(self, &#39;_perturbed_variable_details&#39;):
            return self._perturbed_variable_details
        return None

    @property
    def base_year_projections_of_variables_adjusted_by_intertemporal_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Extract the values of the variables that have been changed by the perturbation to 
        an intertemporal constant as part of computing partial derivatives for setting the
        intertemporal constants appropriately. These values are a column vector
        for the base project year only.
        &#34;&#34;&#34;
        result = np.zeros(shape=(len(self.sym_data.variables_adjusted_by_intertemporal_constants), 1))
        i = 0
        for index, adjusted_variable_details in self.sym_data.variables_adjusted_by_intertemporal_constants.iterrows():
            sequence = adjusted_variable_details[&#39;sequence&#39;]
            match adjusted_variable_details[&#39;var_type&#39;]:
                case &#39;x1l&#39;:
                    result[i, 0] = self.yxr_base_year_projections[[sequence]]
                case &#39;j1l&#39;:
                    result[i, 0] = self.yjr_base_year_projections[[sequence]]
                case &#39;zel&#39;:
                    result[i, 0] = self.exz_base_year_projections[[sequence]]
                case &#39;z1l&#39;:
                    result[i, 0] = self.z1l_base_year_projections[[sequence]]
            i += 1
        return result

    def __set_base_year_observed_values(self):
        &#34;&#34;&#34;
        Get the database values for the various vectors in the model in the projection base year.
        &#34;&#34;&#34;
        # RHS (identical to LHS) vector values to be compared to SSF calculated values
        self._base_year_x1r: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;x1r&#39;, year=self.base_year, use_neutral_real_interest_rate=True)  # t+1
        self._base_year_j1r: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;j1r&#39;, year=self.base_year, use_neutral_real_interest_rate=True)  # t+1
        self._base_year_zer: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;zer&#39;, year=self.base_year, use_neutral_real_interest_rate=True)  # t
        self._base_year_z1r: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;z1r&#39;, year=self.base_year, use_neutral_real_interest_rate=True)  # t

        # SSF RHS vector values
        self._base_year_yxr: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;yxr&#39;, year=self.base_year, use_neutral_real_interest_rate=True)  # t
        self._base_year_yjr: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;yjr&#39;, year=self.base_year, use_neutral_real_interest_rate=True)  # t
        self._base_year_exz: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;exz&#39;, year=self.base_year, use_neutral_real_interest_rate=True)  # t+1
        self._base_year_exo: np.ndarray = self.database.rhs_vector_value(vector_name=&#39;exo&#39;, year=self.base_year, use_neutral_real_interest_rate=True)  # t

    def __store_observed_x1_values(self):
        &#34;&#34;&#34;
        Save the values of the state vector in the base projection year to use in
        initiating the projection process.
        &#34;&#34;&#34;
        self._x1_observed_values_in_base_projection_year = self.base_year_yxr.copy()

    def __store_observed_values_of_variables_adjusted_by_intertemporal_constants(self):
        &#34;&#34;&#34;
        Save the database values of the variables
        that are adjusted by intertemporal constants so that we can use
        those as the values we adjust the variables to using the intertemporal
        constants.
        &#34;&#34;&#34;
        self._base_year_observed_values_of_variables_adjusted_by_intertemporal_constants: np.ndarray = \
            np.zeros(shape=(len(self.sym_data.variables_adjusted_by_intertemporal_constants), 1))
        i = 0
        for index, adjusted_variable_details in self.sym_data.variables_adjusted_by_intertemporal_constants.iterrows():
            sequence = adjusted_variable_details[&#39;sequence&#39;]
            match adjusted_variable_details[&#39;var_type&#39;]:
                case &#39;x1l&#39;:
                    self._base_year_observed_values_of_variables_adjusted_by_intertemporal_constants[i, 0] = self.base_year_yxr[[sequence]]  # t = base year
                case &#39;j1l&#39;:
                    self._base_year_observed_values_of_variables_adjusted_by_intertemporal_constants[i, 0] = self.base_year_yjr[[sequence]]  # t = base year
                case &#39;zel&#39;:
                    self._base_year_observed_values_of_variables_adjusted_by_intertemporal_constants[i, 0] = self.base_year_exz[[
                        sequence]]  # t+1 = year after base year
                case &#39;z1l&#39;:
                    self._base_year_observed_values_of_variables_adjusted_by_intertemporal_constants[i, 0] = self.base_year_z1r[[sequence]]  # t = base year
            i += 1

    def __compute_base_year_ssf_deviations_from_observed_values(self):
        &#34;&#34;&#34;
        Compute the SSF values for the base projection year and calculate the differences from
        observed variable values for all system-determined variables (not the exogenous ones).
        See setconSYMBL.ox for details of the Ox implementation.

        Compute values for LHS variables based on RHS variable values in the projection base year 
        based on the SSF model. Then determine the difference between these LHS variables 
        (model predictions) and the actual values.

        Results are saved as data minus projections for all vectors.
        &#34;&#34;&#34;

        # No constant adjustments for differences from SSF when doing rolling baseline projections
        if self.using_rolled_projections:
            self._x1r_difference_from_ssf = np.zeros((self.sym_data.vector_length(vector_name=&#39;x1r&#39;), 1))
            self._j1r_difference_from_ssf = np.zeros((self.sym_data.vector_length(vector_name=&#39;j1r&#39;), 1))
            self._zer_difference_from_ssf = np.zeros((self.sym_data.vector_length(vector_name=&#39;zer&#39;), 1))
            self._z1r_difference_from_ssf = np.zeros((self.sym_data.vector_length(vector_name=&#39;z1r&#39;), 1))
            return

        # We got here so we must be done the initial baseline projections that require a constant adjustment
        # for the SSF differences from observed data values in the base projection year.

        self.x1l_ssf_calculations_using_base_year_data = self.state_space_form.delta(&#39;x1l&#39;, &#39;yxr&#39;) @ self.base_year_yxr + \
            self.state_space_form.delta(&#39;x1l&#39;, &#39;yjr&#39;) @ self.base_year_yjr + \
            self.state_space_form.delta(&#39;x1l&#39;, &#39;exz&#39;) @ self.base_year_exz + \
            self.state_space_form.delta(&#39;x1l&#39;, &#39;exo&#39;) @ self.base_year_exo

        self.j1l_ssf_calculations_using_base_year_data = self.state_space_form.delta(&#39;j1l&#39;, &#39;yxr&#39;) @ self.base_year_yxr + \
            self.state_space_form.delta(&#39;j1l&#39;, &#39;yjr&#39;) @ self.base_year_yjr + \
            self.state_space_form.delta(&#39;j1l&#39;, &#39;exz&#39;) @ self.base_year_exz + \
            self.state_space_form.delta(&#39;j1l&#39;, &#39;exo&#39;) @ self.base_year_exo

        self.zel_ssf_calculations_using_base_year_data = self.state_space_form.delta(&#39;zel&#39;, &#39;yxr&#39;) @ self.base_year_yxr + \
            self.state_space_form.delta(&#39;zel&#39;, &#39;yjr&#39;) @ self.base_year_yjr + \
            self.state_space_form.delta(&#39;zel&#39;, &#39;exz&#39;) @ self.base_year_exz + \
            self.state_space_form.delta(&#39;zel&#39;, &#39;exo&#39;) @ self.base_year_exo

        self.z1l_ssf_calculations_using_base_year_data = self.state_space_form.delta(&#39;z1l&#39;, &#39;yxr&#39;) @ self.base_year_yxr + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;yjr&#39;) @ self.base_year_yjr + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;exz&#39;) @ self.base_year_exz + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;exo&#39;) @ self.base_year_exo

        self._x1r_difference_from_ssf = self.base_year_x1r - self.x1l_ssf_calculations_using_base_year_data  # t+1 = year after base year
        self._j1r_difference_from_ssf = self.base_year_j1r - self.j1l_ssf_calculations_using_base_year_data  # t+1 = year after base year
        self._zer_difference_from_ssf = self.base_year_zer - self.zel_ssf_calculations_using_base_year_data  # t = base year
        self._z1r_difference_from_ssf = self.base_year_z1r - self.z1l_ssf_calculations_using_base_year_data  # t = base year

    @property
    def base_year_x1r(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        If the base year = t:
        Returns the value of x1r from the database as the value of x1 in period t+1
        &#34;&#34;&#34;
        return self._base_year_x1r

    @property
    def base_year_j1r(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        If the base year = t:
        Returns the value of j1r from the database as the value of j1 in period t+1
        &#34;&#34;&#34;
        return self._base_year_j1r

    @property
    def base_year_zer(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        If the base year = t:
        Returns the value of zer from the database as the value of x1 in period t
        &#34;&#34;&#34;
        return self._base_year_zer

    @property
    def base_year_z1r(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        If the base year = t:
        Returns the value of z1r from the database as the value of z1 in period t
        &#34;&#34;&#34;
        return self._base_year_z1r

    @property
    def base_year_yxr(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        If the base year = t:
        Returns the value of yxr from the database as the value of x1 in period t
        &#34;&#34;&#34;
        return self._base_year_yxr

    @property
    def base_year_yjr(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        If the base year = t:
        Returns the value of yjr from the database as the value of j1 in period t
        &#34;&#34;&#34;
        return self._base_year_yjr

    @property
    def base_year_exz(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        If the base year = t:
        Returns the value of exz from the database as the value of ze in period t+1
        &#34;&#34;&#34;
        return self._base_year_exz

    @property
    def base_year_exo(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        If the base year = t:
        Returns the value of exo from the database as the value of exogenous variables (exo)
        in period t
        &#34;&#34;&#34;
        return self._base_year_exo

    @property
    def x1r_difference_from_ssf(self):
        &#34;&#34;&#34;
        In Ox: decl cz2 = x1r - x1l
        &#34;&#34;&#34;
        return self._x1r_difference_from_ssf

    @property
    def j1r_difference_from_ssf(self):
        &#34;&#34;&#34;
        In Ox: decl cz4 = j1r - j1l
        &#34;&#34;&#34;
        return self._j1r_difference_from_ssf

    @property
    def zer_difference_from_ssf(self):
        &#34;&#34;&#34;
        In Ox: decl cz5 = zer - zel
        &#34;&#34;&#34;
        return self._zer_difference_from_ssf

    @property
    def z1r_difference_from_ssf(self):
        &#34;&#34;&#34;
        In Ox: decl cz6 = z1r - z1l
        &#34;&#34;&#34;
        return self._z1r_difference_from_ssf

    @property
    def x1_observed_values_in_base_projection_year(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Returns the observed values of the state variables in the base projection year.
        &#34;&#34;&#34;
        return self._x1_observed_values_in_base_projection_year

    def compute_functions_of_future_exogenous_variables(self):
        &#34;&#34;&#34;
        The rules governing the dynamic behaviour of variables depend on functions of the current and future exogenous variables.
        These functions are evaluated and the results are stored in numpy matrices that match the number of rows
        for the related vector of variables and that have a column for each year from the base projection year to the
        last year in the projections.
        &#34;&#34;&#34;

        # Set up the arrays that will be populated and initialise them to zeros.

        # // setup for baseline with optimization
        # decl id=invert(unit(nez)-c4n);
        # c4t=id*cz5;

        # decl mu2t=id*c6n;

        # id=invert(unit(njm)-ff-we*mu2t);
        # c6t=id*(cz4+we*c4t);

        # c4t=c4t+mu2t*c6t;
        # c4t=ones(rows(c4t),nobs).*c4t;
        # c6t=ones(rows(c6t),nobs).*c6t;
        # c2t=h2t*exog+c6t+bt2t*gam3t;

        # This is equivalent to h3t in the newsetsymbl.ox script (j by 1 dimensions)
        h3t: np.ndarray = np.zeros(shape=(self.sym_data.vector_length(vector_name=&#39;j1l&#39;), self.projection_years_count))

        # Populate for period T.

        # c4t=invert(unit(nez)-zel_exz_ssf)*cz5   (r by 1 dimensions)
        interim_calculation = self.stable_manifold.Gamma_rT @ self.ze_constants

        # c6t = invert(unit(j)-j1l_yjr_ssf-j1l_exz_ssf*mu2t) * (cz4+j1l_exz_ssf*c4t)
        #     = Gamma_jT (cz4+j1l_exz_ssf*interim_calculation)
        c6T_column = self.stable_manifold.Gamma_jT @ (self.j1_constants + self.state_space_form.delta(&#39;j1l&#39;, &#39;exz&#39;) @ interim_calculation)

        # c4t = c4t + mu2t * c6t (r by 1 dimensions)
        c4T_column = interim_calculation + self.stable_manifold.psi_rj @ c6T_column

        # c4t=ones(rows(c4t),nobs).*c4t (r by T dimensions)
        c4t: np.ndarray = np.tile(c4T_column, (1, self.projection_years_count))

        # c6t=ones(rows(c6t),nobs).*c6t (j by T dimensions)
        c6t: np.ndarray = np.tile(c6T_column, (1, self.projection_years_count))

        # c2t=h2t*exog+c6t    (j by T dimensions)
        c2t: np.ndarray = self.stable_manifold.H2 @ self.exo_projections + c6t

        # (s by T dimensions)
        c5t: np.ndarray = np.zeros(shape=(self.sym_data.vector_length(vector_name=&#39;x1l&#39;), self.projection_years_count))

        # (j by T dimensions)
        c2t_lead: np.ndarray = c2t.copy()
        c4t_lead: np.ndarray = c4t.copy()

        # Populate for earlier periods.
        j = self.projection_years_count-1
        for k in range(self.projection_years_count-1, -1, -1):

            # c5t[][k] = wvi*(x1l_exz_ssf*c4tl[][j] + cz2)          (s by 1 : note no need for T columns)
            c5t: np.ndarray = self.stable_manifold.Gamma_st @ (self.state_space_form.delta(&#39;x1l&#39;, &#39;exz&#39;) @ c4t_lead[:, [j]] + self.x1_constants)

            # c6t[][k] = fdeltinv*(th6t*c5t[][k] - j1l_exz_ssf*c4tl[][j] + c2tl[][j] - cz4)         (j rows)
            c6t[:, [k]] = self.stable_manifold.Gamma_jt @ (self.stable_manifold.common_factor @ c5t - self.state_space_form.delta(
                &#39;j1l&#39;, &#39;exz&#39;) @ c4t_lead[:, [j]] + c2t_lead[:, [j]] - self.j1_constants)

            # c5t[][k] = c5t[][k] + th2t*c6t[][k]
            c5t = c5t + self.stable_manifold.tau_sjt @ c6t[:, [k]]

            # c4t[][k] = mu1tl*c5t[][k] + c4tl[][j]
            c4t[:, [k]] = self.stable_manifold.M1_lead @ c5t + c4t_lead[:, [j]]

            # h3t[][k] = c6t[][k]
            h3t[:, [k]] = c6t[:, [k]].copy()

            # c2t[][k] = h2t*exog[][k] + h3t[][k]
            c2t[:, [k]] = self.stable_manifold.H2 @ self.exo_projections[:, [k]] + h3t[:, [k]]

            # c4tl[][k] = nmu4t*exog[][k] + zel_yjr_ssf*h3t[][k] + zel_exz_ssf*c4t[][k] + cz5
            c4t_lead[:, [k]] = self.stable_manifold.M2 @ self.exo_projections[:, [k]] + \
                self.state_space_form.delta(&#39;zel&#39;, &#39;yjr&#39;) @ h3t[:, [k]] + \
                self.state_space_form.delta(&#39;zel&#39;, &#39;exz&#39;) @ c4t[:, [k]] + \
                self.ze_constants

            c2t_lead = c2t.copy()

            j = k

        # Store the functions of future exogenous variables to access when doing projections.
        self._h3t = h3t.copy()
        self._c4t = c4t.copy()

    @property
    def h3t(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Equivalent to h3t in the Ox implementation
        
        Returns constants and the functions of current and future exogenous variables affecting J1.
        &#34;&#34;&#34;
        return self._h3t

    @property
    def c4t(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Equivalent to c4t in the Ox implementation
        
        Returns constants and the functions of current and future exogenous variables affecting ZE.
        &#34;&#34;&#34;
        return self._c4t

    @property
    def reference_h3t_used_to_compute_intertemporal_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Equivalent to h3t in the Ox implementation
        Functions of current and future exogenous variables affecting J1.
        This is the reference version of h3t, computed to calculation the projections
        for the base year that will be used as a reference projection when determining 
        the numeric derivatives for calculation of the intertemporal constants.

        Its only role is to preserve the appropriate information for benchmarking against Ox.
        &#34;&#34;&#34;
        return self._reference_h3t_used_to_compute_intertemporal_constants

    @property
    def reference_c4t_used_to_compute_intertemporal_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Equivalent to c4t in the Ox implementation
        Functions of current and future exogenous variables affecting ZE.
        This is the reference version of h3t, computed to calculation the projections
        for the base year that will be used as a reference projection when determining 
        the numeric derivatives for calculation of the intertemporal constants.

        Its only role is to preserve the appropriate information for benchmarking against Ox.
        &#34;&#34;&#34;
        return self._reference_c4t_used_to_compute_intertemporal_constants

    @property
    def x1_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to X1 to ensure projections equal observed values.
        Add any intertemporal constant values to the X1R difference to SSF equation 
        results with zero constants to get the combined set of constants.
        &#34;&#34;&#34;

        if hasattr(self, &#34;_x1_constants&#34;):
            return self._x1_constants

        result: np.ndarray = self.x1r_difference_from_ssf.copy()
        if not hasattr(self, &#34;intertemporal_constants&#34;):
            return result

        i = 0
        for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
            if variable_details[&#39;var_type&#39;] == &#39;x1l&#39;:
                result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
            i = i + 1

        self._x1_constants: np.ndarray = result
        return self._x1_constants

    @property
    def j1_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to J1 to ensure projections equal observed values.
        Add any intertemporal constant values to the X1R difference to SSF equation results with zero constants
        to get the combined set of constants.
        &#34;&#34;&#34;

        if hasattr(self, &#34;_j1_constants&#34;):
            return self._j1_constants

        result: np.ndarray = self.j1r_difference_from_ssf.copy()
        if not hasattr(self, &#34;intertemporal_constants&#34;):
            return result
        i = 0
        for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
            if variable_details[&#39;var_type&#39;] == &#39;j1l&#39;:
                result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
            i = i + 1

        self._j1_constants: np.ndarray = result
        return self._j1_constants

    @property
    def ze_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to ZE to ensure projections equal observed values.
        Add any intertemporal constant values to the X1R difference to SSF equation results with zero constants
        to get the combined set of constants.
        &#34;&#34;&#34;

        if hasattr(self, &#34;_ze_constants&#34;):
            return self._ze_constants

        result: np.ndarray = self.zer_difference_from_ssf.copy()
        if not hasattr(self, &#34;intertemporal_constants&#34;):
            return result

        i = 0
        for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
            if variable_details[&#39;var_type&#39;] == &#39;zel&#39;:
                logging.debug(
                    f&#34;At index {i} intertemporal constant is {self.intertemporal_constants.loc[variable_details[&#39;name&#39;],&#39;constant_value&#39;]} : shape is {self.intertemporal_constants.shape}&#34;)
                result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
            i = i + 1

        self._ze_constants: np.ndarray = result
        return self._ze_constants

    @property
    def z1_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to Z1 to ensure projections equal observed values.
        Add any intertemporal constant values to the X1R difference to SSF equation results with zero constants
        to get the combined set of constants.
        &#34;&#34;&#34;

        if hasattr(self, &#34;_z1_constants&#34;):
            return self._z1_constants

        result: np.ndarray = self.z1r_difference_from_ssf.copy()
        if not hasattr(self, &#34;intertemporal_constants&#34;):
            return result
        i = 0
        for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
            if variable_details[&#39;var_type&#39;] == &#39;z1l&#39;:
                result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
            i = i + 1

        self._z1_constants: np.ndarray = result
        return self._z1_constants

    def __create_exogenous_variable_projections(self):
        &#34;&#34;&#34;
        Populates the exogenous variable values through the projection years. 
        These values are determined outside the system.

        The rolling baseline projections just copy the exogenous values from the previous projections
        and use those as the starting point for the next round of projection generation.

        Otherwise, when initially setting up baseline projections, incorporate values from:
        - the database in the base projection year
        - effective labour productivity projections
        - energy efficiency improvement projections
        &#34;&#34;&#34;

        # If we are doing the baseline projections after rolling forward to a new base projection year,
        # just copy the database values for the exogenous variables over the projection years
        # and then we are done.
        if self.using_rolled_projections:
            matching_indices: pd.Index = self.sym_data.combined_variable_summary.loc[self.sym_data.combined_variable_summary.vector == &#39;exo&#39;, :].index
            self._exo_projections: pd.DataFrame = self.database.data.loc[matching_indices, self.configuration.base_and_projection_years_column_labels]
            return

        # We got here so we must be setting up the exogenous variable projections for the first time ...

        # Replicate projection base year values across all projection periods for all exogenous variables.
        base_year_values: np.ndarray = self.base_year_exo
        projections: pd.DataFrame = pd.DataFrame(np.tile(base_year_values, (1, self.configuration.base_and_projection_year_count)))
        projections.columns = self.configuration.base_and_projection_years_column_labels
        projections.reset_index()

        # Add effective labour productivity and energy usage efficiency.
        effective_labour_productivity: EffectiveLabourProductivity = self.model.effective_labour_productivity
        rogy: pd.DataFrame = effective_labour_productivity.rogy
        energy_usage_efficiency: EnergyUsageEfficiency = self.model.energy_usage_efficiency
        for region in self.sym_data.regions_members:

            regional_effective_labour_productivity: pd.DataFrame = effective_labour_productivity.effective_productivity_deviations(region=region)
            regional_energy_usage_efficiency: pd.DataFrame = energy_usage_efficiency.sector_cumulative_energy_usage_efficiency_gains(region=region)
            consumption_energy_usage_efficiency: pd.DataFrame = energy_usage_efficiency.consumption_cumulative_energy_usage_efficiency_gains

            variable_prefix_ROGY: str = f&#34;ROGY&#34;
            rogy_name: str = f&#34;{variable_prefix_ROGY}({region})&#34;
            if self.sym_data.has_variables(variable_name_prefix=rogy_name):
                rogy_index: int = self.sym_data.variable_index(vector_name=&#39;exo&#39;, variable_name=rogy_name)
                rogy_units = self.sym_data.variable_units(vector_name=&#39;exo&#39;, variable_name_prefix=variable_prefix_ROGY)
                rogy_data: pd.DataFrame = rogy.loc[[region], self.configuration.base_and_projection_years_column_labels]
                if &#39;gdp&#39; in rogy_units:
                    raise Exception(f&#34;{rogy_name} has gdp units so shocks to that variable are not supported.&#34;)

                projections.loc[[rogy_index], :] = projections.loc[[rogy_index], :] + (rogy_data.to_numpy().flatten() / 100)
            # else:
            #     logging.warning(f&#34;{rogy_name} is not in the SYM model.&#34;)

            shefc_name_prefix: str = f&#34;SHEFC&#34;
            shefc_name: str = f&#34;{shefc_name_prefix}({region})&#34;
            if self.sym_data.has_variables(variable_name_prefix=shefc_name_prefix):
                shefc_index: int = self.sym_data.variable_index(vector_name=&#39;exo&#39;, variable_name=shefc_name)
                shefc_units = self.sym_data.variable_units(vector_name=&#39;exo&#39;, variable_name_prefix=shefc_name_prefix)
                shefc_data: pd.DataFrame = consumption_energy_usage_efficiency.loc[[region], self.configuration.base_and_projection_years_column_labels]
                if &#39;gdp&#39; in shefc_units:
                    raise Exception(f&#34;{shefc_name} has gdp units so shocks to that variable are not supported.&#34;)
                projections.loc[[shefc_index], :] = projections.loc[[shefc_index], :] + (shefc_data.to_numpy().flatten() / 100)
            # else:
            #     logging.warning(f&#34;{shefc_name} is not in the SYM model.&#34;)

            variable_prefix_SHL: str = &#39;SHL&#39;
            variable_prefix_SHEF: str = &#39;SHEF&#39;
            for sector in self.sym_data.sectors_members:

                shl_name: str = f&#34;{variable_prefix_SHL}({region},{sector})&#34;
                if self.sym_data.has_variables(variable_name_prefix=shl_name):
                    shl_index: int = self.sym_data.variable_index(vector_name=&#39;exo&#39;, variable_name=shl_name)
                    shl_units = self.sym_data.variable_units(vector_name=&#39;exo&#39;, variable_name_prefix=variable_prefix_SHL)
                    shl_data: pd.DataFrame = regional_effective_labour_productivity.loc[[sector], self.configuration.base_and_projection_years_column_labels]
                    if &#39;gdp&#39; in shl_units:
                        raise Exception(f&#34;{shl_name} has gdp units so shocks to that variable are not supported.&#34;)
                    projections.loc[[shl_index], :] = projections.loc[[
                        shl_index], :] + (shl_data.to_numpy().flatten() / 100)
                # else:
                #     logging.warning(f&#34;{shl_name} is not in the SYM model.&#34;)

                shef_name: str = f&#34;{variable_prefix_SHEF}({sector},{region})&#34;
                if self.sym_data.has_variables(variable_name_prefix=shef_name):
                    shef_index: int = self.sym_data.variable_index(vector_name=&#39;exo&#39;, variable_name=shef_name)
                    shef_units = self.sym_data.variable_units(vector_name=&#39;exo&#39;, variable_name_prefix=variable_prefix_SHEF)
                    shef_data: pd.DataFrame = regional_energy_usage_efficiency.loc[[sector], self.configuration.base_and_projection_years_column_labels]
                    if &#39;gdp&#39; in shef_units:
                        raise Exception(f&#34;{shef_name} has gdp units so shocks to that variable are not supported.&#34;)
                    projections.loc[[shef_index], :] = projections.loc[[shef_index], :] + (shef_data.to_numpy().flatten() / 100)
                # else:
                #     logging.warning(f&#34;{shef_shock_name} is not in the SYM model.&#34;)

            # THIS IS OBSOLETE.
            # See https://bitbucket.org/msgpl/gcubedcode/issues/140/prodmat-file-for-20r-is-missing-some
            # for sector in self.sym_data.capital_sectors_members:
            #     variable_prefix_SHL_capital = f&#34;SHL{sector}&#34;
            #     shl_name: str = f&#34;{variable_prefix_SHL_capital}({region})&#34;
            #     if self.sym_data.has_variables(variable_name_prefix=variable_prefix_SHL_capital):
            #         shl_index: int = self.sym_data.variable_index(vector_name=&#39;exo&#39;, variable_name=shl_name)
            #         shl_units = self.sym_data.variable_units(vector_name=&#39;exo&#39;, variable_name_prefix=variable_prefix_SHL_capital)
            #         shl_data: pd.DataFrame = regional_effective_labour_productivity.loc[[sector], self.configuration.base_and_projection_years_column_labels]
            #         if &#39;gdp&#39; in shl_units:
            #             raise Exception(f&#34;{shl_name} has gdp units so shocks to that variable are not supported.&#34;)
            #         projections.loc[[shl_index], :] = projections.loc[[shl_index], :] + (shl_data.to_numpy().flatten() / 100)
            #     # else:
            #     #     logging.warning(f&#34;{shl_name} is not in the SYM model.&#34;)

        # Index with variable names.
        projections.index = self.sym_data.vector_variable_names(vector_name=&#39;exo&#39;)

        # Store the exogenous projections that will be augmented for other projections.
        self._exo_projections: pd.DataFrame = projections

    def __apply_simulation_layers(self):
        &#34;&#34;&#34;
        Apply adjustments to exogenous variables and any state variables for any simulation layers
        that have their event year matching the base year of these baseline projections.
        &#34;&#34;&#34;

        if not self.has_simulation_layer_definitions:
            return
        for simulation_layer_definition in self.simulation_layer_definitions:
            self.__apply_simulation_layer(simulation_layer_definition=simulation_layer_definition)

    def __apply_simulation_layer(self, simulation_layer_definition: SimulationLayerDefinition):
        &#34;&#34;&#34;
        Apply adjustments to exogenous variables and any state variables for the given simulation layer
        &#34;&#34;&#34;
        if simulation_layer_definition.event_year != self.base_year:
            return

        filename: str = simulation_layer_definition.data_filename
        assert os.path.isfile(filename)
        (self._simulation_variables, self._simulation_data) = self.load_data(filename)
        self._simulation_variables.columns = [&#39;name&#39;]
        self._simulation_variables.index = self._simulation_variables.name
        self._simulation_data = self._simulation_data.astype(float)
        self._simulation_data.index = self._simulation_variables.name
        try:
            self._simulation_data = self._simulation_data.loc[:, self.configuration.base_and_projection_years_column_labels]
        except:
            raise Exception(f&#34;The simulation data in {self.simulation_file} should have data from {self.event_year} to {self.end_year}&#34;)
        yratr: pd.DataFrame = self.database.get_data(name_regular_expression=f&#34;^{CONSTANTS.US_REAL_GDP_RATIO_PREFIX}\(&#34;, years=[self.base_year])
        yratr.index = self.sym_data.regions_members

        for variable_name in self._simulation_variables.index:
            variable_region: str = str(self.database.variables.loc[variable_name, &#39;region&#39;])
            variable_units: str = str(self.sym_data.combined_variable_summary.loc[variable_name, &#39;units&#39;])
            data: pd.DataFrame = self._simulation_data.loc[[variable_name], :] / 100
            vector_name = self.sym_data.projection_vector_for_variable(variable_name=variable_name)
            yratr_for_region: float = float(yratr.loc[variable_region, :])
            match variable_units:
                case &#39;gdp&#39;:
                    data = data * yratr_for_region
                case &#39;mmgdp&#39;:
                    data = data * yratr_for_region
                case &#39;btugdp&#39;:
                    data = data * yratr_for_region
                case &#39;gwhgdp&#39;:
                    data = data * yratr_for_region
                case _:
                    pass

            match vector_name:
                case &#39;exo&#39;:
                    self.exo_projections_as_dataframe.loc[[variable_name], self.configuration.base_and_projection_years_column_labels] += data
                    pass

                case &#39;x1l&#39;:
                    self.x1_observed_values_in_base_projection_year.loc[[variable_name], [str(self.base_year)]] += float(data[0])
                    pass

    def __evaluate_base_year_vector_projections(self):
        &#34;&#34;&#34;
        Computes the values of the model equation vectors in the first period of the projection, 
        using the functions of future exogenous variables, the stable manifold, and ...
        &#34;&#34;&#34;

        self._exo_base_year_projections = self.exo_projections[:, [0]]

        self._yxr_base_year_projections = self.x1_observed_values_in_base_projection_year.copy()

        # er = h1t*x[][1] + h2t*exog[][1] + h3t[][1];
        self._yjr_base_year_projections = \
            self.stable_manifold.H1 @ self.yxr_base_year_projections + \
            self.stable_manifold.H2 @ self.exo_base_year_projections + \
            self._h3t[:, [0]]

        # tzl = mu1t*x[][1] + mu4t*exog[][1] + c4t[][1];
        self._exz_base_year_projections = \
            self.stable_manifold.mu1 @ self.yxr_base_year_projections + \
            self.stable_manifold.mu2 @ self.exo_base_year_projections + \
            self._c4t[:, [0]]

        # z1l projections = d5n*x[][1]+d7n*exog[][1]+d6n*er+d4n*tzl+cz6[][1]
        self._z1l_base_year_projections = \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;yxr&#39;) @ self.yxr_base_year_projections + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;exo&#39;) @ self.exo_base_year_projections + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;yjr&#39;) @ self.yjr_base_year_projections + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;exz&#39;) @ self.exz_base_year_projections + \
            self.z1r_difference_from_ssf

    @property
    def yxr_base_year_projections(self):
        &#34;&#34;&#34;
        Projections of X1_t (yxr) in the base year
        &#34;&#34;&#34;
        return self._yxr_base_year_projections

    @property
    def yjr_base_year_projections(self):
        &#34;&#34;&#34;
        Projections of J1_t (yjr) in the base year
        &#34;&#34;&#34;
        return self._yjr_base_year_projections

    @property
    def exz_base_year_projections(self):
        &#34;&#34;&#34;
        Projections of ZE_t (exz) in the base year
        &#34;&#34;&#34;
        return self._exz_base_year_projections

    @property
    def z1l_base_year_projections(self):
        &#34;&#34;&#34;
        Projections of Z1_t (z1l=z1r) in the base year
        &#34;&#34;&#34;
        return self._z1l_base_year_projections

    @property
    def exo_base_year_projections(self):
        &#34;&#34;&#34;
        Projections of EXO_t in the base year
        &#34;&#34;&#34;
        return self._exo_base_year_projections

    @property
    def base_year_original_projections_of_variables_adjusted_by_intertemporal_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The base year projected values for the variables that are being
        adjusted by the intertemporal constants.

        The values are those for the projection that is not adjusted by intertemporal constants.
        &#34;&#34;&#34;
        return self._base_year_original_projections_of_variables_adjusted_by_intertemporal_constants

    @property
    def base_year_original_projections_of_yxr(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The base year projected values for the state variables.
        Required for benchmarking against Ox.
        &#34;&#34;&#34;
        return self._base_year_original_projections_of_yxr

    @property
    def base_year_original_projections_of_yjr(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The base year projected values for the costate variables.
        Required for benchmarking against Ox.
        &#34;&#34;&#34;
        return self._base_year_original_projections_of_yjr

    @property
    def base_year_original_projections_of_exz(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The base year projected values for the expected endogenous variables exz.
        Required for benchmarking against Ox.
        &#34;&#34;&#34;
        return self._base_year_original_projections_of_exz

    @property
    def base_year_original_projections_of_z1l(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The base year projected values for the endogenous variables.
        Required for benchmarking against Ox.
        &#34;&#34;&#34;
        return self._base_year_original_projections_of_z1l

    @property
    def base_year_observed_values_of_variables_adjusted_by_intertemporal_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Returns the observed values in the base projection year of the 
        variables that are adjusted by intertemporal constants.
        &#34;&#34;&#34;
        return self._base_year_observed_values_of_variables_adjusted_by_intertemporal_constants

    @property
    def base_year_lhs_values(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Values selected from base year SSF-generated LHS vectors using RHS vector values as inputs.
        &#34;&#34;&#34;
        return self._base_year_lhs_values

    @property
    def intertemporal_constants(self) -&gt; pd.DataFrame:
        return self._intertemporal_constants

    @property
    def partial_derivatives_wrt_intertemporal_constants(self) -&gt; np.ndarray:
        return self._partial_derivatives

    def __calculate_intertemporal_constants(self):
        &#34;&#34;&#34;
        Computes the intertemporal constant adjustments to jump and other variables to align starting data
        values with model projections in the first year.

        Step 1.
        Compute functions of future exogenous variables through all years of the projection.

        Step 2.
        For the variables that are to be adjusted by the intertemporal
        constants, compute their projected values in the base projection year
        and store these values for comparison to perturbed base year projections so we can calculate
        the derivatives matrix needed to set the intertemporal constants.
        Also store the values of each of the 4 vectors in the model in the base year for benchmarking.

        Step 3.
        Initialise the partial derivatives matrix. This is the matrix of derivatives of each of the
        variables that is adjusted by intertemporal constants, with respect to each of the intertemporal
        constants.
        Iterate over the intertemporal constants, perturbing each and recalculating the base year projections
        of the variables that are adjusted by intertemporal constants so that we can 
        estimate the relevant numeric derivatives.
        &#34;&#34;&#34;

        # Step 1.
        self.compute_functions_of_future_exogenous_variables()
        self._reference_c4t_used_to_compute_intertemporal_constants = self.c4t.copy()
        self._reference_h3t_used_to_compute_intertemporal_constants = self.h3t.copy()

        # Step 2.
        self.__evaluate_base_year_vector_projections()
        self._base_year_original_projections_of_yxr = self.yxr_base_year_projections.copy()
        self._base_year_original_projections_of_yjr = self.yjr_base_year_projections.copy()
        self._base_year_original_projections_of_exz = self.exz_base_year_projections.copy()
        self._base_year_original_projections_of_z1l = self.z1l_base_year_projections.copy()
        self._base_year_original_projections_of_variables_adjusted_by_intertemporal_constants = \
            self.base_year_projections_of_variables_adjusted_by_intertemporal_constants.copy()

        # Step 3.
        self._partial_derivatives = np.zeros(shape=(len(self.sym_data.intertemporal_constant_variables), len(
            self.sym_data.variables_adjusted_by_intertemporal_constants)))
        i = 0
        for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
            self.__update_perturbed_variable(variable_details=variable_details)
            self.compute_functions_of_future_exogenous_variables()
            self.__evaluate_base_year_vector_projections()
            self._partial_derivatives[:, [i]] = (
                self.base_year_projections_of_variables_adjusted_by_intertemporal_constants -
                self._base_year_original_projections_of_variables_adjusted_by_intertemporal_constants) \
                / __class__.PERTURBATION
            i += 1

        # Get the unperturbed values of the start year variables

        # Generate the baseline projection to use in computing partial derivatives
        # and to generate matrix values that are used later in projection processes.
        self.__update_perturbed_variable(variable_details=None)

        # Use newtons method adjustment to compute intertemporal constant values
        self._intertemporal_constants = self.sym_data.intertemporal_constant_variables
        values: np.ndarray = np.linalg.inv(self._partial_derivatives) @ \
            (self.base_year_observed_values_of_variables_adjusted_by_intertemporal_constants -
             self.base_year_original_projections_of_variables_adjusted_by_intertemporal_constants)
        values = values.reshape((len(self.intertemporal_constants.index), 1))
        self._intertemporal_constants[&#39;constant_value&#39;] = values
        logging.info(&#34;The intertemporal constants have been calibrated.&#34;)

    def __generate_projections(self):
        &#34;&#34;&#34;
        Implements the projection logic in msgsimBL.ox. This runs the various equations
        to project variables based on the starting state vector and the values of
        exogenous variables in all years. The steps are as follows:

        Step 1.
        Recalculate the functions of future exogenous variables, incorporating 
        the updated exogenous variable projections and all constant adjustments: 
        the intertemporal constants and the other constants  capturing the difference 
        between the SSF equation results in the base year and the observed 
        values in the base year.
        
        Step 2.
        Project the state vector. (x_t+1 as a function of x_t and exogenous variables and constant adjustments)
        This uses the Anew and Znew matrices computed as part of getting the stable manifold.

        Step 3. 
        Combine all variable projections into a single data frame.

        Step 4.
        Sort the variables in the projection dataframe into the same order as the original database.
        &#34;&#34;&#34;

        # Step 1.
        self.compute_functions_of_future_exogenous_variables()

        # Step 2.
        constantBL: pd.DataFrame = pd.DataFrame(
            self.stable_manifold.Znew @ self.exo_projections +
            self.state_space_form.delta(&#39;x1l&#39;, &#39;yjr&#39;) @ self.h3t +
            self.state_space_form.delta(&#39;x1l&#39;, &#39;exz&#39;) @ self.c4t +
            self.x1_constants)
        constantBL.columns = self.configuration.base_and_projection_years_column_labels
        constantBL.index = self.sym_data.vector_variable_names(vector_name=&#39;x1l&#39;)
        yxr: pd.DataFrame = pd.DataFrame(index=self.sym_data.vector_variable_names(vector_name=&#39;x1l&#39;),
                                         columns=self.configuration.base_and_projection_years_column_labels)
        yxr.loc[:, [str(self.configuration.projection_base_year)]] = self.x1_observed_values_in_base_projection_year
        previous_year_label = str(self.configuration.projection_base_year)
        for year in self.configuration.projection_years_column_labels:
            yxr.loc[:, [year]] = self.stable_manifold.Anew @ yxr.loc[:, [previous_year_label]].to_numpy() + constantBL.loc[:, [previous_year_label]].to_numpy()
            previous_year_label = year
        self._yxr_projections = yxr

        # Project J1
        # er = h1t*x + h2t*exog[][1:nobs] + h3t
        # yjr: pd.DataFrame = pd.DataFrame(self.stable_manifold.H1 @ (yxr.to_numpy()))
        yjr: pd.DataFrame = pd.DataFrame(self.stable_manifold.H1 @ (yxr.to_numpy()) + self.stable_manifold.H2 @ self.exo_projections + self._h3t)
        yjr.columns = self.configuration.base_and_projection_years_column_labels
        yjr.index = self.sym_data.vector_variable_names(vector_name=&#39;j1l&#39;)
        self._yjr_projections = yjr

        # Project time t expected value of ZE in period t+1 (EXZ)
        # Project time t expected value of ZE in period t+1 (EXZ)
        # tzl = mu1t*x + mu4t*exog[][1:nobs] + c4t
        exz: pd.DataFrame = pd.DataFrame(
            self.stable_manifold.mu1 @ yxr.to_numpy() +
            self.stable_manifold.mu2 @ self.exo_projections +
            self._c4t
        )
        exz.columns = self.configuration.base_and_projection_years_column_labels
        exz.index = self.sym_data.vector_variable_names(vector_name=&#39;zer&#39;)
        self._exz_projections = exz

        # Project time t values of ZE using the SSF equation (this should be done with M1 and M2?)
        # What about the functions of future exogenous variables and the constant adjustments
        zel: pd.DataFrame = pd.DataFrame(
            self.state_space_form.delta(&#39;zel&#39;, &#39;yxr&#39;) @ self.yxr_projections +
            self.state_space_form.delta(&#39;zel&#39;, &#39;exz&#39;) @ self.exz_projections +
            self.state_space_form.delta(&#39;zel&#39;, &#39;yjr&#39;) @ self.yjr_projections +
            self.state_space_form.delta(&#39;zel&#39;, &#39;exo&#39;) @ self.exo_projections)
        zel.columns = self.configuration.base_and_projection_years_column_labels
        zel.index = self.sym_data.vector_variable_names(vector_name=&#39;zel&#39;)
        self._zel_projections = zel + self.ze_constants

        # Project Z1 using the SSF equation
        z1l: pd.DataFrame = pd.DataFrame(
            self.state_space_form.delta(&#39;z1l&#39;, &#39;yxr&#39;) @ self.yxr_projections +
            self.state_space_form.delta(&#39;z1l&#39;, &#39;exz&#39;) @ self.exz_projections +
            self.state_space_form.delta(&#39;z1l&#39;, &#39;yjr&#39;) @ self.yjr_projections +
            self.state_space_form.delta(&#39;z1l&#39;, &#39;exo&#39;) @ self.exo_projections)
        z1l.columns = self.configuration.base_and_projection_years_column_labels
        z1l.index = self.sym_data.vector_variable_names(vector_name=&#39;z1l&#39;)
        self._z1l_projections = z1l + self.z1_constants

        # Combine the projections into a single dataframe in the same order as the database
        self._projections = pd.concat([
            self.yxr_projections_as_dataframe,
            self.z1l_projections_as_dataframe,
            self.zel_projections_as_dataframe,
            self.yjr_projections_as_dataframe,
            self.exo_projections_as_dataframe])
        database_ordered_variable_list: pd.DataFrame = self.database.variables.name
        self._projections = pd.concat([database_ordered_variable_list, self._projections], axis=1)
        self._projections.drop(&#39;name&#39;, inplace=True, axis=1)

        # timeshift forward the special state variables by 1 period.
        for variable_name_prefix in CONSTANTS.STATE_LEAD_VARIABLES:
            matching_variables = self._projections.index.str.startswith(variable_name_prefix)
            self._projections.iloc[matching_variables, 0:-2] = self._projections.iloc[matching_variables, 1:-1]
            self._projections.iloc[matching_variables, -1] = 0  # TODO: Once we are past benchmarking against Ox, set this equal to NaN.

        self._projections = self._projections.astype(float)

    @property
    def publishable_data(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Transforms the data so that it can be compared with publishable projections.

        Step 1.
        Get a copy of the raw data.

        Step 2.
        Divide the projections by YRATR/100 in the projection base year for every variable that has units of:
            gdp
            mmtgdp
            btugdp
            gwhgdp

        Step 3.
        Multiply values by 100

        Step 4.
        Get LGDPR data in the projection base year for each region and apply labgrow growth rates to translate
        across database years.

        Step 5.
        For all projections with units equal to usgdp, multiply the projection by the US LGDPR projection computed in step 4.

        Step 6.
        For all projections with units equal to &#39;gdp&#39;, multiply the projection by the associated
        region&#39;s LGDPR projection computed in step 4.

        These publishable projections should then be associated with the publication_units of measurement
        available from the sym_data variable summary.
        The units changes are as follows:
            del -&gt; pct
            pct -&gt; Index
            mmtgdp -&gt; mmt
            btugdp -&gt; btu
            gwhgdp -&gt; gwh
            mmtusgdp -&gt; mmt
            btuusgdp -&gt; btu
            usgdp -&gt; $US Bil
            gdp -&gt; $US Bil

        Saves the result in the _publishable_data property.

        &#34;&#34;&#34;

        # Step 1.
        publication_data: pd.DataFrame = self.database.data.copy()

        # Step 2.
        yratr_data: pd.DataFrame = self.database.data.loc[self.database.variables.name.str.startswith(&#34;YRATR(&#34;), str(self.configuration.base_year)].copy()
        yratr_data.index = self.sym_data.regions_members
        for variable_name in publication_data.index:
            units: str = str(self.database.variables.loc[variable_name, &#39;units&#39;])
            match units:
                case &#39;gdp&#39; | &#39;btugdp&#39; | &#39;mmtgdp&#39; | &#39;gwhgdp&#39;:
                    variable_region: str = str(self.database.variables.loc[variable_name, &#39;region&#39;])
                    factor: float = yratr_data.loc[variable_region]
                    publication_data.loc[[variable_name], :] /= factor

        # Step 3.
        publication_data *= 100.0

        # Step 4.
        # TODO: refactor out this calculation so it is not being done each time we convert to publishable projections
        lgdpr_in_base_year: pd.DataFrame = self.database.data.loc[self.database.variables.name.str.startswith(&#34;LGDPR(&#34;), [str(self.base_year)]].copy() / 100
        us_long_run_growth_rate: float = float(self.parameters.parameter(parameter_name=&#34;labgrow&#34;).loc[:, self.sym_data.us_region].values[0])
        scale_factor = pd.DataFrame(index=[&#39;values&#39;], columns=self.database.data.columns)
        scale_factor.loc[&#39;values&#39;, str(self.configuration.projection_base_year)] = 1
        for year in range(self.configuration.projection_base_year+1, int(self.database.data.columns[-1]) + 1):
            scale_factor.loc[&#39;values&#39;, str(year)] = scale_factor.loc[&#39;values&#39;, str(year-1)] * (1+us_long_run_growth_rate)
        for year in range(self.configuration.projection_base_year-1, int(self.database.data.columns[0]) - 1, -1):
            scale_factor.loc[&#39;values&#39;, str(year)] = scale_factor.loc[&#39;values&#39;, str(year+1)] / (1+us_long_run_growth_rate)
        lgdpr_data: pd.DataFrame = pd.DataFrame(lgdpr_in_base_year.values * scale_factor.values)
        lgdpr_data.index = self.sym_data.regions_members
        lgdpr_data.columns = publication_data.columns

        # Step 5 and 6.
        for variable_name in publication_data.index:
            variable_units: str = str(self.database.variables.loc[variable_name, &#39;units&#39;])
            match variable_units:
                case &#39;usgdp&#39;:
                    publication_data.loc[[variable_name], :] *= lgdpr_data.loc[[CONSTANTS.USA_REGION_CODE], :].values
                case &#39;mmtusgdp&#39;:
                    publication_data.loc[[variable_name], :] *= lgdpr_data.loc[[CONSTANTS.USA_REGION_CODE], :].values
                case &#39;btuusgdp&#39;:
                    publication_data.loc[[variable_name], :] *= lgdpr_data.loc[[CONSTANTS.USA_REGION_CODE], :].values
                case &#39;gdp&#39;:
                    variable_region: str = str(self.database.variables.loc[variable_name, &#39;region&#39;])
                    publication_data.loc[[variable_name], :] *= lgdpr_data.loc[[variable_region], :].values
                case &#39;mmtgdp&#39;:
                    variable_region: str = str(self.database.variables.loc[variable_name, &#39;region&#39;])
                    publication_data.loc[[variable_name], :] *= lgdpr_data.loc[[variable_region], :].values
                case &#39;btugdp&#39;:
                    variable_region: str = str(self.database.variables.loc[variable_name, &#39;region&#39;])
                    publication_data.loc[[variable_name], :] *= lgdpr_data.loc[[variable_region], :].values
                case &#39;gwhgdp&#39;:
                    variable_region: str = str(self.database.variables.loc[variable_name, &#39;region&#39;])
                    publication_data.loc[[variable_name], :] *= lgdpr_data.loc[[variable_region], :].values

        return publication_data.astype(float)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gcubed.projections.base_projections.BaseProjections" href="base_projections.html#gcubed.projections.base_projections.BaseProjections">BaseProjections</a></li>
<li><a title="gcubed.base.Base" href="../base.html#gcubed.base.Base">Base</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.PERTURBATION"><code class="name">var <span class="ident">PERTURBATION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.base_year"><code class="name">var <span class="ident">base_year</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def base_year(self) -&gt; int:
    return self.configuration.projection_base_year</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.base_year_exo"><code class="name">var <span class="ident">base_year_exo</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>If the base year = t:
Returns the value of exo from the database as the value of exogenous variables (exo)
in period t</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def base_year_exo(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    If the base year = t:
    Returns the value of exo from the database as the value of exogenous variables (exo)
    in period t
    &#34;&#34;&#34;
    return self._base_year_exo</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.base_year_exz"><code class="name">var <span class="ident">base_year_exz</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>If the base year = t:
Returns the value of exz from the database as the value of ze in period t+1</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def base_year_exz(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    If the base year = t:
    Returns the value of exz from the database as the value of ze in period t+1
    &#34;&#34;&#34;
    return self._base_year_exz</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.base_year_j1r"><code class="name">var <span class="ident">base_year_j1r</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>If the base year = t:
Returns the value of j1r from the database as the value of j1 in period t+1</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def base_year_j1r(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    If the base year = t:
    Returns the value of j1r from the database as the value of j1 in period t+1
    &#34;&#34;&#34;
    return self._base_year_j1r</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.base_year_lhs_values"><code class="name">var <span class="ident">base_year_lhs_values</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Values selected from base year SSF-generated LHS vectors using RHS vector values as inputs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def base_year_lhs_values(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Values selected from base year SSF-generated LHS vectors using RHS vector values as inputs.
    &#34;&#34;&#34;
    return self._base_year_lhs_values</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.base_year_observed_values_of_variables_adjusted_by_intertemporal_constants"><code class="name">var <span class="ident">base_year_observed_values_of_variables_adjusted_by_intertemporal_constants</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Returns the observed values in the base projection year of the
variables that are adjusted by intertemporal constants.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def base_year_observed_values_of_variables_adjusted_by_intertemporal_constants(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Returns the observed values in the base projection year of the 
    variables that are adjusted by intertemporal constants.
    &#34;&#34;&#34;
    return self._base_year_observed_values_of_variables_adjusted_by_intertemporal_constants</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.base_year_original_projections_of_exz"><code class="name">var <span class="ident">base_year_original_projections_of_exz</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The base year projected values for the expected endogenous variables exz.
Required for benchmarking against Ox.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def base_year_original_projections_of_exz(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The base year projected values for the expected endogenous variables exz.
    Required for benchmarking against Ox.
    &#34;&#34;&#34;
    return self._base_year_original_projections_of_exz</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.base_year_original_projections_of_variables_adjusted_by_intertemporal_constants"><code class="name">var <span class="ident">base_year_original_projections_of_variables_adjusted_by_intertemporal_constants</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The base year projected values for the variables that are being
adjusted by the intertemporal constants.</p>
<p>The values are those for the projection that is not adjusted by intertemporal constants.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def base_year_original_projections_of_variables_adjusted_by_intertemporal_constants(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The base year projected values for the variables that are being
    adjusted by the intertemporal constants.

    The values are those for the projection that is not adjusted by intertemporal constants.
    &#34;&#34;&#34;
    return self._base_year_original_projections_of_variables_adjusted_by_intertemporal_constants</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.base_year_original_projections_of_yjr"><code class="name">var <span class="ident">base_year_original_projections_of_yjr</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The base year projected values for the costate variables.
Required for benchmarking against Ox.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def base_year_original_projections_of_yjr(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The base year projected values for the costate variables.
    Required for benchmarking against Ox.
    &#34;&#34;&#34;
    return self._base_year_original_projections_of_yjr</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.base_year_original_projections_of_yxr"><code class="name">var <span class="ident">base_year_original_projections_of_yxr</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The base year projected values for the state variables.
Required for benchmarking against Ox.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def base_year_original_projections_of_yxr(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The base year projected values for the state variables.
    Required for benchmarking against Ox.
    &#34;&#34;&#34;
    return self._base_year_original_projections_of_yxr</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.base_year_original_projections_of_z1l"><code class="name">var <span class="ident">base_year_original_projections_of_z1l</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The base year projected values for the endogenous variables.
Required for benchmarking against Ox.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def base_year_original_projections_of_z1l(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The base year projected values for the endogenous variables.
    Required for benchmarking against Ox.
    &#34;&#34;&#34;
    return self._base_year_original_projections_of_z1l</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.base_year_projections_of_variables_adjusted_by_intertemporal_constants"><code class="name">var <span class="ident">base_year_projections_of_variables_adjusted_by_intertemporal_constants</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Extract the values of the variables that have been changed by the perturbation to
an intertemporal constant as part of computing partial derivatives for setting the
intertemporal constants appropriately. These values are a column vector
for the base project year only.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def base_year_projections_of_variables_adjusted_by_intertemporal_constants(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Extract the values of the variables that have been changed by the perturbation to 
    an intertemporal constant as part of computing partial derivatives for setting the
    intertemporal constants appropriately. These values are a column vector
    for the base project year only.
    &#34;&#34;&#34;
    result = np.zeros(shape=(len(self.sym_data.variables_adjusted_by_intertemporal_constants), 1))
    i = 0
    for index, adjusted_variable_details in self.sym_data.variables_adjusted_by_intertemporal_constants.iterrows():
        sequence = adjusted_variable_details[&#39;sequence&#39;]
        match adjusted_variable_details[&#39;var_type&#39;]:
            case &#39;x1l&#39;:
                result[i, 0] = self.yxr_base_year_projections[[sequence]]
            case &#39;j1l&#39;:
                result[i, 0] = self.yjr_base_year_projections[[sequence]]
            case &#39;zel&#39;:
                result[i, 0] = self.exz_base_year_projections[[sequence]]
            case &#39;z1l&#39;:
                result[i, 0] = self.z1l_base_year_projections[[sequence]]
        i += 1
    return result</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.base_year_x1r"><code class="name">var <span class="ident">base_year_x1r</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>If the base year = t:
Returns the value of x1r from the database as the value of x1 in period t+1</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def base_year_x1r(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    If the base year = t:
    Returns the value of x1r from the database as the value of x1 in period t+1
    &#34;&#34;&#34;
    return self._base_year_x1r</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.base_year_yjr"><code class="name">var <span class="ident">base_year_yjr</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>If the base year = t:
Returns the value of yjr from the database as the value of j1 in period t</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def base_year_yjr(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    If the base year = t:
    Returns the value of yjr from the database as the value of j1 in period t
    &#34;&#34;&#34;
    return self._base_year_yjr</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.base_year_yxr"><code class="name">var <span class="ident">base_year_yxr</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>If the base year = t:
Returns the value of yxr from the database as the value of x1 in period t</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def base_year_yxr(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    If the base year = t:
    Returns the value of yxr from the database as the value of x1 in period t
    &#34;&#34;&#34;
    return self._base_year_yxr</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.base_year_z1r"><code class="name">var <span class="ident">base_year_z1r</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>If the base year = t:
Returns the value of z1r from the database as the value of z1 in period t</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def base_year_z1r(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    If the base year = t:
    Returns the value of z1r from the database as the value of z1 in period t
    &#34;&#34;&#34;
    return self._base_year_z1r</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.base_year_zer"><code class="name">var <span class="ident">base_year_zer</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>If the base year = t:
Returns the value of zer from the database as the value of x1 in period t</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def base_year_zer(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    If the base year = t:
    Returns the value of zer from the database as the value of x1 in period t
    &#34;&#34;&#34;
    return self._base_year_zer</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.c4t"><code class="name">var <span class="ident">c4t</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Equivalent to c4t in the Ox implementation</p>
<p>Returns constants and the functions of current and future exogenous variables affecting ZE.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def c4t(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Equivalent to c4t in the Ox implementation
    
    Returns constants and the functions of current and future exogenous variables affecting ZE.
    &#34;&#34;&#34;
    return self._c4t</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.configuration"><code class="name">var <span class="ident">configuration</span> : <a title="gcubed.model_configuration.ModelConfiguration" href="../model_configuration.html#gcubed.model_configuration.ModelConfiguration">ModelConfiguration</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def configuration(self) -&gt; ModelConfiguration:
    return self.sym_data.configuration</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.database"><code class="name">var <span class="ident">database</span> : <a title="gcubed.data.gdp_scaled_database.GDPScaledDatabase" href="../data/gdp_scaled_database.html#gcubed.data.gdp_scaled_database.GDPScaledDatabase">GDPScaledDatabase</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def database(self) -&gt; GDPScaledDatabase:
    return self._database</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.exo_base_year_projections"><code class="name">var <span class="ident">exo_base_year_projections</span></code></dt>
<dd>
<div class="desc"><p>Projections of EXO_t in the base year</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def exo_base_year_projections(self):
    &#34;&#34;&#34;
    Projections of EXO_t in the base year
    &#34;&#34;&#34;
    return self._exo_base_year_projections</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.exz_base_year_projections"><code class="name">var <span class="ident">exz_base_year_projections</span></code></dt>
<dd>
<div class="desc"><p>Projections of ZE_t (exz) in the base year</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def exz_base_year_projections(self):
    &#34;&#34;&#34;
    Projections of ZE_t (exz) in the base year
    &#34;&#34;&#34;
    return self._exz_base_year_projections</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.h3t"><code class="name">var <span class="ident">h3t</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Equivalent to h3t in the Ox implementation</p>
<p>Returns constants and the functions of current and future exogenous variables affecting J1.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def h3t(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Equivalent to h3t in the Ox implementation
    
    Returns constants and the functions of current and future exogenous variables affecting J1.
    &#34;&#34;&#34;
    return self._h3t</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.has_simulation_layer_definitions"><code class="name">var <span class="ident">has_simulation_layer_definitions</span> : bool</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def has_simulation_layer_definitions(self) -&gt; bool:
    return (self.simulation_layer_definitions is not None)</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.intertemporal_constants"><code class="name">var <span class="ident">intertemporal_constants</span> : pandas.core.frame.DataFrame</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def intertemporal_constants(self) -&gt; pd.DataFrame:
    return self._intertemporal_constants</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.j1_constants"><code class="name">var <span class="ident">j1_constants</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The constant adjustments to J1 to ensure projections equal observed values.
Add any intertemporal constant values to the X1R difference to SSF equation results with zero constants
to get the combined set of constants.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def j1_constants(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The constant adjustments to J1 to ensure projections equal observed values.
    Add any intertemporal constant values to the X1R difference to SSF equation results with zero constants
    to get the combined set of constants.
    &#34;&#34;&#34;

    if hasattr(self, &#34;_j1_constants&#34;):
        return self._j1_constants

    result: np.ndarray = self.j1r_difference_from_ssf.copy()
    if not hasattr(self, &#34;intertemporal_constants&#34;):
        return result
    i = 0
    for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
        if variable_details[&#39;var_type&#39;] == &#39;j1l&#39;:
            result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
        i = i + 1

    self._j1_constants: np.ndarray = result
    return self._j1_constants</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.j1r_difference_from_ssf"><code class="name">var <span class="ident">j1r_difference_from_ssf</span></code></dt>
<dd>
<div class="desc"><p>In Ox: decl cz4 = j1r - j1l</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def j1r_difference_from_ssf(self):
    &#34;&#34;&#34;
    In Ox: decl cz4 = j1r - j1l
    &#34;&#34;&#34;
    return self._j1r_difference_from_ssf</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.model"><code class="name">var <span class="ident">model</span> : <a title="gcubed.model.Model" href="../model.html#gcubed.model.Model">Model</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def model(self) -&gt; Model:
    return self.state_space_form.model</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.parameters"><code class="name">var <span class="ident">parameters</span> : <a title="gcubed.model_parameters.parameters.Parameters" href="../model_parameters/parameters.html#gcubed.model_parameters.parameters.Parameters">Parameters</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def parameters(self) -&gt; Parameters:
    return self.model.parameters</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.partial_derivatives_wrt_intertemporal_constants"><code class="name">var <span class="ident">partial_derivatives_wrt_intertemporal_constants</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def partial_derivatives_wrt_intertemporal_constants(self) -&gt; np.ndarray:
    return self._partial_derivatives</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.perturbed_variable_details"><code class="name">var <span class="ident">perturbed_variable_details</span> : pandas.core.series.Series</code></dt>
<dd>
<div class="desc"><p>Returns the var_map details of the variable being perturbed to as part of computing
derivatives needed to set intertemporal constants or none if just doing projections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def perturbed_variable_details(self) -&gt; pd.Series:
    &#34;&#34;&#34;
    Returns the var_map details of the variable being perturbed to as part of computing
    derivatives needed to set intertemporal constants or none if just doing projections.
    &#34;&#34;&#34;
    if hasattr(self, &#39;_perturbed_variable_details&#39;):
        return self._perturbed_variable_details
    return None</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.publishable_data"><code class="name">var <span class="ident">publishable_data</span> : pandas.core.frame.DataFrame</code></dt>
<dd>
<div class="desc"><p>Transforms the data so that it can be compared with publishable projections.</p>
<p>Step 1.
Get a copy of the raw data.</p>
<p>Step 2.
Divide the projections by YRATR/100 in the projection base year for every variable that has units of:
gdp
mmtgdp
btugdp
gwhgdp</p>
<p>Step 3.
Multiply values by 100</p>
<p>Step 4.
Get LGDPR data in the projection base year for each region and apply labgrow growth rates to translate
across database years.</p>
<p>Step 5.
For all projections with units equal to usgdp, multiply the projection by the US LGDPR projection computed in step 4.</p>
<p>Step 6.
For all projections with units equal to 'gdp', multiply the projection by the associated
region's LGDPR projection computed in step 4.</p>
<p>These publishable projections should then be associated with the publication_units of measurement
available from the sym_data variable summary.
The units changes are as follows:
del -&gt; pct
pct -&gt; Index
mmtgdp -&gt; mmt
btugdp -&gt; btu
gwhgdp -&gt; gwh
mmtusgdp -&gt; mmt
btuusgdp -&gt; btu
usgdp -&gt; $US Bil
gdp -&gt; $US Bil</p>
<p>Saves the result in the _publishable_data property.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def publishable_data(self) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Transforms the data so that it can be compared with publishable projections.

    Step 1.
    Get a copy of the raw data.

    Step 2.
    Divide the projections by YRATR/100 in the projection base year for every variable that has units of:
        gdp
        mmtgdp
        btugdp
        gwhgdp

    Step 3.
    Multiply values by 100

    Step 4.
    Get LGDPR data in the projection base year for each region and apply labgrow growth rates to translate
    across database years.

    Step 5.
    For all projections with units equal to usgdp, multiply the projection by the US LGDPR projection computed in step 4.

    Step 6.
    For all projections with units equal to &#39;gdp&#39;, multiply the projection by the associated
    region&#39;s LGDPR projection computed in step 4.

    These publishable projections should then be associated with the publication_units of measurement
    available from the sym_data variable summary.
    The units changes are as follows:
        del -&gt; pct
        pct -&gt; Index
        mmtgdp -&gt; mmt
        btugdp -&gt; btu
        gwhgdp -&gt; gwh
        mmtusgdp -&gt; mmt
        btuusgdp -&gt; btu
        usgdp -&gt; $US Bil
        gdp -&gt; $US Bil

    Saves the result in the _publishable_data property.

    &#34;&#34;&#34;

    # Step 1.
    publication_data: pd.DataFrame = self.database.data.copy()

    # Step 2.
    yratr_data: pd.DataFrame = self.database.data.loc[self.database.variables.name.str.startswith(&#34;YRATR(&#34;), str(self.configuration.base_year)].copy()
    yratr_data.index = self.sym_data.regions_members
    for variable_name in publication_data.index:
        units: str = str(self.database.variables.loc[variable_name, &#39;units&#39;])
        match units:
            case &#39;gdp&#39; | &#39;btugdp&#39; | &#39;mmtgdp&#39; | &#39;gwhgdp&#39;:
                variable_region: str = str(self.database.variables.loc[variable_name, &#39;region&#39;])
                factor: float = yratr_data.loc[variable_region]
                publication_data.loc[[variable_name], :] /= factor

    # Step 3.
    publication_data *= 100.0

    # Step 4.
    # TODO: refactor out this calculation so it is not being done each time we convert to publishable projections
    lgdpr_in_base_year: pd.DataFrame = self.database.data.loc[self.database.variables.name.str.startswith(&#34;LGDPR(&#34;), [str(self.base_year)]].copy() / 100
    us_long_run_growth_rate: float = float(self.parameters.parameter(parameter_name=&#34;labgrow&#34;).loc[:, self.sym_data.us_region].values[0])
    scale_factor = pd.DataFrame(index=[&#39;values&#39;], columns=self.database.data.columns)
    scale_factor.loc[&#39;values&#39;, str(self.configuration.projection_base_year)] = 1
    for year in range(self.configuration.projection_base_year+1, int(self.database.data.columns[-1]) + 1):
        scale_factor.loc[&#39;values&#39;, str(year)] = scale_factor.loc[&#39;values&#39;, str(year-1)] * (1+us_long_run_growth_rate)
    for year in range(self.configuration.projection_base_year-1, int(self.database.data.columns[0]) - 1, -1):
        scale_factor.loc[&#39;values&#39;, str(year)] = scale_factor.loc[&#39;values&#39;, str(year+1)] / (1+us_long_run_growth_rate)
    lgdpr_data: pd.DataFrame = pd.DataFrame(lgdpr_in_base_year.values * scale_factor.values)
    lgdpr_data.index = self.sym_data.regions_members
    lgdpr_data.columns = publication_data.columns

    # Step 5 and 6.
    for variable_name in publication_data.index:
        variable_units: str = str(self.database.variables.loc[variable_name, &#39;units&#39;])
        match variable_units:
            case &#39;usgdp&#39;:
                publication_data.loc[[variable_name], :] *= lgdpr_data.loc[[CONSTANTS.USA_REGION_CODE], :].values
            case &#39;mmtusgdp&#39;:
                publication_data.loc[[variable_name], :] *= lgdpr_data.loc[[CONSTANTS.USA_REGION_CODE], :].values
            case &#39;btuusgdp&#39;:
                publication_data.loc[[variable_name], :] *= lgdpr_data.loc[[CONSTANTS.USA_REGION_CODE], :].values
            case &#39;gdp&#39;:
                variable_region: str = str(self.database.variables.loc[variable_name, &#39;region&#39;])
                publication_data.loc[[variable_name], :] *= lgdpr_data.loc[[variable_region], :].values
            case &#39;mmtgdp&#39;:
                variable_region: str = str(self.database.variables.loc[variable_name, &#39;region&#39;])
                publication_data.loc[[variable_name], :] *= lgdpr_data.loc[[variable_region], :].values
            case &#39;btugdp&#39;:
                variable_region: str = str(self.database.variables.loc[variable_name, &#39;region&#39;])
                publication_data.loc[[variable_name], :] *= lgdpr_data.loc[[variable_region], :].values
            case &#39;gwhgdp&#39;:
                variable_region: str = str(self.database.variables.loc[variable_name, &#39;region&#39;])
                publication_data.loc[[variable_name], :] *= lgdpr_data.loc[[variable_region], :].values

    return publication_data.astype(float)</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.reference_c4t_used_to_compute_intertemporal_constants"><code class="name">var <span class="ident">reference_c4t_used_to_compute_intertemporal_constants</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Equivalent to c4t in the Ox implementation
Functions of current and future exogenous variables affecting ZE.
This is the reference version of h3t, computed to calculation the projections
for the base year that will be used as a reference projection when determining
the numeric derivatives for calculation of the intertemporal constants.</p>
<p>Its only role is to preserve the appropriate information for benchmarking against Ox.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def reference_c4t_used_to_compute_intertemporal_constants(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Equivalent to c4t in the Ox implementation
    Functions of current and future exogenous variables affecting ZE.
    This is the reference version of h3t, computed to calculation the projections
    for the base year that will be used as a reference projection when determining 
    the numeric derivatives for calculation of the intertemporal constants.

    Its only role is to preserve the appropriate information for benchmarking against Ox.
    &#34;&#34;&#34;
    return self._reference_c4t_used_to_compute_intertemporal_constants</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.reference_h3t_used_to_compute_intertemporal_constants"><code class="name">var <span class="ident">reference_h3t_used_to_compute_intertemporal_constants</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Equivalent to h3t in the Ox implementation
Functions of current and future exogenous variables affecting J1.
This is the reference version of h3t, computed to calculation the projections
for the base year that will be used as a reference projection when determining
the numeric derivatives for calculation of the intertemporal constants.</p>
<p>Its only role is to preserve the appropriate information for benchmarking against Ox.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def reference_h3t_used_to_compute_intertemporal_constants(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Equivalent to h3t in the Ox implementation
    Functions of current and future exogenous variables affecting J1.
    This is the reference version of h3t, computed to calculation the projections
    for the base year that will be used as a reference projection when determining 
    the numeric derivatives for calculation of the intertemporal constants.

    Its only role is to preserve the appropriate information for benchmarking against Ox.
    &#34;&#34;&#34;
    return self._reference_h3t_used_to_compute_intertemporal_constants</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.simulation_layer_definitions"><code class="name">var <span class="ident">simulation_layer_definitions</span> : <a title="gcubed.projections.simulation_layer_definitions.SimulationLayerDefinitions" href="simulation_layer_definitions.html#gcubed.projections.simulation_layer_definitions.SimulationLayerDefinitions">SimulationLayerDefinitions</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def simulation_layer_definitions(self) -&gt; SimulationLayerDefinitions:
    return self._simulation_layer_definitions</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.stable_manifold"><code class="name">var <span class="ident">stable_manifold</span> : <a title="gcubed.stable_manifold.StableManifold" href="../stable_manifold.html#gcubed.stable_manifold.StableManifold">StableManifold</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def stable_manifold(self) -&gt; StableManifold:
    return self._stable_manifold</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.state_space_form"><code class="name">var <span class="ident">state_space_form</span> : <a title="gcubed.state_space_form.StateSpaceForm" href="../state_space_form.html#gcubed.state_space_form.StateSpaceForm">StateSpaceForm</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def state_space_form(self) -&gt; StateSpaceForm:
    return self.stable_manifold.ssf</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.sym_data"><code class="name">var <span class="ident">sym_data</span> : <a title="gcubed.sym_data.SymData" href="../sym_data.html#gcubed.sym_data.SymData">SymData</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sym_data(self) -&gt; SymData:
    return self.model.sym_data</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.using_rolled_projections"><code class="name">var <span class="ident">using_rolled_projections</span> : bool</code></dt>
<dd>
<div class="desc"><p>Returns true if these projections are building on
previous projections rather than just observed data.
This affects how the baseline projections are set up in terms
of the constants used</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def using_rolled_projections(self) -&gt; bool:
    &#34;&#34;&#34;
    Returns true if these projections are building on
    previous projections rather than just observed data.
    This affects how the baseline projections are set up in terms
    of the constants used 
    &#34;&#34;&#34;
    return self.database.has_data_for_all_projection_years</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.x1_constants"><code class="name">var <span class="ident">x1_constants</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The constant adjustments to X1 to ensure projections equal observed values.
Add any intertemporal constant values to the X1R difference to SSF equation
results with zero constants to get the combined set of constants.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def x1_constants(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The constant adjustments to X1 to ensure projections equal observed values.
    Add any intertemporal constant values to the X1R difference to SSF equation 
    results with zero constants to get the combined set of constants.
    &#34;&#34;&#34;

    if hasattr(self, &#34;_x1_constants&#34;):
        return self._x1_constants

    result: np.ndarray = self.x1r_difference_from_ssf.copy()
    if not hasattr(self, &#34;intertemporal_constants&#34;):
        return result

    i = 0
    for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
        if variable_details[&#39;var_type&#39;] == &#39;x1l&#39;:
            result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
        i = i + 1

    self._x1_constants: np.ndarray = result
    return self._x1_constants</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.x1_observed_values_in_base_projection_year"><code class="name">var <span class="ident">x1_observed_values_in_base_projection_year</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Returns the observed values of the state variables in the base projection year.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def x1_observed_values_in_base_projection_year(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Returns the observed values of the state variables in the base projection year.
    &#34;&#34;&#34;
    return self._x1_observed_values_in_base_projection_year</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.x1r_difference_from_ssf"><code class="name">var <span class="ident">x1r_difference_from_ssf</span></code></dt>
<dd>
<div class="desc"><p>In Ox: decl cz2 = x1r - x1l</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def x1r_difference_from_ssf(self):
    &#34;&#34;&#34;
    In Ox: decl cz2 = x1r - x1l
    &#34;&#34;&#34;
    return self._x1r_difference_from_ssf</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.yjr_base_year_projections"><code class="name">var <span class="ident">yjr_base_year_projections</span></code></dt>
<dd>
<div class="desc"><p>Projections of J1_t (yjr) in the base year</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def yjr_base_year_projections(self):
    &#34;&#34;&#34;
    Projections of J1_t (yjr) in the base year
    &#34;&#34;&#34;
    return self._yjr_base_year_projections</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.yxr_base_year_projections"><code class="name">var <span class="ident">yxr_base_year_projections</span></code></dt>
<dd>
<div class="desc"><p>Projections of X1_t (yxr) in the base year</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def yxr_base_year_projections(self):
    &#34;&#34;&#34;
    Projections of X1_t (yxr) in the base year
    &#34;&#34;&#34;
    return self._yxr_base_year_projections</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.z1_constants"><code class="name">var <span class="ident">z1_constants</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The constant adjustments to Z1 to ensure projections equal observed values.
Add any intertemporal constant values to the X1R difference to SSF equation results with zero constants
to get the combined set of constants.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def z1_constants(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The constant adjustments to Z1 to ensure projections equal observed values.
    Add any intertemporal constant values to the X1R difference to SSF equation results with zero constants
    to get the combined set of constants.
    &#34;&#34;&#34;

    if hasattr(self, &#34;_z1_constants&#34;):
        return self._z1_constants

    result: np.ndarray = self.z1r_difference_from_ssf.copy()
    if not hasattr(self, &#34;intertemporal_constants&#34;):
        return result
    i = 0
    for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
        if variable_details[&#39;var_type&#39;] == &#39;z1l&#39;:
            result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
        i = i + 1

    self._z1_constants: np.ndarray = result
    return self._z1_constants</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.z1l_base_year_projections"><code class="name">var <span class="ident">z1l_base_year_projections</span></code></dt>
<dd>
<div class="desc"><p>Projections of Z1_t (z1l=z1r) in the base year</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def z1l_base_year_projections(self):
    &#34;&#34;&#34;
    Projections of Z1_t (z1l=z1r) in the base year
    &#34;&#34;&#34;
    return self._z1l_base_year_projections</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.z1r_difference_from_ssf"><code class="name">var <span class="ident">z1r_difference_from_ssf</span></code></dt>
<dd>
<div class="desc"><p>In Ox: decl cz6 = z1r - z1l</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def z1r_difference_from_ssf(self):
    &#34;&#34;&#34;
    In Ox: decl cz6 = z1r - z1l
    &#34;&#34;&#34;
    return self._z1r_difference_from_ssf</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.ze_constants"><code class="name">var <span class="ident">ze_constants</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The constant adjustments to ZE to ensure projections equal observed values.
Add any intertemporal constant values to the X1R difference to SSF equation results with zero constants
to get the combined set of constants.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ze_constants(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The constant adjustments to ZE to ensure projections equal observed values.
    Add any intertemporal constant values to the X1R difference to SSF equation results with zero constants
    to get the combined set of constants.
    &#34;&#34;&#34;

    if hasattr(self, &#34;_ze_constants&#34;):
        return self._ze_constants

    result: np.ndarray = self.zer_difference_from_ssf.copy()
    if not hasattr(self, &#34;intertemporal_constants&#34;):
        return result

    i = 0
    for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
        if variable_details[&#39;var_type&#39;] == &#39;zel&#39;:
            logging.debug(
                f&#34;At index {i} intertemporal constant is {self.intertemporal_constants.loc[variable_details[&#39;name&#39;],&#39;constant_value&#39;]} : shape is {self.intertemporal_constants.shape}&#34;)
            result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
        i = i + 1

    self._ze_constants: np.ndarray = result
    return self._ze_constants</code></pre>
</details>
</dd>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.zer_difference_from_ssf"><code class="name">var <span class="ident">zer_difference_from_ssf</span></code></dt>
<dd>
<div class="desc"><p>In Ox: decl cz5 = zer - zel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def zer_difference_from_ssf(self):
    &#34;&#34;&#34;
    In Ox: decl cz5 = zer - zel
    &#34;&#34;&#34;
    return self._zer_difference_from_ssf</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="gcubed.projections.baseline_projections.BaselineProjections.compute_functions_of_future_exogenous_variables"><code class="name flex">
<span>def <span class="ident">compute_functions_of_future_exogenous_variables</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The rules governing the dynamic behaviour of variables depend on functions of the current and future exogenous variables.
These functions are evaluated and the results are stored in numpy matrices that match the number of rows
for the related vector of variables and that have a column for each year from the base projection year to the
last year in the projections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_functions_of_future_exogenous_variables(self):
    &#34;&#34;&#34;
    The rules governing the dynamic behaviour of variables depend on functions of the current and future exogenous variables.
    These functions are evaluated and the results are stored in numpy matrices that match the number of rows
    for the related vector of variables and that have a column for each year from the base projection year to the
    last year in the projections.
    &#34;&#34;&#34;

    # Set up the arrays that will be populated and initialise them to zeros.

    # // setup for baseline with optimization
    # decl id=invert(unit(nez)-c4n);
    # c4t=id*cz5;

    # decl mu2t=id*c6n;

    # id=invert(unit(njm)-ff-we*mu2t);
    # c6t=id*(cz4+we*c4t);

    # c4t=c4t+mu2t*c6t;
    # c4t=ones(rows(c4t),nobs).*c4t;
    # c6t=ones(rows(c6t),nobs).*c6t;
    # c2t=h2t*exog+c6t+bt2t*gam3t;

    # This is equivalent to h3t in the newsetsymbl.ox script (j by 1 dimensions)
    h3t: np.ndarray = np.zeros(shape=(self.sym_data.vector_length(vector_name=&#39;j1l&#39;), self.projection_years_count))

    # Populate for period T.

    # c4t=invert(unit(nez)-zel_exz_ssf)*cz5   (r by 1 dimensions)
    interim_calculation = self.stable_manifold.Gamma_rT @ self.ze_constants

    # c6t = invert(unit(j)-j1l_yjr_ssf-j1l_exz_ssf*mu2t) * (cz4+j1l_exz_ssf*c4t)
    #     = Gamma_jT (cz4+j1l_exz_ssf*interim_calculation)
    c6T_column = self.stable_manifold.Gamma_jT @ (self.j1_constants + self.state_space_form.delta(&#39;j1l&#39;, &#39;exz&#39;) @ interim_calculation)

    # c4t = c4t + mu2t * c6t (r by 1 dimensions)
    c4T_column = interim_calculation + self.stable_manifold.psi_rj @ c6T_column

    # c4t=ones(rows(c4t),nobs).*c4t (r by T dimensions)
    c4t: np.ndarray = np.tile(c4T_column, (1, self.projection_years_count))

    # c6t=ones(rows(c6t),nobs).*c6t (j by T dimensions)
    c6t: np.ndarray = np.tile(c6T_column, (1, self.projection_years_count))

    # c2t=h2t*exog+c6t    (j by T dimensions)
    c2t: np.ndarray = self.stable_manifold.H2 @ self.exo_projections + c6t

    # (s by T dimensions)
    c5t: np.ndarray = np.zeros(shape=(self.sym_data.vector_length(vector_name=&#39;x1l&#39;), self.projection_years_count))

    # (j by T dimensions)
    c2t_lead: np.ndarray = c2t.copy()
    c4t_lead: np.ndarray = c4t.copy()

    # Populate for earlier periods.
    j = self.projection_years_count-1
    for k in range(self.projection_years_count-1, -1, -1):

        # c5t[][k] = wvi*(x1l_exz_ssf*c4tl[][j] + cz2)          (s by 1 : note no need for T columns)
        c5t: np.ndarray = self.stable_manifold.Gamma_st @ (self.state_space_form.delta(&#39;x1l&#39;, &#39;exz&#39;) @ c4t_lead[:, [j]] + self.x1_constants)

        # c6t[][k] = fdeltinv*(th6t*c5t[][k] - j1l_exz_ssf*c4tl[][j] + c2tl[][j] - cz4)         (j rows)
        c6t[:, [k]] = self.stable_manifold.Gamma_jt @ (self.stable_manifold.common_factor @ c5t - self.state_space_form.delta(
            &#39;j1l&#39;, &#39;exz&#39;) @ c4t_lead[:, [j]] + c2t_lead[:, [j]] - self.j1_constants)

        # c5t[][k] = c5t[][k] + th2t*c6t[][k]
        c5t = c5t + self.stable_manifold.tau_sjt @ c6t[:, [k]]

        # c4t[][k] = mu1tl*c5t[][k] + c4tl[][j]
        c4t[:, [k]] = self.stable_manifold.M1_lead @ c5t + c4t_lead[:, [j]]

        # h3t[][k] = c6t[][k]
        h3t[:, [k]] = c6t[:, [k]].copy()

        # c2t[][k] = h2t*exog[][k] + h3t[][k]
        c2t[:, [k]] = self.stable_manifold.H2 @ self.exo_projections[:, [k]] + h3t[:, [k]]

        # c4tl[][k] = nmu4t*exog[][k] + zel_yjr_ssf*h3t[][k] + zel_exz_ssf*c4t[][k] + cz5
        c4t_lead[:, [k]] = self.stable_manifold.M2 @ self.exo_projections[:, [k]] + \
            self.state_space_form.delta(&#39;zel&#39;, &#39;yjr&#39;) @ h3t[:, [k]] + \
            self.state_space_form.delta(&#39;zel&#39;, &#39;exz&#39;) @ c4t[:, [k]] + \
            self.ze_constants

        c2t_lead = c2t.copy()

        j = k

    # Store the functions of future exogenous variables to access when doing projections.
    self._h3t = h3t.copy()
    self._c4t = c4t.copy()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gcubed.projections.base_projections.BaseProjections" href="base_projections.html#gcubed.projections.base_projections.BaseProjections">BaseProjections</a></b></code>:
<ul class="hlist">
<li><code><a title="gcubed.projections.base_projections.BaseProjections.database_projections" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.database_projections">database_projections</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.exo_projections" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.exo_projections">exo_projections</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.exo_projections_as_dataframe" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.exo_projections_as_dataframe">exo_projections_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.exz_projections" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.exz_projections">exz_projections</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.exz_projections_as_dataframe" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.exz_projections_as_dataframe">exz_projections_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.generate_database_projections" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.generate_database_projections">generate_database_projections</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.generate_publishable_projections" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.generate_publishable_projections">generate_publishable_projections</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.get_deviations_between_projections" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.get_deviations_between_projections">get_deviations_between_projections</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.get_year_labels" href="../base.html#gcubed.base.Base.get_year_labels">get_year_labels</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.graphable_projections" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.graphable_projections">graphable_projections</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.load_data" href="../base.html#gcubed.base.Base.load_data">load_data</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.long_rate_constants" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.long_rate_constants">long_rate_constants</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.longrate_calculation" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.longrate_calculation">longrate_calculation</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.preceding_projection_years" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.preceding_projection_years">preceding_projection_years</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.projection_years" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.projection_years">projection_years</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.projections" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.projections">projections</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.publishable_projections" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.publishable_projections">publishable_projections</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.simulation_data_columns" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.simulation_data_columns">simulation_data_columns</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.yjr_projections" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.yjr_projections">yjr_projections</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.yjr_projections_as_dataframe" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.yjr_projections_as_dataframe">yjr_projections_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.yxr_projections" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.yxr_projections">yxr_projections</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.yxr_projections_as_dataframe" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.yxr_projections_as_dataframe">yxr_projections_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.z1l_projections" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.z1l_projections">z1l_projections</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.z1l_projections_as_dataframe" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.z1l_projections_as_dataframe">z1l_projections_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.zel_projections" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.zel_projections">zel_projections</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.zel_projections_as_dataframe" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.zel_projections_as_dataframe">zel_projections_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.zeros" href="../base.html#gcubed.base.Base.zeros">zeros</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gcubed.projections" href="index.html">gcubed.projections</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gcubed.projections.baseline_projections.BaselineProjections" href="#gcubed.projections.baseline_projections.BaselineProjections">BaselineProjections</a></code></h4>
<ul class="">
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.PERTURBATION" href="#gcubed.projections.baseline_projections.BaselineProjections.PERTURBATION">PERTURBATION</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.base_year" href="#gcubed.projections.baseline_projections.BaselineProjections.base_year">base_year</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.base_year_exo" href="#gcubed.projections.baseline_projections.BaselineProjections.base_year_exo">base_year_exo</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.base_year_exz" href="#gcubed.projections.baseline_projections.BaselineProjections.base_year_exz">base_year_exz</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.base_year_j1r" href="#gcubed.projections.baseline_projections.BaselineProjections.base_year_j1r">base_year_j1r</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.base_year_lhs_values" href="#gcubed.projections.baseline_projections.BaselineProjections.base_year_lhs_values">base_year_lhs_values</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.base_year_observed_values_of_variables_adjusted_by_intertemporal_constants" href="#gcubed.projections.baseline_projections.BaselineProjections.base_year_observed_values_of_variables_adjusted_by_intertemporal_constants">base_year_observed_values_of_variables_adjusted_by_intertemporal_constants</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.base_year_original_projections_of_exz" href="#gcubed.projections.baseline_projections.BaselineProjections.base_year_original_projections_of_exz">base_year_original_projections_of_exz</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.base_year_original_projections_of_variables_adjusted_by_intertemporal_constants" href="#gcubed.projections.baseline_projections.BaselineProjections.base_year_original_projections_of_variables_adjusted_by_intertemporal_constants">base_year_original_projections_of_variables_adjusted_by_intertemporal_constants</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.base_year_original_projections_of_yjr" href="#gcubed.projections.baseline_projections.BaselineProjections.base_year_original_projections_of_yjr">base_year_original_projections_of_yjr</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.base_year_original_projections_of_yxr" href="#gcubed.projections.baseline_projections.BaselineProjections.base_year_original_projections_of_yxr">base_year_original_projections_of_yxr</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.base_year_original_projections_of_z1l" href="#gcubed.projections.baseline_projections.BaselineProjections.base_year_original_projections_of_z1l">base_year_original_projections_of_z1l</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.base_year_projections_of_variables_adjusted_by_intertemporal_constants" href="#gcubed.projections.baseline_projections.BaselineProjections.base_year_projections_of_variables_adjusted_by_intertemporal_constants">base_year_projections_of_variables_adjusted_by_intertemporal_constants</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.base_year_x1r" href="#gcubed.projections.baseline_projections.BaselineProjections.base_year_x1r">base_year_x1r</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.base_year_yjr" href="#gcubed.projections.baseline_projections.BaselineProjections.base_year_yjr">base_year_yjr</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.base_year_yxr" href="#gcubed.projections.baseline_projections.BaselineProjections.base_year_yxr">base_year_yxr</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.base_year_z1r" href="#gcubed.projections.baseline_projections.BaselineProjections.base_year_z1r">base_year_z1r</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.base_year_zer" href="#gcubed.projections.baseline_projections.BaselineProjections.base_year_zer">base_year_zer</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.c4t" href="#gcubed.projections.baseline_projections.BaselineProjections.c4t">c4t</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.compute_functions_of_future_exogenous_variables" href="#gcubed.projections.baseline_projections.BaselineProjections.compute_functions_of_future_exogenous_variables">compute_functions_of_future_exogenous_variables</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.configuration" href="#gcubed.projections.baseline_projections.BaselineProjections.configuration">configuration</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.database" href="#gcubed.projections.baseline_projections.BaselineProjections.database">database</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.exo_base_year_projections" href="#gcubed.projections.baseline_projections.BaselineProjections.exo_base_year_projections">exo_base_year_projections</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.exz_base_year_projections" href="#gcubed.projections.baseline_projections.BaselineProjections.exz_base_year_projections">exz_base_year_projections</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.h3t" href="#gcubed.projections.baseline_projections.BaselineProjections.h3t">h3t</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.has_simulation_layer_definitions" href="#gcubed.projections.baseline_projections.BaselineProjections.has_simulation_layer_definitions">has_simulation_layer_definitions</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.intertemporal_constants" href="#gcubed.projections.baseline_projections.BaselineProjections.intertemporal_constants">intertemporal_constants</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.j1_constants" href="#gcubed.projections.baseline_projections.BaselineProjections.j1_constants">j1_constants</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.j1r_difference_from_ssf" href="#gcubed.projections.baseline_projections.BaselineProjections.j1r_difference_from_ssf">j1r_difference_from_ssf</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.model" href="#gcubed.projections.baseline_projections.BaselineProjections.model">model</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.parameters" href="#gcubed.projections.baseline_projections.BaselineProjections.parameters">parameters</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.partial_derivatives_wrt_intertemporal_constants" href="#gcubed.projections.baseline_projections.BaselineProjections.partial_derivatives_wrt_intertemporal_constants">partial_derivatives_wrt_intertemporal_constants</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.perturbed_variable_details" href="#gcubed.projections.baseline_projections.BaselineProjections.perturbed_variable_details">perturbed_variable_details</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.publishable_data" href="#gcubed.projections.baseline_projections.BaselineProjections.publishable_data">publishable_data</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.reference_c4t_used_to_compute_intertemporal_constants" href="#gcubed.projections.baseline_projections.BaselineProjections.reference_c4t_used_to_compute_intertemporal_constants">reference_c4t_used_to_compute_intertemporal_constants</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.reference_h3t_used_to_compute_intertemporal_constants" href="#gcubed.projections.baseline_projections.BaselineProjections.reference_h3t_used_to_compute_intertemporal_constants">reference_h3t_used_to_compute_intertemporal_constants</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.simulation_layer_definitions" href="#gcubed.projections.baseline_projections.BaselineProjections.simulation_layer_definitions">simulation_layer_definitions</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.stable_manifold" href="#gcubed.projections.baseline_projections.BaselineProjections.stable_manifold">stable_manifold</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.state_space_form" href="#gcubed.projections.baseline_projections.BaselineProjections.state_space_form">state_space_form</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.sym_data" href="#gcubed.projections.baseline_projections.BaselineProjections.sym_data">sym_data</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.using_rolled_projections" href="#gcubed.projections.baseline_projections.BaselineProjections.using_rolled_projections">using_rolled_projections</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.x1_constants" href="#gcubed.projections.baseline_projections.BaselineProjections.x1_constants">x1_constants</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.x1_observed_values_in_base_projection_year" href="#gcubed.projections.baseline_projections.BaselineProjections.x1_observed_values_in_base_projection_year">x1_observed_values_in_base_projection_year</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.x1r_difference_from_ssf" href="#gcubed.projections.baseline_projections.BaselineProjections.x1r_difference_from_ssf">x1r_difference_from_ssf</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.yjr_base_year_projections" href="#gcubed.projections.baseline_projections.BaselineProjections.yjr_base_year_projections">yjr_base_year_projections</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.yxr_base_year_projections" href="#gcubed.projections.baseline_projections.BaselineProjections.yxr_base_year_projections">yxr_base_year_projections</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.z1_constants" href="#gcubed.projections.baseline_projections.BaselineProjections.z1_constants">z1_constants</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.z1l_base_year_projections" href="#gcubed.projections.baseline_projections.BaselineProjections.z1l_base_year_projections">z1l_base_year_projections</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.z1r_difference_from_ssf" href="#gcubed.projections.baseline_projections.BaselineProjections.z1r_difference_from_ssf">z1r_difference_from_ssf</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.ze_constants" href="#gcubed.projections.baseline_projections.BaselineProjections.ze_constants">ze_constants</a></code></li>
<li><code><a title="gcubed.projections.baseline_projections.BaselineProjections.zer_difference_from_ssf" href="#gcubed.projections.baseline_projections.BaselineProjections.zer_difference_from_ssf">zer_difference_from_ssf</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
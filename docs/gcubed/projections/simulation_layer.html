<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gcubed.projections.simulation_layer API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gcubed.projections.simulation_layer</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># ------------------------------------------------------------------
# Purpose: Compute and provide access to simulations that overlay
# baseline projections and possibly other simulation layers.
# Author: Geoff Shuetrim
# ------------------------------------------------------------------
import logging
import os
import pandas as pd
import numpy as np
import gcubed.constants as CONSTANTS
from gcubed.data.database import Database
from gcubed.projections.base_projections import BaseProjections
from gcubed.projections.baseline_projections import BaselineProjections
from gcubed.projections.simulation_layer_definition import SimulationLayerDefinition

class SimulationLayer(BaseProjections):
    &#34;&#34;&#34;
    TODO: Complete the simulations implementation
    Compute model simulations over the projection horizon.
    &#34;&#34;&#34;

    def __init__(self, simulation_layer_definition: SimulationLayerDefinition, baseline_projections: BaselineProjections, previous_simulation_layer=None) -&gt; None:
        &#34;&#34;&#34;
        Use this constructor for any simulation that is the first simulation layer applied to baseline projections.
        &#34;&#34;&#34;
        assert baseline_projections is not None
        self._baseline_projections = baseline_projections
        self._stable_manifold = self.baseline_projections.stable_manifold

        self._previous_simulation_layer = previous_simulation_layer

        assert simulation_layer_definition is not None
        self._simulation_layer_definition = simulation_layer_definition

        assert os.path.isfile(self.data_file)

        if self.previous_simulation_layer is not None:
            assert self.event_year &gt; self.previous_simulation_layer.event_year
        else:
            assert self.event_year &gt; self.baseline_projections.base_year

        self.load_simulation_data()

        self.__generate_simulation_projections()

        self.generate_database_projections()

        self.generate_publishable_projections()

        self.__validate()

        logging.info(f&#34;The {self.name} projections have been generated.&#34;)



    def __validate(self):
        &#34;&#34;&#34;
        TODO:  Validate the simulations: 
        &#34;&#34;&#34;

    @property
    def simulation_layer_definition(self) -&gt; SimulationLayerDefinition:
        return self._simulation_layer_definition

    @property
    def name(self) -&gt; str:
        return self._simulation_layer_definition.name

    @property
    def description(self) -&gt; str:
        return self._simulation_layer_definition.description

    @property
    def data_file(self) -&gt; str:
        &#34;&#34;&#34;
        Returns the string specifying the name of the file containing the simulation data.
        &#34;&#34;&#34;
        return self.simulation_layer_definition.data_filename

    @property
    def event_year(self) -&gt; str:
        &#34;&#34;&#34;
        Returns the event year for the simulation layer.
        This is the first year that knowledge of the simulation event becomes available
        to agents.
        &#34;&#34;&#34;
        return self.simulation_layer_definition.event_year

    @property
    def previous_simulation_layer(self):
        &#34;&#34;&#34;
        Note that the return type is not specified because the SimulationLayer class cannot
        refer to itself in its own definition.

        Returns the previous simulation layer, or none if there is none.
        &#34;&#34;&#34;
        if hasattr(self,&#39;_previous_simulation_layer&#39;):
            return self._previous_simulation_layer
        return None

    @property
    def previous_projection_layer(self) -&gt; BaseProjections:
        if self.previous_simulation_layer is None:
            return self.baseline_projections
        return self.previous_simulation_layer

    @property
    def baseline_projections(self) -&gt; BaselineProjections:
        &#34;&#34;&#34;
        Returns the baseline projections underpinning this simulation
        &#34;&#34;&#34;
        if self.previous_simulation_layer is not None:
            return self.previous_simulation_layer.baseline_projections
        return self._baseline_projections

    @property
    def database(self) -&gt; Database:
        &#34;&#34;&#34;
        Returns the database associated with the baseline projections.
        &#34;&#34;&#34;
        return self.baseline_projections.database

    @property
    def simulation_variables(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Returns the variable summary information for the simulation data.
        &#34;&#34;&#34;
        return self._simulation_variables

    @property
    def simulation_data(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Returns the simulation data.
        &#34;&#34;&#34;
        return self._simulation_data

    def load_simulation_data(self):
        &#34;&#34;&#34;
        
        TODO: Check if there are simulations where shocks to state variable initial values are not allowed.

        Load and apply the simulation data that affect exogenous variables. 
        Load and apply the simulation data that affect state variables initial values.
        
        When a variable has data in the simulation file, load that into the appropriate 
        SYM-specified row of the exogenous variable projections, from the start projection year onwards.

        When a variable has data in the simulation file (control.csv by default), load that into the appropriate 
        SYM-specified row of the state variable projection start year vector and ignore
        data in the control file for all years after that projection start year.

        Adjust the simulation data as follows, depending on the units of the variable:
            gdp - multiply by (projection base year YRATR / 100).
            mmgdp - same as gdp
            btugdp - same as gdp 
            gwhgdp - same as gdp
            usgdp - divide the value in the control file by 100.
            All other units - divide the value in the control file by 100.
        &#34;&#34;&#34;

        # Load the simulation data.
        filename: str = self.data_file
        assert os.path.isfile(filename)
        (self._simulation_variables, self._simulation_data) = self.load_data(filename)
        self._simulation_variables.columns = [&#39;name&#39;]
        self._simulation_variables.index = self._simulation_variables.name
        self._simulation_data = self._simulation_data.astype(float)
        self._simulation_data.index = self._simulation_variables.name

        try:
            self._simulation_data = self._simulation_data.loc[:, self.projection_years_column_labels]
        except:
            raise Exception(f&#34;The simulation data in {self.data_file} should have data from {self.event_year} to {self.end_year}&#34;)

        # Iterate the shocks, allocating the shocks
        yratr: pd.DataFrame = self.baseline_projections.database.get_data(name_regular_expression=f&#34;^{CONSTANTS.US_REAL_GDP_RATIO_PREFIX}\(&#34;, years=[self.base_year])
        yratr.index = self.sym_data.regions_members

        for variable_name in self._simulation_variables.index:
            variable_region: str = str(self.baseline_projections.database.variables.loc[variable_name, &#39;region&#39;])
            variable_units: str = str(self.sym_data.combined_variable_summary.loc[variable_name, &#39;units&#39;])
            data: pd.DataFrame = self._simulation_data.loc[[variable_name], :] / 100
            vector_name = self.sym_data.projection_vector_for_variable(variable_name=variable_name)
            variable_sequence: int = self.sym_data.variable_index(vector_name=vector_name, variable_name=variable_name)
            yratr_for_region: float = float(yratr.loc[variable_region, :].values[0])
            match variable_units:
                case &#39;gdp&#39;:
                    data = data * yratr_for_region
                case &#39;mmgdp&#39;:
                    data = data * yratr_for_region
                case &#39;btugdp&#39;:
                    data = data * yratr_for_region
                case &#39;gwhgdp&#39;:
                    data = data * yratr_for_region
                case _:
                    pass

            self._exo_projections = self.previous_projection_layer.exo_projections_as_dataframe.loc[:, self.projection_years_column_labels]

            x1_initial_values: pd.DataFrame = self.previous_projection_layer.yxr_projections_as_dataframe.loc[:, [str(self.event_year)]].copy()

            match vector_name:
                case &#39;exo&#39;:
                    self._exo_projections.loc[[variable_name], self.projection_years_column_labels] += data
                    pass

                case &#39;x1l&#39;:
                    x1_initial_values.loc[[variable_name], [str(self.event_year)]] += float(data[0])
                    pass

            self._x1_initial_values: np.ndarray = x1_initial_values.to_numpy()


    def compute_functions_of_future_exogenous_variables(self):
        &#34;&#34;&#34;
        The rules governing the dynamic behaviour of variables depend on functions of the current and future exogenous variables.
        These functions are evaluated and the results are stored in numpy matrices that match the number of rows
        for the related vector of variables and that have a column for each year from the base projection year to the
        last year in the projections.
        &#34;&#34;&#34;

        # Set up the arrays that will be populated and initialise them to zeros.

        # This is equivalent to h3t in the newsetsymbl.ox script (j by 1 dimensions)
        self._h3t: np.ndarray = np.zeros(shape=(self.sym_data.vector_length(vector_name=&#39;j1l&#39;), self.projection_years_count))

        # Populate for period T.

        # c4t=invert(unit(nez)-zel_exz_ssf)*cz5   (r by 1 dimensions)
        interim_calculation = self.stable_manifold.Gamma_rT @ self.baseline_projections.ze_constants

        # c6t = invert(unit(j)-j1l_yjr_ssf-j1l_exz_ssf*mu2t) * (cz4+j1l_exz_ssf*c4t)
        # c6t = invert(unit(j)-j1l_yjr_ssf-j1l_exz_ssf*mu2t) * (cz4+j1l_exz_ssf*c4t)
        #     = Gamma_jT (cz4+j1l_exz_ssf*interim_calculation)
        c6T_column = self.stable_manifold.Gamma_jT @ (self.baseline_projections.j1_constants + self.state_space_form.delta(&#39;j1l&#39;, &#39;exz&#39;) @ interim_calculation)

        # c4t = c4t + mu2t * c6t (r by 1 dimensions)
        c4T_column = interim_calculation + self.stable_manifold.psi_rj @ c6T_column

        # c4t=ones(rows(c4t),nobs).*c4t (r by T dimensions)
        self._c4t: np.ndarray = np.tile(c4T_column, (1, self.projection_years_count))

        # c6t=ones(rows(c6t),nobs).*c6t (j by T dimensions)
        c6t: np.ndarray = np.tile(c6T_column, (1, self.projection_years_count))

        # c2t=h2t*exog+c6t    (j by T dimensions)
        c2t: np.ndarray = self.stable_manifold.H2 @ self.exo_projections + c6t

        # (s by T dimensions)
        c5t: np.ndarray = np.zeros(shape=(self.sym_data.vector_length(vector_name=&#39;x1l&#39;), self.projection_years_count))

        # (j by T dimensions)
        c2t_lead: np.ndarray = c2t.copy()
        c4t_lead: np.ndarray = self._c4t.copy()

        # Populate for earlier periods.
        j = self.projection_years_count-1
        for k in range(self.projection_years_count-1, -1, -1):

            # c5t[][k] = wvi*(x1l_exz_ssf*c4tl[][j] + cz2)          (s by 1 : note no need for T columns)
            c5t: np.ndarray = self.stable_manifold.Gamma_st @ (self.state_space_form.delta(&#39;x1l&#39;, &#39;exz&#39;) @
                                                               c4t_lead[:, [j]] + self.baseline_projections.x1_constants)

            # c6t[][k] = fdeltinv*(th6t*c5t[][k] - j1l_exz_ssf*c4tl[][j] + c2tl[][j] - cz4)         (j rows)
            c6t[:, [k]] = self.stable_manifold.Gamma_jt @ (self.stable_manifold.common_factor @ c5t - self.state_space_form.delta(
                &#39;j1l&#39;, &#39;exz&#39;) @ c4t_lead[:, [j]] + c2t_lead[:, [j]] - self.baseline_projections.j1_constants)

            # c5t[][k] = c5t[][k] + th2t*c6t[][k]
            c5t = c5t + self.stable_manifold.tau_sjt @ c6t[:, [k]]

            # c4t[][k] = mu1tl*c5t[][k] + c4tl[][j]
            self._c4t[:, [k]] = self.stable_manifold.M1_lead @ c5t + c4t_lead[:, [j]]

            # h3t[][k] = c6t[][k]
            self._h3t[:, [k]] = c6t[:, [k]].copy()

            # c2t[][k] = h2t*exog[][k] + h3t[][k]
            c2t[:, [k]] = self.stable_manifold.H2 @ self.exo_projections[:, [k]] + self._h3t[:, [k]]

            # c4tl[][k] = nmu4t*exog[][k] + zel_yjr_ssf*h3t[][k] + zel_exz_ssf*c4t[][k] + cz5
            c4t_lead[:, [k]] = self.stable_manifold.M2 @ self.exo_projections[:, [k]] + \
                self.state_space_form.delta(&#39;zel&#39;, &#39;yjr&#39;) @ self._h3t[:, [k]] + \
                self.state_space_form.delta(&#39;zel&#39;, &#39;exz&#39;) @ self._c4t[:, [k]] + \
                self.baseline_projections.ze_constants

            c2t_lead = c2t.copy()

            j = k


    @property
    def h3t(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Equivalent to h3t in the Ox implementation
        Functions of current and future exogenous variables affecting J1.
        &#34;&#34;&#34;
        return self._h3t

    @property
    def c4t(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Equivalent to c4t in the Ox implementation
        Functions of current and future exogenous variables affecting ZE.
        &#34;&#34;&#34;
        return self._c4t

    def __generate_simulation_projections(self):
        &#34;&#34;&#34;
        Implements the projection logic in msgsimBL2.ox.

        Recalculate the functions of future exogenous variables, incorporating 
        the updated exogenous variable projections and  all constant adjustments, 
        the intertemporal constants and the other constants  capturing the difference 
        between the SSF equation results in the base year and the observed 
        values in the base year.
        
        Do the actual projection calculations
        Set up properties so that baseline projections are available for all vectors.

        Re-sort the variable projections into the same order as the original database.

        Set up property to access baseline projections as the original data in CSV format.

        &#34;&#34;&#34;
        # Recalculate functions of future exogenous variables now that cycle information is included
        self.compute_functions_of_future_exogenous_variables()

        # Project the state variables, X1, and store in dataframe X.
        constantBL: pd.DataFrame = pd.DataFrame(self.stable_manifold.Znew @ self.exo_projections +
            self.state_space_form.delta(&#39;x1l&#39;, &#39;yjr&#39;) @ self.h3t +
            self.state_space_form.delta(&#39;x1l&#39;, &#39;exz&#39;) @ self.c4t +
            self.baseline_projections.x1_constants)

        constantBL.columns = self.projection_years_column_labels
        constantBL.index = self.sym_data.vector_variable_names(vector_name=&#39;x1l&#39;)
        yxr: pd.DataFrame = self.zeros(rows=self.sym_data.vector_length(&#39;x1l&#39;), cols=self.projection_years_count)
        yxr.columns = self.projection_years_column_labels
        yxr.index = self.sym_data.vector_variable_names(vector_name=&#39;x1l&#39;)
        yxr.loc[:, [str(self.event_year)]] = self._x1_initial_values
        previous_year_label = str(self.event_year)
        for year in self.projection_years_column_labels[1:]:
            yxr.loc[:, [year]] = self.stable_manifold.Anew @ yxr.loc[:, [previous_year_label]].to_numpy() + \
                constantBL.loc[:, [previous_year_label]].to_numpy()
            previous_year_label = year
        self._yxr_projections: pd.DataFrame = yxr

        # Project J1
        # er = h1t*x + h2t*exog[][1:nobs] + h3t
        # yjr: pd.DataFrame = pd.DataFrame(self.stable_manifold.H1 @ (yxr.to_numpy()))
        yjr: pd.DataFrame = pd.DataFrame(self.stable_manifold.H1 @ (yxr.to_numpy()) + self.stable_manifold.H2 @ self.exo_projections + self.h3t)
        yjr.columns = self.projection_years_column_labels
        yjr.index = self.sym_data.vector_variable_names(vector_name=&#39;j1l&#39;)
        self._yjr_projections: pd.DataFrame = yjr

        # Project time t expected value of ZE in period t+1 (EXZ)
        # Project time t expected value of ZE in period t+1 (EXZ)
        # tzl = mu1t*x + mu4t*exog[][1:nobs] + c4t
        exz: pd.DataFrame = pd.DataFrame(
            self.stable_manifold.mu1 @ yxr.to_numpy() +
            self.stable_manifold.mu2 @ self.exo_projections +
            self.c4t
        )
        exz.columns = self.projection_years_column_labels
        exz.index = self.sym_data.vector_variable_names(vector_name=&#39;zer&#39;)
        self._exz_projections: pd.DataFrame = exz

        # Project time t values of ZE using the SSF equation (this should be done with M1 and M2?)
        # What about the functions of future exogenous variables and the constant adjustments
        zel: pd.DataFrame = pd.DataFrame(
            self.state_space_form.delta(&#39;zel&#39;, &#39;yxr&#39;) @ self.yxr_projections +
            self.state_space_form.delta(&#39;zel&#39;, &#39;exz&#39;) @ self.exz_projections +
            self.state_space_form.delta(&#39;zel&#39;, &#39;yjr&#39;) @ self.yjr_projections +
            self.state_space_form.delta(&#39;zel&#39;, &#39;exo&#39;) @ self.exo_projections)
        zel.columns = self.projection_years_column_labels
        zel.index = self.sym_data.vector_variable_names(vector_name=&#39;zel&#39;)
        self._zel_projections: pd.DataFrame = zel + self.baseline_projections.ze_constants

        # Project Z1 using the SSF equation
        z1l: pd.DataFrame = pd.DataFrame(
            self.state_space_form.delta(&#39;z1l&#39;, &#39;yxr&#39;) @ self.yxr_projections +
            self.state_space_form.delta(&#39;z1l&#39;, &#39;exz&#39;) @ self.exz_projections +
            self.state_space_form.delta(&#39;z1l&#39;, &#39;yjr&#39;) @ self.yjr_projections +
            self.state_space_form.delta(&#39;z1l&#39;, &#39;exo&#39;) @ self.exo_projections)
        z1l.columns = self.projection_years_column_labels
        z1l.index = self.sym_data.vector_variable_names(vector_name=&#39;z1l&#39;)
        self._z1l_projections: pd.DataFrame = z1l + self.baseline_projections.z1_constants

        # Combine the projections into a single dataframe in the same order as the database
        self._projections = pd.concat([
            self.yxr_projections_as_dataframe,
            self.z1l_projections_as_dataframe,
            self.zel_projections_as_dataframe,
            self.yjr_projections_as_dataframe,
            self.exo_projections_as_dataframe])
        database_ordered_variable_list: pd.DataFrame = self.baseline_projections.database.variables.name
        self._projections = pd.concat([database_ordered_variable_list, self._projections], axis=1)
        self._projections.drop(&#39;name&#39;, inplace=True, axis=1)

        # Concatenate with the projections from the previous layer to get complete projections from the base projection
        # year through to the end projection year
        self._projections = pd.concat([self.previous_projection_layer.projections.loc[:, self.preceding_projection_years_column_labels], self.projections], axis=1)

        self._projections = self._projections.astype(float)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gcubed.projections.simulation_layer.SimulationLayer"><code class="flex name class">
<span>class <span class="ident">SimulationLayer</span></span>
<span>(</span><span>simulation_layer_definition: <a title="gcubed.projections.simulation_layer_definition.SimulationLayerDefinition" href="simulation_layer_definition.html#gcubed.projections.simulation_layer_definition.SimulationLayerDefinition">SimulationLayerDefinition</a>, baseline_projections: <a title="gcubed.projections.baseline_projections.BaselineProjections" href="baseline_projections.html#gcubed.projections.baseline_projections.BaselineProjections">BaselineProjections</a>, previous_simulation_layer=None)</span>
</code></dt>
<dd>
<div class="desc"><p>TODO: Complete the simulations implementation
Compute model simulations over the projection horizon.</p>
<p>Use this constructor for any simulation that is the first simulation layer applied to baseline projections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SimulationLayer(BaseProjections):
    &#34;&#34;&#34;
    TODO: Complete the simulations implementation
    Compute model simulations over the projection horizon.
    &#34;&#34;&#34;

    def __init__(self, simulation_layer_definition: SimulationLayerDefinition, baseline_projections: BaselineProjections, previous_simulation_layer=None) -&gt; None:
        &#34;&#34;&#34;
        Use this constructor for any simulation that is the first simulation layer applied to baseline projections.
        &#34;&#34;&#34;
        assert baseline_projections is not None
        self._baseline_projections = baseline_projections
        self._stable_manifold = self.baseline_projections.stable_manifold

        self._previous_simulation_layer = previous_simulation_layer

        assert simulation_layer_definition is not None
        self._simulation_layer_definition = simulation_layer_definition

        assert os.path.isfile(self.data_file)

        if self.previous_simulation_layer is not None:
            assert self.event_year &gt; self.previous_simulation_layer.event_year
        else:
            assert self.event_year &gt; self.baseline_projections.base_year

        self.load_simulation_data()

        self.__generate_simulation_projections()

        self.generate_database_projections()

        self.generate_publishable_projections()

        self.__validate()

        logging.info(f&#34;The {self.name} projections have been generated.&#34;)



    def __validate(self):
        &#34;&#34;&#34;
        TODO:  Validate the simulations: 
        &#34;&#34;&#34;

    @property
    def simulation_layer_definition(self) -&gt; SimulationLayerDefinition:
        return self._simulation_layer_definition

    @property
    def name(self) -&gt; str:
        return self._simulation_layer_definition.name

    @property
    def description(self) -&gt; str:
        return self._simulation_layer_definition.description

    @property
    def data_file(self) -&gt; str:
        &#34;&#34;&#34;
        Returns the string specifying the name of the file containing the simulation data.
        &#34;&#34;&#34;
        return self.simulation_layer_definition.data_filename

    @property
    def event_year(self) -&gt; str:
        &#34;&#34;&#34;
        Returns the event year for the simulation layer.
        This is the first year that knowledge of the simulation event becomes available
        to agents.
        &#34;&#34;&#34;
        return self.simulation_layer_definition.event_year

    @property
    def previous_simulation_layer(self):
        &#34;&#34;&#34;
        Note that the return type is not specified because the SimulationLayer class cannot
        refer to itself in its own definition.

        Returns the previous simulation layer, or none if there is none.
        &#34;&#34;&#34;
        if hasattr(self,&#39;_previous_simulation_layer&#39;):
            return self._previous_simulation_layer
        return None

    @property
    def previous_projection_layer(self) -&gt; BaseProjections:
        if self.previous_simulation_layer is None:
            return self.baseline_projections
        return self.previous_simulation_layer

    @property
    def baseline_projections(self) -&gt; BaselineProjections:
        &#34;&#34;&#34;
        Returns the baseline projections underpinning this simulation
        &#34;&#34;&#34;
        if self.previous_simulation_layer is not None:
            return self.previous_simulation_layer.baseline_projections
        return self._baseline_projections

    @property
    def database(self) -&gt; Database:
        &#34;&#34;&#34;
        Returns the database associated with the baseline projections.
        &#34;&#34;&#34;
        return self.baseline_projections.database

    @property
    def simulation_variables(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Returns the variable summary information for the simulation data.
        &#34;&#34;&#34;
        return self._simulation_variables

    @property
    def simulation_data(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Returns the simulation data.
        &#34;&#34;&#34;
        return self._simulation_data

    def load_simulation_data(self):
        &#34;&#34;&#34;
        
        TODO: Check if there are simulations where shocks to state variable initial values are not allowed.

        Load and apply the simulation data that affect exogenous variables. 
        Load and apply the simulation data that affect state variables initial values.
        
        When a variable has data in the simulation file, load that into the appropriate 
        SYM-specified row of the exogenous variable projections, from the start projection year onwards.

        When a variable has data in the simulation file (control.csv by default), load that into the appropriate 
        SYM-specified row of the state variable projection start year vector and ignore
        data in the control file for all years after that projection start year.

        Adjust the simulation data as follows, depending on the units of the variable:
            gdp - multiply by (projection base year YRATR / 100).
            mmgdp - same as gdp
            btugdp - same as gdp 
            gwhgdp - same as gdp
            usgdp - divide the value in the control file by 100.
            All other units - divide the value in the control file by 100.
        &#34;&#34;&#34;

        # Load the simulation data.
        filename: str = self.data_file
        assert os.path.isfile(filename)
        (self._simulation_variables, self._simulation_data) = self.load_data(filename)
        self._simulation_variables.columns = [&#39;name&#39;]
        self._simulation_variables.index = self._simulation_variables.name
        self._simulation_data = self._simulation_data.astype(float)
        self._simulation_data.index = self._simulation_variables.name

        try:
            self._simulation_data = self._simulation_data.loc[:, self.projection_years_column_labels]
        except:
            raise Exception(f&#34;The simulation data in {self.data_file} should have data from {self.event_year} to {self.end_year}&#34;)

        # Iterate the shocks, allocating the shocks
        yratr: pd.DataFrame = self.baseline_projections.database.get_data(name_regular_expression=f&#34;^{CONSTANTS.US_REAL_GDP_RATIO_PREFIX}\(&#34;, years=[self.base_year])
        yratr.index = self.sym_data.regions_members

        for variable_name in self._simulation_variables.index:
            variable_region: str = str(self.baseline_projections.database.variables.loc[variable_name, &#39;region&#39;])
            variable_units: str = str(self.sym_data.combined_variable_summary.loc[variable_name, &#39;units&#39;])
            data: pd.DataFrame = self._simulation_data.loc[[variable_name], :] / 100
            vector_name = self.sym_data.projection_vector_for_variable(variable_name=variable_name)
            variable_sequence: int = self.sym_data.variable_index(vector_name=vector_name, variable_name=variable_name)
            yratr_for_region: float = float(yratr.loc[variable_region, :].values[0])
            match variable_units:
                case &#39;gdp&#39;:
                    data = data * yratr_for_region
                case &#39;mmgdp&#39;:
                    data = data * yratr_for_region
                case &#39;btugdp&#39;:
                    data = data * yratr_for_region
                case &#39;gwhgdp&#39;:
                    data = data * yratr_for_region
                case _:
                    pass

            self._exo_projections = self.previous_projection_layer.exo_projections_as_dataframe.loc[:, self.projection_years_column_labels]

            x1_initial_values: pd.DataFrame = self.previous_projection_layer.yxr_projections_as_dataframe.loc[:, [str(self.event_year)]].copy()

            match vector_name:
                case &#39;exo&#39;:
                    self._exo_projections.loc[[variable_name], self.projection_years_column_labels] += data
                    pass

                case &#39;x1l&#39;:
                    x1_initial_values.loc[[variable_name], [str(self.event_year)]] += float(data[0])
                    pass

            self._x1_initial_values: np.ndarray = x1_initial_values.to_numpy()


    def compute_functions_of_future_exogenous_variables(self):
        &#34;&#34;&#34;
        The rules governing the dynamic behaviour of variables depend on functions of the current and future exogenous variables.
        These functions are evaluated and the results are stored in numpy matrices that match the number of rows
        for the related vector of variables and that have a column for each year from the base projection year to the
        last year in the projections.
        &#34;&#34;&#34;

        # Set up the arrays that will be populated and initialise them to zeros.

        # This is equivalent to h3t in the newsetsymbl.ox script (j by 1 dimensions)
        self._h3t: np.ndarray = np.zeros(shape=(self.sym_data.vector_length(vector_name=&#39;j1l&#39;), self.projection_years_count))

        # Populate for period T.

        # c4t=invert(unit(nez)-zel_exz_ssf)*cz5   (r by 1 dimensions)
        interim_calculation = self.stable_manifold.Gamma_rT @ self.baseline_projections.ze_constants

        # c6t = invert(unit(j)-j1l_yjr_ssf-j1l_exz_ssf*mu2t) * (cz4+j1l_exz_ssf*c4t)
        # c6t = invert(unit(j)-j1l_yjr_ssf-j1l_exz_ssf*mu2t) * (cz4+j1l_exz_ssf*c4t)
        #     = Gamma_jT (cz4+j1l_exz_ssf*interim_calculation)
        c6T_column = self.stable_manifold.Gamma_jT @ (self.baseline_projections.j1_constants + self.state_space_form.delta(&#39;j1l&#39;, &#39;exz&#39;) @ interim_calculation)

        # c4t = c4t + mu2t * c6t (r by 1 dimensions)
        c4T_column = interim_calculation + self.stable_manifold.psi_rj @ c6T_column

        # c4t=ones(rows(c4t),nobs).*c4t (r by T dimensions)
        self._c4t: np.ndarray = np.tile(c4T_column, (1, self.projection_years_count))

        # c6t=ones(rows(c6t),nobs).*c6t (j by T dimensions)
        c6t: np.ndarray = np.tile(c6T_column, (1, self.projection_years_count))

        # c2t=h2t*exog+c6t    (j by T dimensions)
        c2t: np.ndarray = self.stable_manifold.H2 @ self.exo_projections + c6t

        # (s by T dimensions)
        c5t: np.ndarray = np.zeros(shape=(self.sym_data.vector_length(vector_name=&#39;x1l&#39;), self.projection_years_count))

        # (j by T dimensions)
        c2t_lead: np.ndarray = c2t.copy()
        c4t_lead: np.ndarray = self._c4t.copy()

        # Populate for earlier periods.
        j = self.projection_years_count-1
        for k in range(self.projection_years_count-1, -1, -1):

            # c5t[][k] = wvi*(x1l_exz_ssf*c4tl[][j] + cz2)          (s by 1 : note no need for T columns)
            c5t: np.ndarray = self.stable_manifold.Gamma_st @ (self.state_space_form.delta(&#39;x1l&#39;, &#39;exz&#39;) @
                                                               c4t_lead[:, [j]] + self.baseline_projections.x1_constants)

            # c6t[][k] = fdeltinv*(th6t*c5t[][k] - j1l_exz_ssf*c4tl[][j] + c2tl[][j] - cz4)         (j rows)
            c6t[:, [k]] = self.stable_manifold.Gamma_jt @ (self.stable_manifold.common_factor @ c5t - self.state_space_form.delta(
                &#39;j1l&#39;, &#39;exz&#39;) @ c4t_lead[:, [j]] + c2t_lead[:, [j]] - self.baseline_projections.j1_constants)

            # c5t[][k] = c5t[][k] + th2t*c6t[][k]
            c5t = c5t + self.stable_manifold.tau_sjt @ c6t[:, [k]]

            # c4t[][k] = mu1tl*c5t[][k] + c4tl[][j]
            self._c4t[:, [k]] = self.stable_manifold.M1_lead @ c5t + c4t_lead[:, [j]]

            # h3t[][k] = c6t[][k]
            self._h3t[:, [k]] = c6t[:, [k]].copy()

            # c2t[][k] = h2t*exog[][k] + h3t[][k]
            c2t[:, [k]] = self.stable_manifold.H2 @ self.exo_projections[:, [k]] + self._h3t[:, [k]]

            # c4tl[][k] = nmu4t*exog[][k] + zel_yjr_ssf*h3t[][k] + zel_exz_ssf*c4t[][k] + cz5
            c4t_lead[:, [k]] = self.stable_manifold.M2 @ self.exo_projections[:, [k]] + \
                self.state_space_form.delta(&#39;zel&#39;, &#39;yjr&#39;) @ self._h3t[:, [k]] + \
                self.state_space_form.delta(&#39;zel&#39;, &#39;exz&#39;) @ self._c4t[:, [k]] + \
                self.baseline_projections.ze_constants

            c2t_lead = c2t.copy()

            j = k


    @property
    def h3t(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Equivalent to h3t in the Ox implementation
        Functions of current and future exogenous variables affecting J1.
        &#34;&#34;&#34;
        return self._h3t

    @property
    def c4t(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Equivalent to c4t in the Ox implementation
        Functions of current and future exogenous variables affecting ZE.
        &#34;&#34;&#34;
        return self._c4t

    def __generate_simulation_projections(self):
        &#34;&#34;&#34;
        Implements the projection logic in msgsimBL2.ox.

        Recalculate the functions of future exogenous variables, incorporating 
        the updated exogenous variable projections and  all constant adjustments, 
        the intertemporal constants and the other constants  capturing the difference 
        between the SSF equation results in the base year and the observed 
        values in the base year.
        
        Do the actual projection calculations
        Set up properties so that baseline projections are available for all vectors.

        Re-sort the variable projections into the same order as the original database.

        Set up property to access baseline projections as the original data in CSV format.

        &#34;&#34;&#34;
        # Recalculate functions of future exogenous variables now that cycle information is included
        self.compute_functions_of_future_exogenous_variables()

        # Project the state variables, X1, and store in dataframe X.
        constantBL: pd.DataFrame = pd.DataFrame(self.stable_manifold.Znew @ self.exo_projections +
            self.state_space_form.delta(&#39;x1l&#39;, &#39;yjr&#39;) @ self.h3t +
            self.state_space_form.delta(&#39;x1l&#39;, &#39;exz&#39;) @ self.c4t +
            self.baseline_projections.x1_constants)

        constantBL.columns = self.projection_years_column_labels
        constantBL.index = self.sym_data.vector_variable_names(vector_name=&#39;x1l&#39;)
        yxr: pd.DataFrame = self.zeros(rows=self.sym_data.vector_length(&#39;x1l&#39;), cols=self.projection_years_count)
        yxr.columns = self.projection_years_column_labels
        yxr.index = self.sym_data.vector_variable_names(vector_name=&#39;x1l&#39;)
        yxr.loc[:, [str(self.event_year)]] = self._x1_initial_values
        previous_year_label = str(self.event_year)
        for year in self.projection_years_column_labels[1:]:
            yxr.loc[:, [year]] = self.stable_manifold.Anew @ yxr.loc[:, [previous_year_label]].to_numpy() + \
                constantBL.loc[:, [previous_year_label]].to_numpy()
            previous_year_label = year
        self._yxr_projections: pd.DataFrame = yxr

        # Project J1
        # er = h1t*x + h2t*exog[][1:nobs] + h3t
        # yjr: pd.DataFrame = pd.DataFrame(self.stable_manifold.H1 @ (yxr.to_numpy()))
        yjr: pd.DataFrame = pd.DataFrame(self.stable_manifold.H1 @ (yxr.to_numpy()) + self.stable_manifold.H2 @ self.exo_projections + self.h3t)
        yjr.columns = self.projection_years_column_labels
        yjr.index = self.sym_data.vector_variable_names(vector_name=&#39;j1l&#39;)
        self._yjr_projections: pd.DataFrame = yjr

        # Project time t expected value of ZE in period t+1 (EXZ)
        # Project time t expected value of ZE in period t+1 (EXZ)
        # tzl = mu1t*x + mu4t*exog[][1:nobs] + c4t
        exz: pd.DataFrame = pd.DataFrame(
            self.stable_manifold.mu1 @ yxr.to_numpy() +
            self.stable_manifold.mu2 @ self.exo_projections +
            self.c4t
        )
        exz.columns = self.projection_years_column_labels
        exz.index = self.sym_data.vector_variable_names(vector_name=&#39;zer&#39;)
        self._exz_projections: pd.DataFrame = exz

        # Project time t values of ZE using the SSF equation (this should be done with M1 and M2?)
        # What about the functions of future exogenous variables and the constant adjustments
        zel: pd.DataFrame = pd.DataFrame(
            self.state_space_form.delta(&#39;zel&#39;, &#39;yxr&#39;) @ self.yxr_projections +
            self.state_space_form.delta(&#39;zel&#39;, &#39;exz&#39;) @ self.exz_projections +
            self.state_space_form.delta(&#39;zel&#39;, &#39;yjr&#39;) @ self.yjr_projections +
            self.state_space_form.delta(&#39;zel&#39;, &#39;exo&#39;) @ self.exo_projections)
        zel.columns = self.projection_years_column_labels
        zel.index = self.sym_data.vector_variable_names(vector_name=&#39;zel&#39;)
        self._zel_projections: pd.DataFrame = zel + self.baseline_projections.ze_constants

        # Project Z1 using the SSF equation
        z1l: pd.DataFrame = pd.DataFrame(
            self.state_space_form.delta(&#39;z1l&#39;, &#39;yxr&#39;) @ self.yxr_projections +
            self.state_space_form.delta(&#39;z1l&#39;, &#39;exz&#39;) @ self.exz_projections +
            self.state_space_form.delta(&#39;z1l&#39;, &#39;yjr&#39;) @ self.yjr_projections +
            self.state_space_form.delta(&#39;z1l&#39;, &#39;exo&#39;) @ self.exo_projections)
        z1l.columns = self.projection_years_column_labels
        z1l.index = self.sym_data.vector_variable_names(vector_name=&#39;z1l&#39;)
        self._z1l_projections: pd.DataFrame = z1l + self.baseline_projections.z1_constants

        # Combine the projections into a single dataframe in the same order as the database
        self._projections = pd.concat([
            self.yxr_projections_as_dataframe,
            self.z1l_projections_as_dataframe,
            self.zel_projections_as_dataframe,
            self.yjr_projections_as_dataframe,
            self.exo_projections_as_dataframe])
        database_ordered_variable_list: pd.DataFrame = self.baseline_projections.database.variables.name
        self._projections = pd.concat([database_ordered_variable_list, self._projections], axis=1)
        self._projections.drop(&#39;name&#39;, inplace=True, axis=1)

        # Concatenate with the projections from the previous layer to get complete projections from the base projection
        # year through to the end projection year
        self._projections = pd.concat([self.previous_projection_layer.projections.loc[:, self.preceding_projection_years_column_labels], self.projections], axis=1)

        self._projections = self._projections.astype(float)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gcubed.projections.base_projections.BaseProjections" href="base_projections.html#gcubed.projections.base_projections.BaseProjections">BaseProjections</a></li>
<li><a title="gcubed.base.Base" href="../base.html#gcubed.base.Base">Base</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="gcubed.projections.simulation_layer.SimulationLayer.baseline_projections"><code class="name">var <span class="ident">baseline_projections</span> : <a title="gcubed.projections.baseline_projections.BaselineProjections" href="baseline_projections.html#gcubed.projections.baseline_projections.BaselineProjections">BaselineProjections</a></code></dt>
<dd>
<div class="desc"><p>Returns the baseline projections underpinning this simulation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def baseline_projections(self) -&gt; BaselineProjections:
    &#34;&#34;&#34;
    Returns the baseline projections underpinning this simulation
    &#34;&#34;&#34;
    if self.previous_simulation_layer is not None:
        return self.previous_simulation_layer.baseline_projections
    return self._baseline_projections</code></pre>
</details>
</dd>
<dt id="gcubed.projections.simulation_layer.SimulationLayer.c4t"><code class="name">var <span class="ident">c4t</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Equivalent to c4t in the Ox implementation
Functions of current and future exogenous variables affecting ZE.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def c4t(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Equivalent to c4t in the Ox implementation
    Functions of current and future exogenous variables affecting ZE.
    &#34;&#34;&#34;
    return self._c4t</code></pre>
</details>
</dd>
<dt id="gcubed.projections.simulation_layer.SimulationLayer.data_file"><code class="name">var <span class="ident">data_file</span> : str</code></dt>
<dd>
<div class="desc"><p>Returns the string specifying the name of the file containing the simulation data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data_file(self) -&gt; str:
    &#34;&#34;&#34;
    Returns the string specifying the name of the file containing the simulation data.
    &#34;&#34;&#34;
    return self.simulation_layer_definition.data_filename</code></pre>
</details>
</dd>
<dt id="gcubed.projections.simulation_layer.SimulationLayer.database"><code class="name">var <span class="ident">database</span> : <a title="gcubed.data.database.Database" href="../data/database.html#gcubed.data.database.Database">Database</a></code></dt>
<dd>
<div class="desc"><p>Returns the database associated with the baseline projections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def database(self) -&gt; Database:
    &#34;&#34;&#34;
    Returns the database associated with the baseline projections.
    &#34;&#34;&#34;
    return self.baseline_projections.database</code></pre>
</details>
</dd>
<dt id="gcubed.projections.simulation_layer.SimulationLayer.description"><code class="name">var <span class="ident">description</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def description(self) -&gt; str:
    return self._simulation_layer_definition.description</code></pre>
</details>
</dd>
<dt id="gcubed.projections.simulation_layer.SimulationLayer.event_year"><code class="name">var <span class="ident">event_year</span> : str</code></dt>
<dd>
<div class="desc"><p>Returns the event year for the simulation layer.
This is the first year that knowledge of the simulation event becomes available
to agents.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def event_year(self) -&gt; str:
    &#34;&#34;&#34;
    Returns the event year for the simulation layer.
    This is the first year that knowledge of the simulation event becomes available
    to agents.
    &#34;&#34;&#34;
    return self.simulation_layer_definition.event_year</code></pre>
</details>
</dd>
<dt id="gcubed.projections.simulation_layer.SimulationLayer.h3t"><code class="name">var <span class="ident">h3t</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Equivalent to h3t in the Ox implementation
Functions of current and future exogenous variables affecting J1.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def h3t(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Equivalent to h3t in the Ox implementation
    Functions of current and future exogenous variables affecting J1.
    &#34;&#34;&#34;
    return self._h3t</code></pre>
</details>
</dd>
<dt id="gcubed.projections.simulation_layer.SimulationLayer.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    return self._simulation_layer_definition.name</code></pre>
</details>
</dd>
<dt id="gcubed.projections.simulation_layer.SimulationLayer.previous_projection_layer"><code class="name">var <span class="ident">previous_projection_layer</span> : <a title="gcubed.projections.base_projections.BaseProjections" href="base_projections.html#gcubed.projections.base_projections.BaseProjections">BaseProjections</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def previous_projection_layer(self) -&gt; BaseProjections:
    if self.previous_simulation_layer is None:
        return self.baseline_projections
    return self.previous_simulation_layer</code></pre>
</details>
</dd>
<dt id="gcubed.projections.simulation_layer.SimulationLayer.previous_simulation_layer"><code class="name">var <span class="ident">previous_simulation_layer</span></code></dt>
<dd>
<div class="desc"><p>Note that the return type is not specified because the SimulationLayer class cannot
refer to itself in its own definition.</p>
<p>Returns the previous simulation layer, or none if there is none.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def previous_simulation_layer(self):
    &#34;&#34;&#34;
    Note that the return type is not specified because the SimulationLayer class cannot
    refer to itself in its own definition.

    Returns the previous simulation layer, or none if there is none.
    &#34;&#34;&#34;
    if hasattr(self,&#39;_previous_simulation_layer&#39;):
        return self._previous_simulation_layer
    return None</code></pre>
</details>
</dd>
<dt id="gcubed.projections.simulation_layer.SimulationLayer.simulation_data"><code class="name">var <span class="ident">simulation_data</span> : pandas.core.frame.DataFrame</code></dt>
<dd>
<div class="desc"><p>Returns the simulation data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def simulation_data(self) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Returns the simulation data.
    &#34;&#34;&#34;
    return self._simulation_data</code></pre>
</details>
</dd>
<dt id="gcubed.projections.simulation_layer.SimulationLayer.simulation_layer_definition"><code class="name">var <span class="ident">simulation_layer_definition</span> : <a title="gcubed.projections.simulation_layer_definition.SimulationLayerDefinition" href="simulation_layer_definition.html#gcubed.projections.simulation_layer_definition.SimulationLayerDefinition">SimulationLayerDefinition</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def simulation_layer_definition(self) -&gt; SimulationLayerDefinition:
    return self._simulation_layer_definition</code></pre>
</details>
</dd>
<dt id="gcubed.projections.simulation_layer.SimulationLayer.simulation_variables"><code class="name">var <span class="ident">simulation_variables</span> : pandas.core.frame.DataFrame</code></dt>
<dd>
<div class="desc"><p>Returns the variable summary information for the simulation data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def simulation_variables(self) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Returns the variable summary information for the simulation data.
    &#34;&#34;&#34;
    return self._simulation_variables</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="gcubed.projections.simulation_layer.SimulationLayer.compute_functions_of_future_exogenous_variables"><code class="name flex">
<span>def <span class="ident">compute_functions_of_future_exogenous_variables</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The rules governing the dynamic behaviour of variables depend on functions of the current and future exogenous variables.
These functions are evaluated and the results are stored in numpy matrices that match the number of rows
for the related vector of variables and that have a column for each year from the base projection year to the
last year in the projections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_functions_of_future_exogenous_variables(self):
    &#34;&#34;&#34;
    The rules governing the dynamic behaviour of variables depend on functions of the current and future exogenous variables.
    These functions are evaluated and the results are stored in numpy matrices that match the number of rows
    for the related vector of variables and that have a column for each year from the base projection year to the
    last year in the projections.
    &#34;&#34;&#34;

    # Set up the arrays that will be populated and initialise them to zeros.

    # This is equivalent to h3t in the newsetsymbl.ox script (j by 1 dimensions)
    self._h3t: np.ndarray = np.zeros(shape=(self.sym_data.vector_length(vector_name=&#39;j1l&#39;), self.projection_years_count))

    # Populate for period T.

    # c4t=invert(unit(nez)-zel_exz_ssf)*cz5   (r by 1 dimensions)
    interim_calculation = self.stable_manifold.Gamma_rT @ self.baseline_projections.ze_constants

    # c6t = invert(unit(j)-j1l_yjr_ssf-j1l_exz_ssf*mu2t) * (cz4+j1l_exz_ssf*c4t)
    # c6t = invert(unit(j)-j1l_yjr_ssf-j1l_exz_ssf*mu2t) * (cz4+j1l_exz_ssf*c4t)
    #     = Gamma_jT (cz4+j1l_exz_ssf*interim_calculation)
    c6T_column = self.stable_manifold.Gamma_jT @ (self.baseline_projections.j1_constants + self.state_space_form.delta(&#39;j1l&#39;, &#39;exz&#39;) @ interim_calculation)

    # c4t = c4t + mu2t * c6t (r by 1 dimensions)
    c4T_column = interim_calculation + self.stable_manifold.psi_rj @ c6T_column

    # c4t=ones(rows(c4t),nobs).*c4t (r by T dimensions)
    self._c4t: np.ndarray = np.tile(c4T_column, (1, self.projection_years_count))

    # c6t=ones(rows(c6t),nobs).*c6t (j by T dimensions)
    c6t: np.ndarray = np.tile(c6T_column, (1, self.projection_years_count))

    # c2t=h2t*exog+c6t    (j by T dimensions)
    c2t: np.ndarray = self.stable_manifold.H2 @ self.exo_projections + c6t

    # (s by T dimensions)
    c5t: np.ndarray = np.zeros(shape=(self.sym_data.vector_length(vector_name=&#39;x1l&#39;), self.projection_years_count))

    # (j by T dimensions)
    c2t_lead: np.ndarray = c2t.copy()
    c4t_lead: np.ndarray = self._c4t.copy()

    # Populate for earlier periods.
    j = self.projection_years_count-1
    for k in range(self.projection_years_count-1, -1, -1):

        # c5t[][k] = wvi*(x1l_exz_ssf*c4tl[][j] + cz2)          (s by 1 : note no need for T columns)
        c5t: np.ndarray = self.stable_manifold.Gamma_st @ (self.state_space_form.delta(&#39;x1l&#39;, &#39;exz&#39;) @
                                                           c4t_lead[:, [j]] + self.baseline_projections.x1_constants)

        # c6t[][k] = fdeltinv*(th6t*c5t[][k] - j1l_exz_ssf*c4tl[][j] + c2tl[][j] - cz4)         (j rows)
        c6t[:, [k]] = self.stable_manifold.Gamma_jt @ (self.stable_manifold.common_factor @ c5t - self.state_space_form.delta(
            &#39;j1l&#39;, &#39;exz&#39;) @ c4t_lead[:, [j]] + c2t_lead[:, [j]] - self.baseline_projections.j1_constants)

        # c5t[][k] = c5t[][k] + th2t*c6t[][k]
        c5t = c5t + self.stable_manifold.tau_sjt @ c6t[:, [k]]

        # c4t[][k] = mu1tl*c5t[][k] + c4tl[][j]
        self._c4t[:, [k]] = self.stable_manifold.M1_lead @ c5t + c4t_lead[:, [j]]

        # h3t[][k] = c6t[][k]
        self._h3t[:, [k]] = c6t[:, [k]].copy()

        # c2t[][k] = h2t*exog[][k] + h3t[][k]
        c2t[:, [k]] = self.stable_manifold.H2 @ self.exo_projections[:, [k]] + self._h3t[:, [k]]

        # c4tl[][k] = nmu4t*exog[][k] + zel_yjr_ssf*h3t[][k] + zel_exz_ssf*c4t[][k] + cz5
        c4t_lead[:, [k]] = self.stable_manifold.M2 @ self.exo_projections[:, [k]] + \
            self.state_space_form.delta(&#39;zel&#39;, &#39;yjr&#39;) @ self._h3t[:, [k]] + \
            self.state_space_form.delta(&#39;zel&#39;, &#39;exz&#39;) @ self._c4t[:, [k]] + \
            self.baseline_projections.ze_constants

        c2t_lead = c2t.copy()

        j = k</code></pre>
</details>
</dd>
<dt id="gcubed.projections.simulation_layer.SimulationLayer.load_simulation_data"><code class="name flex">
<span>def <span class="ident">load_simulation_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>TODO: Check if there are simulations where shocks to state variable initial values are not allowed.</p>
<p>Load and apply the simulation data that affect exogenous variables.
Load and apply the simulation data that affect state variables initial values.</p>
<p>When a variable has data in the simulation file, load that into the appropriate
SYM-specified row of the exogenous variable projections, from the start projection year onwards.</p>
<p>When a variable has data in the simulation file (control.csv by default), load that into the appropriate
SYM-specified row of the state variable projection start year vector and ignore
data in the control file for all years after that projection start year.</p>
<p>Adjust the simulation data as follows, depending on the units of the variable:
gdp - multiply by (projection base year YRATR / 100).
mmgdp - same as gdp
btugdp - same as gdp
gwhgdp - same as gdp
usgdp - divide the value in the control file by 100.
All other units - divide the value in the control file by 100.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_simulation_data(self):
    &#34;&#34;&#34;
    
    TODO: Check if there are simulations where shocks to state variable initial values are not allowed.

    Load and apply the simulation data that affect exogenous variables. 
    Load and apply the simulation data that affect state variables initial values.
    
    When a variable has data in the simulation file, load that into the appropriate 
    SYM-specified row of the exogenous variable projections, from the start projection year onwards.

    When a variable has data in the simulation file (control.csv by default), load that into the appropriate 
    SYM-specified row of the state variable projection start year vector and ignore
    data in the control file for all years after that projection start year.

    Adjust the simulation data as follows, depending on the units of the variable:
        gdp - multiply by (projection base year YRATR / 100).
        mmgdp - same as gdp
        btugdp - same as gdp 
        gwhgdp - same as gdp
        usgdp - divide the value in the control file by 100.
        All other units - divide the value in the control file by 100.
    &#34;&#34;&#34;

    # Load the simulation data.
    filename: str = self.data_file
    assert os.path.isfile(filename)
    (self._simulation_variables, self._simulation_data) = self.load_data(filename)
    self._simulation_variables.columns = [&#39;name&#39;]
    self._simulation_variables.index = self._simulation_variables.name
    self._simulation_data = self._simulation_data.astype(float)
    self._simulation_data.index = self._simulation_variables.name

    try:
        self._simulation_data = self._simulation_data.loc[:, self.projection_years_column_labels]
    except:
        raise Exception(f&#34;The simulation data in {self.data_file} should have data from {self.event_year} to {self.end_year}&#34;)

    # Iterate the shocks, allocating the shocks
    yratr: pd.DataFrame = self.baseline_projections.database.get_data(name_regular_expression=f&#34;^{CONSTANTS.US_REAL_GDP_RATIO_PREFIX}\(&#34;, years=[self.base_year])
    yratr.index = self.sym_data.regions_members

    for variable_name in self._simulation_variables.index:
        variable_region: str = str(self.baseline_projections.database.variables.loc[variable_name, &#39;region&#39;])
        variable_units: str = str(self.sym_data.combined_variable_summary.loc[variable_name, &#39;units&#39;])
        data: pd.DataFrame = self._simulation_data.loc[[variable_name], :] / 100
        vector_name = self.sym_data.projection_vector_for_variable(variable_name=variable_name)
        variable_sequence: int = self.sym_data.variable_index(vector_name=vector_name, variable_name=variable_name)
        yratr_for_region: float = float(yratr.loc[variable_region, :].values[0])
        match variable_units:
            case &#39;gdp&#39;:
                data = data * yratr_for_region
            case &#39;mmgdp&#39;:
                data = data * yratr_for_region
            case &#39;btugdp&#39;:
                data = data * yratr_for_region
            case &#39;gwhgdp&#39;:
                data = data * yratr_for_region
            case _:
                pass

        self._exo_projections = self.previous_projection_layer.exo_projections_as_dataframe.loc[:, self.projection_years_column_labels]

        x1_initial_values: pd.DataFrame = self.previous_projection_layer.yxr_projections_as_dataframe.loc[:, [str(self.event_year)]].copy()

        match vector_name:
            case &#39;exo&#39;:
                self._exo_projections.loc[[variable_name], self.projection_years_column_labels] += data
                pass

            case &#39;x1l&#39;:
                x1_initial_values.loc[[variable_name], [str(self.event_year)]] += float(data[0])
                pass

        self._x1_initial_values: np.ndarray = x1_initial_values.to_numpy()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gcubed.projections.base_projections.BaseProjections" href="base_projections.html#gcubed.projections.base_projections.BaseProjections">BaseProjections</a></b></code>:
<ul class="hlist">
<li><code><a title="gcubed.projections.base_projections.BaseProjections.database_projections" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.database_projections">database_projections</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.exo_projections" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.exo_projections">exo_projections</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.exo_projections_as_dataframe" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.exo_projections_as_dataframe">exo_projections_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.exz_projections" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.exz_projections">exz_projections</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.exz_projections_as_dataframe" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.exz_projections_as_dataframe">exz_projections_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.generate_database_projections" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.generate_database_projections">generate_database_projections</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.generate_publishable_projections" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.generate_publishable_projections">generate_publishable_projections</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.get_deviations_between_projections" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.get_deviations_between_projections">get_deviations_between_projections</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.get_year_labels" href="../base.html#gcubed.base.Base.get_year_labels">get_year_labels</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.graphable_projections" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.graphable_projections">graphable_projections</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.load_data" href="../base.html#gcubed.base.Base.load_data">load_data</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.long_rate_constants" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.long_rate_constants">long_rate_constants</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.longrate_calculation" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.longrate_calculation">longrate_calculation</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.preceding_projection_years" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.preceding_projection_years">preceding_projection_years</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.projection_years" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.projection_years">projection_years</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.projections" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.projections">projections</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.publishable_projections" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.publishable_projections">publishable_projections</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.simulation_data_columns" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.simulation_data_columns">simulation_data_columns</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.yjr_projections" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.yjr_projections">yjr_projections</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.yjr_projections_as_dataframe" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.yjr_projections_as_dataframe">yjr_projections_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.yxr_projections" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.yxr_projections">yxr_projections</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.yxr_projections_as_dataframe" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.yxr_projections_as_dataframe">yxr_projections_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.z1l_projections" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.z1l_projections">z1l_projections</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.z1l_projections_as_dataframe" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.z1l_projections_as_dataframe">z1l_projections_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.zel_projections" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.zel_projections">zel_projections</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.zel_projections_as_dataframe" href="base_projections.html#gcubed.projections.base_projections.BaseProjections.zel_projections_as_dataframe">zel_projections_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.zeros" href="../base.html#gcubed.base.Base.zeros">zeros</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gcubed.projections" href="index.html">gcubed.projections</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gcubed.projections.simulation_layer.SimulationLayer" href="#gcubed.projections.simulation_layer.SimulationLayer">SimulationLayer</a></code></h4>
<ul class="">
<li><code><a title="gcubed.projections.simulation_layer.SimulationLayer.baseline_projections" href="#gcubed.projections.simulation_layer.SimulationLayer.baseline_projections">baseline_projections</a></code></li>
<li><code><a title="gcubed.projections.simulation_layer.SimulationLayer.c4t" href="#gcubed.projections.simulation_layer.SimulationLayer.c4t">c4t</a></code></li>
<li><code><a title="gcubed.projections.simulation_layer.SimulationLayer.compute_functions_of_future_exogenous_variables" href="#gcubed.projections.simulation_layer.SimulationLayer.compute_functions_of_future_exogenous_variables">compute_functions_of_future_exogenous_variables</a></code></li>
<li><code><a title="gcubed.projections.simulation_layer.SimulationLayer.data_file" href="#gcubed.projections.simulation_layer.SimulationLayer.data_file">data_file</a></code></li>
<li><code><a title="gcubed.projections.simulation_layer.SimulationLayer.database" href="#gcubed.projections.simulation_layer.SimulationLayer.database">database</a></code></li>
<li><code><a title="gcubed.projections.simulation_layer.SimulationLayer.description" href="#gcubed.projections.simulation_layer.SimulationLayer.description">description</a></code></li>
<li><code><a title="gcubed.projections.simulation_layer.SimulationLayer.event_year" href="#gcubed.projections.simulation_layer.SimulationLayer.event_year">event_year</a></code></li>
<li><code><a title="gcubed.projections.simulation_layer.SimulationLayer.h3t" href="#gcubed.projections.simulation_layer.SimulationLayer.h3t">h3t</a></code></li>
<li><code><a title="gcubed.projections.simulation_layer.SimulationLayer.load_simulation_data" href="#gcubed.projections.simulation_layer.SimulationLayer.load_simulation_data">load_simulation_data</a></code></li>
<li><code><a title="gcubed.projections.simulation_layer.SimulationLayer.name" href="#gcubed.projections.simulation_layer.SimulationLayer.name">name</a></code></li>
<li><code><a title="gcubed.projections.simulation_layer.SimulationLayer.previous_projection_layer" href="#gcubed.projections.simulation_layer.SimulationLayer.previous_projection_layer">previous_projection_layer</a></code></li>
<li><code><a title="gcubed.projections.simulation_layer.SimulationLayer.previous_simulation_layer" href="#gcubed.projections.simulation_layer.SimulationLayer.previous_simulation_layer">previous_simulation_layer</a></code></li>
<li><code><a title="gcubed.projections.simulation_layer.SimulationLayer.simulation_data" href="#gcubed.projections.simulation_layer.SimulationLayer.simulation_data">simulation_data</a></code></li>
<li><code><a title="gcubed.projections.simulation_layer.SimulationLayer.simulation_layer_definition" href="#gcubed.projections.simulation_layer.SimulationLayer.simulation_layer_definition">simulation_layer_definition</a></code></li>
<li><code><a title="gcubed.projections.simulation_layer.SimulationLayer.simulation_variables" href="#gcubed.projections.simulation_layer.SimulationLayer.simulation_variables">simulation_variables</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
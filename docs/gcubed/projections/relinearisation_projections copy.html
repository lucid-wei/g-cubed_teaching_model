<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gcubed.projections.relinearisation_projections copy API documentation</title>
<meta name="description" content="Contains the RelinearisationProjections class, for doing projections
after relinearising a model, and making adjustments for any simulation layers
…" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gcubed.projections.relinearisation_projections copy</code></h1>
</header>
<section id="section-intro">
<p>Contains the RelinearisationProjections class, for doing projections
after relinearising a model, and making adjustments for any simulation layers
that impact on the relinearisation year.</p>
<p>The adjustments are made to fit constants based on the original projection first year.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># ------------------------------------------------------------------
# Purpose: Compute and provide access to relinearisation projections.
# Author: Geoff Shuetrim
# ------------------------------------------------------------------
&#34;&#34;&#34;
Contains the RelinearisationProjections class, for doing projections
after relinearising a model, and making adjustments for any simulation layers
that impact on the relinearisation year.

The adjustments are made to fit constants based on the original projection first year.
&#34;&#34;&#34;
import logging
import os
import pandas as pd
import numpy as np
from gcubed.constants import Constants
from gcubed.sym_data import SymData
from gcubed.model_parameters.parameters import Parameters
from gcubed.model_configuration import ModelConfiguration
from gcubed.model import Model
from gcubed.linearisation.linear_model import LinearModel
from gcubed.linearisation.stable_manifold import StableManifold
from gcubed.linearisation.state_space_form import StateSpaceForm
from gcubed.data.gdp_scaled_database import GDPScaledDatabase
from gcubed.projections.model_updater import ModelUpdater
from gcubed.projections.projections import Projections
from gcubed.projections.baseline_projections import BaselineProjections
from gcubed.projections.simulation_layer_definitions import SimulationLayerDefinitions
from gcubed.projections.simulation_layer_definition import SimulationLayerDefinition

class RelinearisationProjections(Projections):
    &#34;&#34;&#34;
    Compute the relinearisation model projections over the projection horizon 
    from the base projection year (the last year with available data)
    through to the last projection year.
    &#34;&#34;&#34;

    def __init__(self, 
                 baseline_projections: BaselineProjections, 
                 previous_projections: Projections, 
                 relinearisation_year: int, 
                 simulation_layer_definitions: SimulationLayerDefinitions = [],
                 relinearise_around_the_neutral_real_interest_rate:bool = True) -&gt; None:
        &#34;&#34;&#34;

        ### Constructor

        Creates relinearisation projections for the specified new base year.

        ### Arguments

        baseline_projections: The baseline projections.

        previous_projections: The previous projections.

        relinearisation_year: The year that the relinearisation is being done.

        simulation_layer_definitions: 
        An optional input that provides an ordered list of simulation layer 
        definitions that can be used to augment the initial state vector and 
        the exogenous variable projections that underpin the projections. 
        The simulation layers are ignored if they have an event year that 
        is not equal to the base projection year. This parameter defaults to
        an empty list.

        relinearise_around_neutral_real_interest_rate: `True` if the relinearisation
        is done around the neutral real interest rate and `False` if it is done around
        previous projection values in the relinearisation year. 
        This parameter defaults to `True`.
        &#34;&#34;&#34;

        logging.info(f&#34;Relinearising the model starting from {relinearisation_year}.&#34;)

        # Store the baseline projections
        assert baseline_projections is not None
        self._baseline_projections = baseline_projections

        # Store the simulation layer definitions (if any were provided.)
        self._simulation_layer_definitions = simulation_layer_definitions

        self._relinearise_around_the_neutral_real_interest_rate = relinearise_around_the_neutral_real_interest_rate

        # Update the model from the old projections, changing the model 
        # configuration&#39;s first projection year and augmenting the database 
        # for the model to include values from the old projections for each 
        # of the projection years out to the last projection year.
        my_previous_projections: Projections = previous_projections if previous_projections is not None else baseline_projections
        new_model: Model = ModelUpdater.get_updated_model(projections=my_previous_projections, new_first_projection_year=relinearisation_year)
        assert new_model.configuration.first_projection_year == relinearisation_year
        assert new_model.configuration.linearisation_year == relinearisation_year

        # Copy across the long rate constants from the baseline projections.
        self._long_rate_constants: pd.DataFrame = self.baseline_projections.long_rate_constants

        # Relinearise the updated model around the new projection base year to get the revised stable manifold.
        linear_model: LinearModel = LinearModel(
            model=new_model, 
            use_neutral_real_interest_rate=self.relinearise_around_the_neutral_real_interest_rate)
        state_space_form: StateSpaceForm = StateSpaceForm(linear_model=linear_model)
        stable_manifold: StableManifold = StableManifold(state_space_form=state_space_form)
        super().__init__(stable_manifold=stable_manifold)
        self._is_baseline_projections = False
        self._previous_projections: Projections = my_previous_projections

        self._database = GDPScaledDatabase(database=new_model.database, base_year=self.configuration.base_year)

        self.populate_exogenous_projections_and_initial_state_vector()

        # Relinearisation constants calculation process done in this section
        self.__compute_constant_adjustments()

        self._generate_projections()

        self._generate_database_projections()

        self._generate_publishable_projections()

        self.__validate()

    def __validate(self):
        &#34;&#34;&#34;
        ### Overview

        Perform any necessary validations on the relinearised projections.
        &#34;&#34;&#34;
        logging.info(f&#34;The {self.first_projection_year} relinearised projections have been generated.&#34;)
    
    @property
    def stable_manifold(self) -&gt; StableManifold:
        &#34;&#34;&#34;
        The stable manifold after doing the relinearisation.
        &#34;&#34;&#34;
        return self._stable_manifold

    @property
    def state_space_form(self) -&gt; StateSpaceForm:
        &#34;&#34;&#34;
        The state-space form after doing the relinearisation.
        &#34;&#34;&#34;
        return self.stable_manifold.ssf

    @property
    def model(self) -&gt; Model:
        &#34;&#34;&#34;
        The model to relinearise.
        &#34;&#34;&#34;
        return self.state_space_form.model

    @property
    def sym_data(self) -&gt; SymData:
        &#34;&#34;&#34;
        The SYM generated data about the model.
        &#34;&#34;&#34;
        return self.model.sym_data

    @property
    def parameters(self) -&gt; Parameters:
        &#34;&#34;&#34;
        The calibrated model parameters.
        &#34;&#34;&#34;
        return self.model.parameters

    @property
    def configuration(self) -&gt; ModelConfiguration:
        &#34;&#34;&#34;
        The model configuration.
        &#34;&#34;&#34;
        return self.sym_data.configuration

    @property
    def database(self) -&gt; GDPScaledDatabase:
        &#34;&#34;&#34;
        The database used for the relinearisation and projections.
        &#34;&#34;&#34;
        return self._database

    @property
    def baseline_projections(self) -&gt; BaselineProjections:
        &#34;&#34;&#34;
        The baseline projections that this relinearisation projections builds upon.
        &#34;&#34;&#34;
        return self._baseline_projections

    @property
    def simulation_layer_definitions(self) -&gt; SimulationLayerDefinitions:
        &#34;&#34;&#34;
        The list of simulation layer definitions, in their appropriate order
        from the first to be applied to the last to be applied.
        &#34;&#34;&#34;
        return self._simulation_layer_definitions

    @property
    def relinearise_around_the_neutral_real_interest_rate(self) -&gt; bool:
        &#34;&#34;&#34;
        `True` if  relinearisations are around the neutral real interest rate
        and `False` if they are around previous projection values
        in the relinearisation year.
        &#34;&#34;&#34;
        return self._relinearise_around_the_neutral_real_interest_rate
    
    def populate_exogenous_projections_and_initial_state_vector(self):
        &#34;&#34;&#34;

        ### Overview

        Load exogenous variable projections and initial state vector values
        from the previous projections.

        For any simulation layer definition with its event year equal to the base
        year for this projections, augment the exogenous variables and state
        vector with supplied simulation layer data.
        &#34;&#34;&#34;

        self._exo_projections = self.previous_projections.exo_projections.copy()

        self._yxr_initial_values: pd.DataFrame = self.previous_projections.yxr_projections_as_dataframe.loc[:, [str(self.first_projection_year)]].copy()

        for simulation_layer_definition in self.simulation_layer_definitions:
            self.__apply_simulation_layer(simulation_layer_definition=simulation_layer_definition)

    def __apply_simulation_layer(self, simulation_layer_definition: SimulationLayerDefinition):
        &#34;&#34;&#34;
        ### Overview

        Applies adjustments to exogenous variables and any state 
        variables for the given simulation layer.
        &#34;&#34;&#34;
        if simulation_layer_definition.event_year != self.first_projection_year:
            return

        filename: str = simulation_layer_definition.data_filename
        assert os.path.isfile(filename)
        (simulation_variables, simulation_data) = self.load_data(filename)
        simulation_data = simulation_data.astype(float)
        simulation_variables.columns = [&#39;name&#39;]
        simulation_variables.index = simulation_variables.name
        simulation_data.index = simulation_variables.name
        try:
            simulation_data = simulation_data.loc[:, self.configuration.projection_years_column_labels]
        except:
            raise Exception(f&#34;The simulation data in {self.simulation_file} should have data from {self.first_projection_year} to {self.last_projection_year}&#34;)
        yratr: pd.DataFrame = self.baseline_projections.database.get_data(name_regular_expression=f&#34;^{Constants().US_REAL_GDP_RATIO_PREFIX}\(&#34;, years=[self.configuration.original_first_projection_year])
        yratr.index = self.sym_data.regions_members

        for variable_name in self._simulation_variables.index:
            variable_region: str = str(self.database.variables.loc[variable_name, &#39;region&#39;])
            units_for_variables_with_given_name_prefix: str = str(self.sym_data.combined_variable_summary.loc[variable_name, &#39;units&#39;])
            data: pd.DataFrame = simulation_data.loc[[variable_name], :] / 100
            vector_name = self.sym_data.projection_vector_for_variable(variable_name=variable_name)
            yratr_for_region: float = float(yratr.loc[variable_region, :].values[0])
            match units_for_variables_with_given_name_prefix:
                case &#39;gdp&#39; | &#39;mmgdp&#39; | &#39;btugdp&#39; | &#39;gwhgdp&#39;:
                    data *= yratr_for_region
                case _:
                    pass

            match vector_name:
                case &#39;exo&#39;:
                    self._exo_projections.loc[[variable_name], self.projection_years_column_labels] += data
                    pass

                case &#39;x1l&#39;:
                    self._yxr_initial_values.loc[[variable_name], [str(self.first_projection_year)]] += float(data[0])
                    pass

    @property
    def x1_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to X1 to ensure projections equal observed values
        in the original base projection year.
        &#34;&#34;&#34;
        return self.baseline_projections.x1_constants

    @property
    def j1_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to J1 to ensure projections equal observed values
        in the original base projection year.
        &#34;&#34;&#34;
        return self.baseline_projections.j1_constants

    @property
    def ze_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to ZE to ensure projections equal observed values
        in the original base projection year.
        &#34;&#34;&#34;
        return self.baseline_projections.ze_constants

    @property
    def z1_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to Z1 to ensure projections equal observed values
        in the original base projection year.
        &#34;&#34;&#34;
        return self.baseline_projections.z1_constants
    
    #####################################################################################
    # Constant calculation functionality after here
    #####################################################################################

    def __compute_constant_adjustments(self):
        &#34;&#34;&#34;
        ### Overview

        We already have the original first projection year database values
        for all vectors and for the variables that are adjusted by intertemporal 
        variables. They are all accessible from the baseline projections.

        Step 1.
        Compute SSF raw projections in the original first projection year minus
        the values for those projected variable vectors in the database for
        that original first projection year. These will differ from those produced
        in the baseline because the relinearisation will have changed the 
        state space form of the model.

        Step 2.
        Compute the intertemporal constants.

        &#34;&#34;&#34;

        # Step 1.
        self.__compute_original_first_projection_year_ssf_deviations_from_observed_values()

        # Step 2.
        self.__calculate_intertemporal_constants()

    def __compute_original_first_projection_year_ssf_deviations_from_observed_values(self):
        &#34;&#34;&#34;
        ### Overview

        Step 1.
        Calculate the  values for the LHS vectors  in  the
        original first projection year using the relinearised
        state space form of the model. This uses the RHS vectors
        for the first projection year associated with the 
        baseline projections (NOT THESE RELINEARISED PROJECTIONS.)

        and 

        Step 2.
        Calculate the differences between the database values for the RHS vectors
        `x1r`, `j1r`, `zer`, and `z1r` and the values computed in Step 1. Store these
        as properties of the class instance. They become constant adjustments that are
        used in the projection process to ensure that the database values in 
        the first projection year match the baseline projections of those values.

        The differences are preserved as the database values minus projections.
        &#34;&#34;&#34;

        # Step 1.
        x1l_ssf_calculations_using_first_projection_year_data = self.state_space_form.delta(&#39;x1l&#39;, &#39;yxr&#39;) @ self.baseline_projections.first_projection_year_yxr + \
            self.state_space_form.delta(&#39;x1l&#39;, &#39;yjr&#39;) @ self.baseline_projections.first_projection_year_yjr + \
            self.state_space_form.delta(&#39;x1l&#39;, &#39;exz&#39;) @ self.baseline_projections.first_projection_year_exz + \
            self.state_space_form.delta(&#39;x1l&#39;, &#39;exo&#39;) @ self.baseline_projections.first_projection_year_exo

        j1l_ssf_calculations_using_first_projection_year_data = self.state_space_form.delta(&#39;j1l&#39;, &#39;yxr&#39;) @ self.baseline_projections.first_projection_year_yxr + \
            self.state_space_form.delta(&#39;j1l&#39;, &#39;yjr&#39;) @ self.baseline_projections.first_projection_year_yjr + \
            self.state_space_form.delta(&#39;j1l&#39;, &#39;exz&#39;) @ self.baseline_projections.first_projection_year_exz + \
            self.state_space_form.delta(&#39;j1l&#39;, &#39;exo&#39;) @ self.baseline_projections.first_projection_year_exo

        zel_ssf_calculations_using_first_projection_year_data = self.state_space_form.delta(&#39;zel&#39;, &#39;yxr&#39;) @ self.baseline_projections.first_projection_year_yxr + \
            self.state_space_form.delta(&#39;zel&#39;, &#39;yjr&#39;) @ self.baseline_projections.first_projection_year_yjr + \
            self.state_space_form.delta(&#39;zel&#39;, &#39;exz&#39;) @ self.baseline_projections.first_projection_year_exz + \
            self.state_space_form.delta(&#39;zel&#39;, &#39;exo&#39;) @ self.baseline_projections.first_projection_year_exo

        z1l_ssf_calculations_using_first_projection_year_data = self.state_space_form.delta(&#39;z1l&#39;, &#39;yxr&#39;) @ self.baseline_projections.first_projection_year_yxr + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;yjr&#39;) @ self.baseline_projections.first_projection_year_yjr + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;exz&#39;) @ self.baseline_projections.first_projection_year_exz + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;exo&#39;) @ self.baseline_projections.first_projection_year_exo

        # Step 2.
        self._x1r_difference_from_ssf = self.baseline_projections.first_projection_year_x1r - x1l_ssf_calculations_using_first_projection_year_data  # t+1 = year after base year
        self._j1r_difference_from_ssf = self.baseline_projections.first_projection_year_j1r - j1l_ssf_calculations_using_first_projection_year_data  # t+1 = year after base year
        self._zer_difference_from_ssf = self.baseline_projections.first_projection_year_zer - zel_ssf_calculations_using_first_projection_year_data  # t = base year
        self._z1r_difference_from_ssf = self.baseline_projections.first_projection_year_z1r - z1l_ssf_calculations_using_first_projection_year_data  # t = base year

    @property
    def x1r_difference_from_ssf(self):
        &#34;&#34;&#34;
        The original first projection year 
        difference between the database values of `x1r`
        and the raw baseline projections of those values,
        without making any constant adjustments at all.

        These differences are added to the constants that
        are used in the baseline projections to ensure that
        the projections in the first projection year match
        the database values in that year.
        &#34;&#34;&#34;
        return self._x1r_difference_from_ssf

    @property
    def j1r_difference_from_ssf(self):
        &#34;&#34;&#34;
        The original first projection year 
        difference between the database values of `j1r`
        and the raw baseline projections of those values,
        without making any constant adjustments at all.

        These differences are added to the constants that
        are used in the baseline projections to ensure that
        the projections in the first projection year match
        the database values in that year.

        &#34;&#34;&#34;
        return self._j1r_difference_from_ssf

    @property
    def zer_difference_from_ssf(self):
        &#34;&#34;&#34;
        The original first projection year 
        difference between the database values of `zer`
        and the raw baseline projections of those values,
        without making any constant adjustments at all.

        These differences are added to the constants that
        are used in the baseline projections to ensure that
        the projections in the first projection year match
        the database values in that year.
        &#34;&#34;&#34;
        return self._zer_difference_from_ssf

    @property
    def z1r_difference_from_ssf(self):
        &#34;&#34;&#34;
        The original first projection year 
        difference between the database values of `z1r`
        and the raw projections of those values,
        without making any constant adjustments at all.

        These differences are added to the constants that
        are used in the baseline projections to ensure that
        the projections in the first projection year match
        the database values in that year.
        &#34;&#34;&#34;
        return self._z1r_difference_from_ssf
    

    def __evaluate_first_projection_year_vector_projections(self):
        &#34;&#34;&#34;
        Computes the values of the model equation vectors in the original 
        first projection year, using the functions of future exogenous variables, 
        the stable manifold, etc based on the relinearised model.
        &#34;&#34;&#34;

        self._exo_first_year_projections: np.ndarray = self.exo_projections.loc[:, [str(self.first_projection_year)]].to_numpy()

        self._yxr_first_year_projections: np.ndarray = self.yxr_initial_values.to_numpy().copy()

        # er = h1t*x[][1] + h2t*exog[][1] + h3t[][1];
        self._yjr_first_year_projections: np.ndarray = \
            self.stable_manifold.H1 @ self.yxr_first_year_projections + \
            self.stable_manifold.H2 @ self.exo_first_year_projections + \
            self._h3t[:, [0]]

        # tzl = mu1t*x[][1] + mu4t*exog[][1] + c4t[][1];
        self._exz_first_year_projections: np.ndarray = \
            self.stable_manifold.mu1 @ self.yxr_first_year_projections + \
            self.stable_manifold.mu2 @ self.exo_first_year_projections + \
            self._c4t[:, [0]]

        # z1l projections = d5n*x[][1]+d7n*exog[][1]+d6n*er+d4n*tzl+cz6[][1]
        self._z1l_first_year_projections: np.ndarray = \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;yxr&#39;) @ self.yxr_first_year_projections + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;exo&#39;) @ self.exo_first_year_projections + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;yjr&#39;) @ self.yjr_first_year_projections + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;exz&#39;) @ self.exz_first_year_projections + \
            self.z1r_difference_from_ssf

    @property
    def yxr_first_year_projections(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Projections of X1_t (yxr) in the first projection year
        &#34;&#34;&#34;
        return self._yxr_first_year_projections

    @property
    def yjr_first_year_projections(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Projections of J1_t (yjr) in the first projection year
        &#34;&#34;&#34;
        return self._yjr_first_year_projections

    @property
    def exz_first_year_projections(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Projections of ZE_t (exz) in the first projection year
        &#34;&#34;&#34;
        return self._exz_first_year_projections

    @property
    def z1l_first_year_projections(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Projections of Z1_t (z1l=z1r) in the first projection year
        &#34;&#34;&#34;
        return self._z1l_first_year_projections

    @property
    def exo_first_year_projections(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Projections of EXO_t in the first projection year
        &#34;&#34;&#34;
        return self._exo_first_year_projections

    @property
    def first_year_original_projections_of_variables_adjusted_by_intertemporal_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The first year projected values for the variables that are being
        adjusted by the intertemporal constants.

        The values are those for the projection that is not adjusted by intertemporal constants.

        It is used in the calculation of the intertemporal constants but it is only preserved
        as a property to facilitate benchmarking against Ox.
        &#34;&#34;&#34;
        return self._first_year_original_projections_of_variables_adjusted_by_intertemporal_constants


    def __update_perturbed_variable(self, variable_details: pd.Series):
        &#34;&#34;&#34;
        ### Overview

        For each variable that has an intertemporal constant, we need to compute
        numerical approximations to the partial derivatives of the model with respect
        to that constant. Those  partial derivatives are approximated by evaluating the 
        relevant equations in the model using the data in the first projection year and then 
        again evaluating those equations after perturbing the variable of interest by
        `gcubed.Constants.DELTA`. The difference between the two evaluations is used
        to compute the partial derivatives for that constant.

        This function does the work of perturbing the intertemporal constant 
        associated with the variable, preparing for calculation of the partial 
        derivatives for that constant.

        The adjustment to the constant (the perturbation) is made by adjusting the
        constants associated with variables&#39; observed differences from their state 
        space form equation evaluations in the baseline&#39;s first projection year.

        The original value of that constant is tracked using the private property, 
        `_original_value`, so that it can be restored after the partial derivatives
        have been computed.

        This function is called once for each variable in the SYM table of intertemporal 
        constant variables, as part of computing the intertemporal constants.

        &#34;&#34;&#34;

        if hasattr(self, &#39;_perturbed_variable_details&#39;):
            sequence = self._perturbed_variable_details[&#39;sequence&#39;]
            match self._perturbed_variable_details[&#39;var_type&#39;]:
                case &#39;x1l&#39;:
                    self.x1r_difference_from_ssf[sequence] = self._original_value
                case &#39;j1l&#39;:
                    self.j1r_difference_from_ssf[sequence] = self._original_value
                case &#39;zel&#39;:
                    self.zer_difference_from_ssf[sequence] = self._original_value
                case &#39;z1l&#39;:
                    self.z1r_difference_from_ssf[sequence] = self._original_value
            delattr(self, &#39;_original_value&#39;)

        if variable_details is None:
            delattr(self, &#39;_perturbed_variable_details&#39;)
        else:
            sequence = variable_details[&#39;sequence&#39;]
            match variable_details[&#39;var_type&#39;]:
                case &#39;x1l&#39;:
                    self._original_value = float(self.x1r_difference_from_ssf[sequence])
                    self.x1r_difference_from_ssf[sequence] = self._original_value + Constants().DELTA
                case &#39;j1l&#39;:
                    self._original_value = float(self.j1r_difference_from_ssf[sequence])
                    self.j1r_difference_from_ssf[sequence] = self._original_value + Constants().DELTA
                case &#39;zel&#39;:
                    self._original_value = float(self.zer_difference_from_ssf[sequence])
                    self.zer_difference_from_ssf[sequence] = self._original_value + Constants().DELTA
                case &#39;z1l&#39;:
                    self._original_value = float(self.z1r_difference_from_ssf[sequence])
                    self.z1r_difference_from_ssf[sequence] = self._original_value + Constants().DELTA
            self._perturbed_variable_details = variable_details

    @property
    def perturbed_variable_details(self) -&gt; pd.Series:
        &#34;&#34;&#34;
        If computing intertemporal constants, 
        the var_map details (the row of the SYM var_map dataframe)
        for the variable being perturbed as part of computing
        derivatives needed to set intertemporal constants. Otherwise, this returns
        `None` if just producing the baseline projections.
        &#34;&#34;&#34;
        if hasattr(self, &#39;_perturbed_variable_details&#39;):
            return self._perturbed_variable_details
        return None


    @property
    def first_year_projections_of_variables_adjusted_by_intertemporal_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        An column vector of first year projection values for those variables that are adjusted
        by intertemporal constants.

        The vector is populated from the vectors of first year projections for 
        each of `x1l`, `j1l`, `zel`,  and `z1l`.
        &#34;&#34;&#34;
        result = np.zeros(shape=(len(self.sym_data.variables_adjusted_by_intertemporal_constants), 1))
        i = 0
        for index, adjusted_variable_details in self.sym_data.variables_adjusted_by_intertemporal_constants.iterrows():
            sequence = adjusted_variable_details[&#39;sequence&#39;]
            match adjusted_variable_details[&#39;var_type&#39;]:
                case &#39;x1l&#39;:
                    result[i, 0] = self.yxr_first_year_projections[[sequence]]
                case &#39;j1l&#39;:
                    result[i, 0] = self.yjr_first_year_projections[[sequence]]
                case &#39;zel&#39;:
                    result[i, 0] = self.exz_first_year_projections[[sequence]]
                case &#39;z1l&#39;:
                    result[i, 0] = self.z1l_first_year_projections[[sequence]]
            i += 1
        return result

    @property
    def partial_derivatives_wrt_intertemporal_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The matrix of partial derivatives used in Newton&#39;s method to
        compute the intertemporal constants.

        This is a property of the class just to support benchmarking against Ox.
        &#34;&#34;&#34;
        return self._partial_derivatives
    

    @property
    def intertemporal_constants(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        The data frame of intertemporal constants information
        obtained from SYM but augmented with the values of the
        intertemporal constants.

        The dataframe is indexed by the variable names.

        The constant values are stored in a column called `constant_value`.
        &#34;&#34;&#34;
        return self._intertemporal_constants


    def __calculate_intertemporal_constants(self):
        &#34;&#34;&#34;
        ### Overview

        Computes the intertemporal constant adjustments to 
        jump and other variables to align starting data
        values with model projections in the first year.

        Step 1.
        Compute functions of future exogenous variables through all years from the
        original first projection year (for the baseline projections) through to 
        the last projection year. These are needed to compute the functions of future
        exogenous variables that feed into the intertemporal constant calculations.

        Step 2.
        For the variables that are to be adjusted by the intertemporal
        constants, compute their projected values in the base projection year
        and store these values for comparison to perturbed base year projections so we can calculate
        the derivatives matrix needed to set the intertemporal constants.
        Also store the values of each of the 4 vectors in the model in the base year for benchmarking.

        Step 3.
        Initialise the partial derivatives matrix. This is the matrix of derivatives of each of the
        variables that is adjusted by intertemporal constants, with respect to each of the intertemporal
        constants, in the SSF equations (each of which is linear).

        Iterate over the intertemporal constants, perturbing each and recalculating the base year projections
        of the variables that are adjusted by intertemporal constants so that we can 
        estimate the relevant numeric derivatives.

        At the end of this step, update the perturbed variable details to `None` so that
        all constants associated with the difference between observed values and SSF calculated values
        are at their unpurturbed values when doing actual baseline projections.

        Step 4.
        Apply Newton&#39;s method to solve for the intertemporal constants.
        Multiply the difference between the observed values of the variables that are adjusted by
        the intertemporal constants and their original projected values, in the first projection year,
        by the inverse of the partial derivatives matrix.

        This only needs to be done once because the SSF of the model is linear so Newton&#39;s method
        gets to the solution in one iteration.
        &#34;&#34;&#34;

        # Step 1.
        self._compute_functions_of_future_exogenous_variables(exogenous_projections=self.exo_projections)

        # Step 2.
        # Compute the first year projections - noting that no intertemporal 
        # constant adjustments have been made yet.
        self.__evaluate_first_projection_year_vector_projections()

        # Capture the first year projections of the intertemporal variables. 
        # These are used in this function for Newton&#39;s method below
        # and they are also deep-copied and stored as a property of the 
        # class for benchmarking purposes.
        self._first_year_original_projections_of_variables_adjusted_by_intertemporal_constants = self.first_year_projections_of_variables_adjusted_by_intertemporal_constants.copy()

        # Step 3.
        # Compute the partial derivatives matrix
        self._partial_derivatives = np.zeros(shape=(len(self.sym_data.intertemporal_constant_variables), len(
            self.sym_data.variables_adjusted_by_intertemporal_constants)))
        i = 0
        for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
            self.__update_perturbed_variable(variable_details=variable_details)
            self._compute_functions_of_future_exogenous_variables(exogenous_projections=self.exo_projections)
            self.__evaluate_first_projection_year_vector_projections()
            self._partial_derivatives[:, [i]] = (
                self.first_year_projections_of_variables_adjusted_by_intertemporal_constants -
                self._first_year_original_projections_of_variables_adjusted_by_intertemporal_constants) / Constants().DELTA
            i += 1

        # Generate the baseline projection to use in computing partial derivatives
        # and to generate matrix values that are used later in projection processes.
        self.__update_perturbed_variable(variable_details=None)

        # Step 4.
        # Use Newtons method adjustment to compute intertemporal constant values
        self._intertemporal_constants = self.sym_data.intertemporal_constant_variables
        values: np.ndarray = np.linalg.inv(self._partial_derivatives) @ \
            (self.baseline_projections.first_year_observed_values_of_variables_adjusted_by_intertemporal_constants -
             self.first_year_original_projections_of_variables_adjusted_by_intertemporal_constants)
        values = values.reshape((len(self.intertemporal_constants.index), 1))
        self._intertemporal_constants[&#39;constant_value&#39;] = values

        logging.info(&#34;The intertemporal constants have been calibrated for the relinearised model.&#34;)



    @property
    def x1_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to X1 to ensure projections equal observed values.
        Add any intertemporal constant values to the X1R difference to SSF equation 
        results with zero constants to get the combined set of constants.
        &#34;&#34;&#34;

        if hasattr(self, &#34;_x1_constants&#34;):
            return self._x1_constants

        result: np.ndarray = self.x1r_difference_from_ssf.copy()
        if not hasattr(self, &#34;intertemporal_constants&#34;):
            return result

        i = 0
        for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
            if variable_details[&#39;var_type&#39;] == &#39;x1l&#39;:
                result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
            i = i + 1

        self._x1_constants: np.ndarray = result
        return self._x1_constants

    @property
    def j1_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to J1 to ensure projections equal observed values.
        Add any intertemporal constant values to the X1R difference to SSF equation 
        results with zero constants to get the combined set of constants.
        &#34;&#34;&#34;

        if hasattr(self, &#34;_j1_constants&#34;):
            return self._j1_constants

        result: np.ndarray = self.j1r_difference_from_ssf.copy()
        if not hasattr(self, &#34;intertemporal_constants&#34;):
            return result
        i = 0
        for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
            if variable_details[&#39;var_type&#39;] == &#39;j1l&#39;:
                result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
            i = i + 1

        self._j1_constants: np.ndarray = result
        return self._j1_constants

    @property
    def ze_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to ZE to ensure projections equal observed values.
        Add any intertemporal constant values to the X1R difference to SSF equation 
        results with zero constants to get the combined set of constants.
        &#34;&#34;&#34;

        if hasattr(self, &#34;_ze_constants&#34;):
            return self._ze_constants

        result: np.ndarray = self.zer_difference_from_ssf.copy()
        if not hasattr(self, &#34;intertemporal_constants&#34;):
            return result

        i = 0
        for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
            if variable_details[&#39;var_type&#39;] == &#39;zel&#39;:
                logging.debug(
                    f&#34;At index {i} intertemporal constant is {self.intertemporal_constants.loc[variable_details[&#39;name&#39;],&#39;constant_value&#39;]} : shape is {self.intertemporal_constants.shape}&#34;)
                result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
            i = i + 1

        self._ze_constants: np.ndarray = result
        return self._ze_constants

    @property
    def z1_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to Z1 to ensure projections equal observed values.
        Add any intertemporal constant values to the X1R difference to SSF equation 
        results with zero constants to get the combined set of constants.
        &#34;&#34;&#34;

        if hasattr(self, &#34;_z1_constants&#34;):
            return self._z1_constants

        result: np.ndarray = self.z1r_difference_from_ssf.copy()
        if not hasattr(self, &#34;intertemporal_constants&#34;):
            return result
        i = 0
        for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
            if variable_details[&#39;var_type&#39;] == &#39;z1l&#39;:
                result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
            i = i + 1

        self._z1_constants: np.ndarray = result
        return self._z1_constants</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gcubed.projections.relinearisation_projections copy.RelinearisationProjections"><code class="flex name class">
<span>class <span class="ident">RelinearisationProjections</span></span>
<span>(</span><span>baseline_projections: <a title="gcubed.projections.baseline_projections.BaselineProjections" href="baseline_projections.html#gcubed.projections.baseline_projections.BaselineProjections">BaselineProjections</a>, previous_projections: <a title="gcubed.projections.projections.Projections" href="projections.html#gcubed.projections.projections.Projections">Projections</a>, relinearisation_year: int, simulation_layer_definitions: <a title="gcubed.projections.simulation_layer_definitions.SimulationLayerDefinitions" href="simulation_layer_definitions.html#gcubed.projections.simulation_layer_definitions.SimulationLayerDefinitions">SimulationLayerDefinitions</a> = [], relinearise_around_the_neutral_real_interest_rate: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the relinearisation model projections over the projection horizon
from the base projection year (the last year with available data)
through to the last projection year.</p>
<h3 id="constructor">Constructor</h3>
<p>Creates relinearisation projections for the specified new base year.</p>
<h3 id="arguments">Arguments</h3>
<p>baseline_projections: The baseline projections.</p>
<p>previous_projections: The previous projections.</p>
<p>relinearisation_year: The year that the relinearisation is being done.</p>
<p>simulation_layer_definitions:
An optional input that provides an ordered list of simulation layer
definitions that can be used to augment the initial state vector and
the exogenous variable projections that underpin the projections.
The simulation layers are ignored if they have an event year that
is not equal to the base projection year. This parameter defaults to
an empty list.</p>
<p>relinearise_around_neutral_real_interest_rate: <code>True</code> if the relinearisation
is done around the neutral real interest rate and <code>False</code> if it is done around
previous projection values in the relinearisation year.
This parameter defaults to <code>True</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RelinearisationProjections(Projections):
    &#34;&#34;&#34;
    Compute the relinearisation model projections over the projection horizon 
    from the base projection year (the last year with available data)
    through to the last projection year.
    &#34;&#34;&#34;

    def __init__(self, 
                 baseline_projections: BaselineProjections, 
                 previous_projections: Projections, 
                 relinearisation_year: int, 
                 simulation_layer_definitions: SimulationLayerDefinitions = [],
                 relinearise_around_the_neutral_real_interest_rate:bool = True) -&gt; None:
        &#34;&#34;&#34;

        ### Constructor

        Creates relinearisation projections for the specified new base year.

        ### Arguments

        baseline_projections: The baseline projections.

        previous_projections: The previous projections.

        relinearisation_year: The year that the relinearisation is being done.

        simulation_layer_definitions: 
        An optional input that provides an ordered list of simulation layer 
        definitions that can be used to augment the initial state vector and 
        the exogenous variable projections that underpin the projections. 
        The simulation layers are ignored if they have an event year that 
        is not equal to the base projection year. This parameter defaults to
        an empty list.

        relinearise_around_neutral_real_interest_rate: `True` if the relinearisation
        is done around the neutral real interest rate and `False` if it is done around
        previous projection values in the relinearisation year. 
        This parameter defaults to `True`.
        &#34;&#34;&#34;

        logging.info(f&#34;Relinearising the model starting from {relinearisation_year}.&#34;)

        # Store the baseline projections
        assert baseline_projections is not None
        self._baseline_projections = baseline_projections

        # Store the simulation layer definitions (if any were provided.)
        self._simulation_layer_definitions = simulation_layer_definitions

        self._relinearise_around_the_neutral_real_interest_rate = relinearise_around_the_neutral_real_interest_rate

        # Update the model from the old projections, changing the model 
        # configuration&#39;s first projection year and augmenting the database 
        # for the model to include values from the old projections for each 
        # of the projection years out to the last projection year.
        my_previous_projections: Projections = previous_projections if previous_projections is not None else baseline_projections
        new_model: Model = ModelUpdater.get_updated_model(projections=my_previous_projections, new_first_projection_year=relinearisation_year)
        assert new_model.configuration.first_projection_year == relinearisation_year
        assert new_model.configuration.linearisation_year == relinearisation_year

        # Copy across the long rate constants from the baseline projections.
        self._long_rate_constants: pd.DataFrame = self.baseline_projections.long_rate_constants

        # Relinearise the updated model around the new projection base year to get the revised stable manifold.
        linear_model: LinearModel = LinearModel(
            model=new_model, 
            use_neutral_real_interest_rate=self.relinearise_around_the_neutral_real_interest_rate)
        state_space_form: StateSpaceForm = StateSpaceForm(linear_model=linear_model)
        stable_manifold: StableManifold = StableManifold(state_space_form=state_space_form)
        super().__init__(stable_manifold=stable_manifold)
        self._is_baseline_projections = False
        self._previous_projections: Projections = my_previous_projections

        self._database = GDPScaledDatabase(database=new_model.database, base_year=self.configuration.base_year)

        self.populate_exogenous_projections_and_initial_state_vector()

        # Relinearisation constants calculation process done in this section
        self.__compute_constant_adjustments()

        self._generate_projections()

        self._generate_database_projections()

        self._generate_publishable_projections()

        self.__validate()

    def __validate(self):
        &#34;&#34;&#34;
        ### Overview

        Perform any necessary validations on the relinearised projections.
        &#34;&#34;&#34;
        logging.info(f&#34;The {self.first_projection_year} relinearised projections have been generated.&#34;)
    
    @property
    def stable_manifold(self) -&gt; StableManifold:
        &#34;&#34;&#34;
        The stable manifold after doing the relinearisation.
        &#34;&#34;&#34;
        return self._stable_manifold

    @property
    def state_space_form(self) -&gt; StateSpaceForm:
        &#34;&#34;&#34;
        The state-space form after doing the relinearisation.
        &#34;&#34;&#34;
        return self.stable_manifold.ssf

    @property
    def model(self) -&gt; Model:
        &#34;&#34;&#34;
        The model to relinearise.
        &#34;&#34;&#34;
        return self.state_space_form.model

    @property
    def sym_data(self) -&gt; SymData:
        &#34;&#34;&#34;
        The SYM generated data about the model.
        &#34;&#34;&#34;
        return self.model.sym_data

    @property
    def parameters(self) -&gt; Parameters:
        &#34;&#34;&#34;
        The calibrated model parameters.
        &#34;&#34;&#34;
        return self.model.parameters

    @property
    def configuration(self) -&gt; ModelConfiguration:
        &#34;&#34;&#34;
        The model configuration.
        &#34;&#34;&#34;
        return self.sym_data.configuration

    @property
    def database(self) -&gt; GDPScaledDatabase:
        &#34;&#34;&#34;
        The database used for the relinearisation and projections.
        &#34;&#34;&#34;
        return self._database

    @property
    def baseline_projections(self) -&gt; BaselineProjections:
        &#34;&#34;&#34;
        The baseline projections that this relinearisation projections builds upon.
        &#34;&#34;&#34;
        return self._baseline_projections

    @property
    def simulation_layer_definitions(self) -&gt; SimulationLayerDefinitions:
        &#34;&#34;&#34;
        The list of simulation layer definitions, in their appropriate order
        from the first to be applied to the last to be applied.
        &#34;&#34;&#34;
        return self._simulation_layer_definitions

    @property
    def relinearise_around_the_neutral_real_interest_rate(self) -&gt; bool:
        &#34;&#34;&#34;
        `True` if  relinearisations are around the neutral real interest rate
        and `False` if they are around previous projection values
        in the relinearisation year.
        &#34;&#34;&#34;
        return self._relinearise_around_the_neutral_real_interest_rate
    
    def populate_exogenous_projections_and_initial_state_vector(self):
        &#34;&#34;&#34;

        ### Overview

        Load exogenous variable projections and initial state vector values
        from the previous projections.

        For any simulation layer definition with its event year equal to the base
        year for this projections, augment the exogenous variables and state
        vector with supplied simulation layer data.
        &#34;&#34;&#34;

        self._exo_projections = self.previous_projections.exo_projections.copy()

        self._yxr_initial_values: pd.DataFrame = self.previous_projections.yxr_projections_as_dataframe.loc[:, [str(self.first_projection_year)]].copy()

        for simulation_layer_definition in self.simulation_layer_definitions:
            self.__apply_simulation_layer(simulation_layer_definition=simulation_layer_definition)

    def __apply_simulation_layer(self, simulation_layer_definition: SimulationLayerDefinition):
        &#34;&#34;&#34;
        ### Overview

        Applies adjustments to exogenous variables and any state 
        variables for the given simulation layer.
        &#34;&#34;&#34;
        if simulation_layer_definition.event_year != self.first_projection_year:
            return

        filename: str = simulation_layer_definition.data_filename
        assert os.path.isfile(filename)
        (simulation_variables, simulation_data) = self.load_data(filename)
        simulation_data = simulation_data.astype(float)
        simulation_variables.columns = [&#39;name&#39;]
        simulation_variables.index = simulation_variables.name
        simulation_data.index = simulation_variables.name
        try:
            simulation_data = simulation_data.loc[:, self.configuration.projection_years_column_labels]
        except:
            raise Exception(f&#34;The simulation data in {self.simulation_file} should have data from {self.first_projection_year} to {self.last_projection_year}&#34;)
        yratr: pd.DataFrame = self.baseline_projections.database.get_data(name_regular_expression=f&#34;^{Constants().US_REAL_GDP_RATIO_PREFIX}\(&#34;, years=[self.configuration.original_first_projection_year])
        yratr.index = self.sym_data.regions_members

        for variable_name in self._simulation_variables.index:
            variable_region: str = str(self.database.variables.loc[variable_name, &#39;region&#39;])
            units_for_variables_with_given_name_prefix: str = str(self.sym_data.combined_variable_summary.loc[variable_name, &#39;units&#39;])
            data: pd.DataFrame = simulation_data.loc[[variable_name], :] / 100
            vector_name = self.sym_data.projection_vector_for_variable(variable_name=variable_name)
            yratr_for_region: float = float(yratr.loc[variable_region, :].values[0])
            match units_for_variables_with_given_name_prefix:
                case &#39;gdp&#39; | &#39;mmgdp&#39; | &#39;btugdp&#39; | &#39;gwhgdp&#39;:
                    data *= yratr_for_region
                case _:
                    pass

            match vector_name:
                case &#39;exo&#39;:
                    self._exo_projections.loc[[variable_name], self.projection_years_column_labels] += data
                    pass

                case &#39;x1l&#39;:
                    self._yxr_initial_values.loc[[variable_name], [str(self.first_projection_year)]] += float(data[0])
                    pass

    @property
    def x1_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to X1 to ensure projections equal observed values
        in the original base projection year.
        &#34;&#34;&#34;
        return self.baseline_projections.x1_constants

    @property
    def j1_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to J1 to ensure projections equal observed values
        in the original base projection year.
        &#34;&#34;&#34;
        return self.baseline_projections.j1_constants

    @property
    def ze_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to ZE to ensure projections equal observed values
        in the original base projection year.
        &#34;&#34;&#34;
        return self.baseline_projections.ze_constants

    @property
    def z1_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to Z1 to ensure projections equal observed values
        in the original base projection year.
        &#34;&#34;&#34;
        return self.baseline_projections.z1_constants
    
    #####################################################################################
    # Constant calculation functionality after here
    #####################################################################################

    def __compute_constant_adjustments(self):
        &#34;&#34;&#34;
        ### Overview

        We already have the original first projection year database values
        for all vectors and for the variables that are adjusted by intertemporal 
        variables. They are all accessible from the baseline projections.

        Step 1.
        Compute SSF raw projections in the original first projection year minus
        the values for those projected variable vectors in the database for
        that original first projection year. These will differ from those produced
        in the baseline because the relinearisation will have changed the 
        state space form of the model.

        Step 2.
        Compute the intertemporal constants.

        &#34;&#34;&#34;

        # Step 1.
        self.__compute_original_first_projection_year_ssf_deviations_from_observed_values()

        # Step 2.
        self.__calculate_intertemporal_constants()

    def __compute_original_first_projection_year_ssf_deviations_from_observed_values(self):
        &#34;&#34;&#34;
        ### Overview

        Step 1.
        Calculate the  values for the LHS vectors  in  the
        original first projection year using the relinearised
        state space form of the model. This uses the RHS vectors
        for the first projection year associated with the 
        baseline projections (NOT THESE RELINEARISED PROJECTIONS.)

        and 

        Step 2.
        Calculate the differences between the database values for the RHS vectors
        `x1r`, `j1r`, `zer`, and `z1r` and the values computed in Step 1. Store these
        as properties of the class instance. They become constant adjustments that are
        used in the projection process to ensure that the database values in 
        the first projection year match the baseline projections of those values.

        The differences are preserved as the database values minus projections.
        &#34;&#34;&#34;

        # Step 1.
        x1l_ssf_calculations_using_first_projection_year_data = self.state_space_form.delta(&#39;x1l&#39;, &#39;yxr&#39;) @ self.baseline_projections.first_projection_year_yxr + \
            self.state_space_form.delta(&#39;x1l&#39;, &#39;yjr&#39;) @ self.baseline_projections.first_projection_year_yjr + \
            self.state_space_form.delta(&#39;x1l&#39;, &#39;exz&#39;) @ self.baseline_projections.first_projection_year_exz + \
            self.state_space_form.delta(&#39;x1l&#39;, &#39;exo&#39;) @ self.baseline_projections.first_projection_year_exo

        j1l_ssf_calculations_using_first_projection_year_data = self.state_space_form.delta(&#39;j1l&#39;, &#39;yxr&#39;) @ self.baseline_projections.first_projection_year_yxr + \
            self.state_space_form.delta(&#39;j1l&#39;, &#39;yjr&#39;) @ self.baseline_projections.first_projection_year_yjr + \
            self.state_space_form.delta(&#39;j1l&#39;, &#39;exz&#39;) @ self.baseline_projections.first_projection_year_exz + \
            self.state_space_form.delta(&#39;j1l&#39;, &#39;exo&#39;) @ self.baseline_projections.first_projection_year_exo

        zel_ssf_calculations_using_first_projection_year_data = self.state_space_form.delta(&#39;zel&#39;, &#39;yxr&#39;) @ self.baseline_projections.first_projection_year_yxr + \
            self.state_space_form.delta(&#39;zel&#39;, &#39;yjr&#39;) @ self.baseline_projections.first_projection_year_yjr + \
            self.state_space_form.delta(&#39;zel&#39;, &#39;exz&#39;) @ self.baseline_projections.first_projection_year_exz + \
            self.state_space_form.delta(&#39;zel&#39;, &#39;exo&#39;) @ self.baseline_projections.first_projection_year_exo

        z1l_ssf_calculations_using_first_projection_year_data = self.state_space_form.delta(&#39;z1l&#39;, &#39;yxr&#39;) @ self.baseline_projections.first_projection_year_yxr + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;yjr&#39;) @ self.baseline_projections.first_projection_year_yjr + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;exz&#39;) @ self.baseline_projections.first_projection_year_exz + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;exo&#39;) @ self.baseline_projections.first_projection_year_exo

        # Step 2.
        self._x1r_difference_from_ssf = self.baseline_projections.first_projection_year_x1r - x1l_ssf_calculations_using_first_projection_year_data  # t+1 = year after base year
        self._j1r_difference_from_ssf = self.baseline_projections.first_projection_year_j1r - j1l_ssf_calculations_using_first_projection_year_data  # t+1 = year after base year
        self._zer_difference_from_ssf = self.baseline_projections.first_projection_year_zer - zel_ssf_calculations_using_first_projection_year_data  # t = base year
        self._z1r_difference_from_ssf = self.baseline_projections.first_projection_year_z1r - z1l_ssf_calculations_using_first_projection_year_data  # t = base year

    @property
    def x1r_difference_from_ssf(self):
        &#34;&#34;&#34;
        The original first projection year 
        difference between the database values of `x1r`
        and the raw baseline projections of those values,
        without making any constant adjustments at all.

        These differences are added to the constants that
        are used in the baseline projections to ensure that
        the projections in the first projection year match
        the database values in that year.
        &#34;&#34;&#34;
        return self._x1r_difference_from_ssf

    @property
    def j1r_difference_from_ssf(self):
        &#34;&#34;&#34;
        The original first projection year 
        difference between the database values of `j1r`
        and the raw baseline projections of those values,
        without making any constant adjustments at all.

        These differences are added to the constants that
        are used in the baseline projections to ensure that
        the projections in the first projection year match
        the database values in that year.

        &#34;&#34;&#34;
        return self._j1r_difference_from_ssf

    @property
    def zer_difference_from_ssf(self):
        &#34;&#34;&#34;
        The original first projection year 
        difference between the database values of `zer`
        and the raw baseline projections of those values,
        without making any constant adjustments at all.

        These differences are added to the constants that
        are used in the baseline projections to ensure that
        the projections in the first projection year match
        the database values in that year.
        &#34;&#34;&#34;
        return self._zer_difference_from_ssf

    @property
    def z1r_difference_from_ssf(self):
        &#34;&#34;&#34;
        The original first projection year 
        difference between the database values of `z1r`
        and the raw projections of those values,
        without making any constant adjustments at all.

        These differences are added to the constants that
        are used in the baseline projections to ensure that
        the projections in the first projection year match
        the database values in that year.
        &#34;&#34;&#34;
        return self._z1r_difference_from_ssf
    

    def __evaluate_first_projection_year_vector_projections(self):
        &#34;&#34;&#34;
        Computes the values of the model equation vectors in the original 
        first projection year, using the functions of future exogenous variables, 
        the stable manifold, etc based on the relinearised model.
        &#34;&#34;&#34;

        self._exo_first_year_projections: np.ndarray = self.exo_projections.loc[:, [str(self.first_projection_year)]].to_numpy()

        self._yxr_first_year_projections: np.ndarray = self.yxr_initial_values.to_numpy().copy()

        # er = h1t*x[][1] + h2t*exog[][1] + h3t[][1];
        self._yjr_first_year_projections: np.ndarray = \
            self.stable_manifold.H1 @ self.yxr_first_year_projections + \
            self.stable_manifold.H2 @ self.exo_first_year_projections + \
            self._h3t[:, [0]]

        # tzl = mu1t*x[][1] + mu4t*exog[][1] + c4t[][1];
        self._exz_first_year_projections: np.ndarray = \
            self.stable_manifold.mu1 @ self.yxr_first_year_projections + \
            self.stable_manifold.mu2 @ self.exo_first_year_projections + \
            self._c4t[:, [0]]

        # z1l projections = d5n*x[][1]+d7n*exog[][1]+d6n*er+d4n*tzl+cz6[][1]
        self._z1l_first_year_projections: np.ndarray = \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;yxr&#39;) @ self.yxr_first_year_projections + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;exo&#39;) @ self.exo_first_year_projections + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;yjr&#39;) @ self.yjr_first_year_projections + \
            self.state_space_form.delta(&#39;z1l&#39;, &#39;exz&#39;) @ self.exz_first_year_projections + \
            self.z1r_difference_from_ssf

    @property
    def yxr_first_year_projections(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Projections of X1_t (yxr) in the first projection year
        &#34;&#34;&#34;
        return self._yxr_first_year_projections

    @property
    def yjr_first_year_projections(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Projections of J1_t (yjr) in the first projection year
        &#34;&#34;&#34;
        return self._yjr_first_year_projections

    @property
    def exz_first_year_projections(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Projections of ZE_t (exz) in the first projection year
        &#34;&#34;&#34;
        return self._exz_first_year_projections

    @property
    def z1l_first_year_projections(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Projections of Z1_t (z1l=z1r) in the first projection year
        &#34;&#34;&#34;
        return self._z1l_first_year_projections

    @property
    def exo_first_year_projections(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Projections of EXO_t in the first projection year
        &#34;&#34;&#34;
        return self._exo_first_year_projections

    @property
    def first_year_original_projections_of_variables_adjusted_by_intertemporal_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The first year projected values for the variables that are being
        adjusted by the intertemporal constants.

        The values are those for the projection that is not adjusted by intertemporal constants.

        It is used in the calculation of the intertemporal constants but it is only preserved
        as a property to facilitate benchmarking against Ox.
        &#34;&#34;&#34;
        return self._first_year_original_projections_of_variables_adjusted_by_intertemporal_constants


    def __update_perturbed_variable(self, variable_details: pd.Series):
        &#34;&#34;&#34;
        ### Overview

        For each variable that has an intertemporal constant, we need to compute
        numerical approximations to the partial derivatives of the model with respect
        to that constant. Those  partial derivatives are approximated by evaluating the 
        relevant equations in the model using the data in the first projection year and then 
        again evaluating those equations after perturbing the variable of interest by
        `gcubed.Constants.DELTA`. The difference between the two evaluations is used
        to compute the partial derivatives for that constant.

        This function does the work of perturbing the intertemporal constant 
        associated with the variable, preparing for calculation of the partial 
        derivatives for that constant.

        The adjustment to the constant (the perturbation) is made by adjusting the
        constants associated with variables&#39; observed differences from their state 
        space form equation evaluations in the baseline&#39;s first projection year.

        The original value of that constant is tracked using the private property, 
        `_original_value`, so that it can be restored after the partial derivatives
        have been computed.

        This function is called once for each variable in the SYM table of intertemporal 
        constant variables, as part of computing the intertemporal constants.

        &#34;&#34;&#34;

        if hasattr(self, &#39;_perturbed_variable_details&#39;):
            sequence = self._perturbed_variable_details[&#39;sequence&#39;]
            match self._perturbed_variable_details[&#39;var_type&#39;]:
                case &#39;x1l&#39;:
                    self.x1r_difference_from_ssf[sequence] = self._original_value
                case &#39;j1l&#39;:
                    self.j1r_difference_from_ssf[sequence] = self._original_value
                case &#39;zel&#39;:
                    self.zer_difference_from_ssf[sequence] = self._original_value
                case &#39;z1l&#39;:
                    self.z1r_difference_from_ssf[sequence] = self._original_value
            delattr(self, &#39;_original_value&#39;)

        if variable_details is None:
            delattr(self, &#39;_perturbed_variable_details&#39;)
        else:
            sequence = variable_details[&#39;sequence&#39;]
            match variable_details[&#39;var_type&#39;]:
                case &#39;x1l&#39;:
                    self._original_value = float(self.x1r_difference_from_ssf[sequence])
                    self.x1r_difference_from_ssf[sequence] = self._original_value + Constants().DELTA
                case &#39;j1l&#39;:
                    self._original_value = float(self.j1r_difference_from_ssf[sequence])
                    self.j1r_difference_from_ssf[sequence] = self._original_value + Constants().DELTA
                case &#39;zel&#39;:
                    self._original_value = float(self.zer_difference_from_ssf[sequence])
                    self.zer_difference_from_ssf[sequence] = self._original_value + Constants().DELTA
                case &#39;z1l&#39;:
                    self._original_value = float(self.z1r_difference_from_ssf[sequence])
                    self.z1r_difference_from_ssf[sequence] = self._original_value + Constants().DELTA
            self._perturbed_variable_details = variable_details

    @property
    def perturbed_variable_details(self) -&gt; pd.Series:
        &#34;&#34;&#34;
        If computing intertemporal constants, 
        the var_map details (the row of the SYM var_map dataframe)
        for the variable being perturbed as part of computing
        derivatives needed to set intertemporal constants. Otherwise, this returns
        `None` if just producing the baseline projections.
        &#34;&#34;&#34;
        if hasattr(self, &#39;_perturbed_variable_details&#39;):
            return self._perturbed_variable_details
        return None


    @property
    def first_year_projections_of_variables_adjusted_by_intertemporal_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        An column vector of first year projection values for those variables that are adjusted
        by intertemporal constants.

        The vector is populated from the vectors of first year projections for 
        each of `x1l`, `j1l`, `zel`,  and `z1l`.
        &#34;&#34;&#34;
        result = np.zeros(shape=(len(self.sym_data.variables_adjusted_by_intertemporal_constants), 1))
        i = 0
        for index, adjusted_variable_details in self.sym_data.variables_adjusted_by_intertemporal_constants.iterrows():
            sequence = adjusted_variable_details[&#39;sequence&#39;]
            match adjusted_variable_details[&#39;var_type&#39;]:
                case &#39;x1l&#39;:
                    result[i, 0] = self.yxr_first_year_projections[[sequence]]
                case &#39;j1l&#39;:
                    result[i, 0] = self.yjr_first_year_projections[[sequence]]
                case &#39;zel&#39;:
                    result[i, 0] = self.exz_first_year_projections[[sequence]]
                case &#39;z1l&#39;:
                    result[i, 0] = self.z1l_first_year_projections[[sequence]]
            i += 1
        return result

    @property
    def partial_derivatives_wrt_intertemporal_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The matrix of partial derivatives used in Newton&#39;s method to
        compute the intertemporal constants.

        This is a property of the class just to support benchmarking against Ox.
        &#34;&#34;&#34;
        return self._partial_derivatives
    

    @property
    def intertemporal_constants(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        The data frame of intertemporal constants information
        obtained from SYM but augmented with the values of the
        intertemporal constants.

        The dataframe is indexed by the variable names.

        The constant values are stored in a column called `constant_value`.
        &#34;&#34;&#34;
        return self._intertemporal_constants


    def __calculate_intertemporal_constants(self):
        &#34;&#34;&#34;
        ### Overview

        Computes the intertemporal constant adjustments to 
        jump and other variables to align starting data
        values with model projections in the first year.

        Step 1.
        Compute functions of future exogenous variables through all years from the
        original first projection year (for the baseline projections) through to 
        the last projection year. These are needed to compute the functions of future
        exogenous variables that feed into the intertemporal constant calculations.

        Step 2.
        For the variables that are to be adjusted by the intertemporal
        constants, compute their projected values in the base projection year
        and store these values for comparison to perturbed base year projections so we can calculate
        the derivatives matrix needed to set the intertemporal constants.
        Also store the values of each of the 4 vectors in the model in the base year for benchmarking.

        Step 3.
        Initialise the partial derivatives matrix. This is the matrix of derivatives of each of the
        variables that is adjusted by intertemporal constants, with respect to each of the intertemporal
        constants, in the SSF equations (each of which is linear).

        Iterate over the intertemporal constants, perturbing each and recalculating the base year projections
        of the variables that are adjusted by intertemporal constants so that we can 
        estimate the relevant numeric derivatives.

        At the end of this step, update the perturbed variable details to `None` so that
        all constants associated with the difference between observed values and SSF calculated values
        are at their unpurturbed values when doing actual baseline projections.

        Step 4.
        Apply Newton&#39;s method to solve for the intertemporal constants.
        Multiply the difference between the observed values of the variables that are adjusted by
        the intertemporal constants and their original projected values, in the first projection year,
        by the inverse of the partial derivatives matrix.

        This only needs to be done once because the SSF of the model is linear so Newton&#39;s method
        gets to the solution in one iteration.
        &#34;&#34;&#34;

        # Step 1.
        self._compute_functions_of_future_exogenous_variables(exogenous_projections=self.exo_projections)

        # Step 2.
        # Compute the first year projections - noting that no intertemporal 
        # constant adjustments have been made yet.
        self.__evaluate_first_projection_year_vector_projections()

        # Capture the first year projections of the intertemporal variables. 
        # These are used in this function for Newton&#39;s method below
        # and they are also deep-copied and stored as a property of the 
        # class for benchmarking purposes.
        self._first_year_original_projections_of_variables_adjusted_by_intertemporal_constants = self.first_year_projections_of_variables_adjusted_by_intertemporal_constants.copy()

        # Step 3.
        # Compute the partial derivatives matrix
        self._partial_derivatives = np.zeros(shape=(len(self.sym_data.intertemporal_constant_variables), len(
            self.sym_data.variables_adjusted_by_intertemporal_constants)))
        i = 0
        for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
            self.__update_perturbed_variable(variable_details=variable_details)
            self._compute_functions_of_future_exogenous_variables(exogenous_projections=self.exo_projections)
            self.__evaluate_first_projection_year_vector_projections()
            self._partial_derivatives[:, [i]] = (
                self.first_year_projections_of_variables_adjusted_by_intertemporal_constants -
                self._first_year_original_projections_of_variables_adjusted_by_intertemporal_constants) / Constants().DELTA
            i += 1

        # Generate the baseline projection to use in computing partial derivatives
        # and to generate matrix values that are used later in projection processes.
        self.__update_perturbed_variable(variable_details=None)

        # Step 4.
        # Use Newtons method adjustment to compute intertemporal constant values
        self._intertemporal_constants = self.sym_data.intertemporal_constant_variables
        values: np.ndarray = np.linalg.inv(self._partial_derivatives) @ \
            (self.baseline_projections.first_year_observed_values_of_variables_adjusted_by_intertemporal_constants -
             self.first_year_original_projections_of_variables_adjusted_by_intertemporal_constants)
        values = values.reshape((len(self.intertemporal_constants.index), 1))
        self._intertemporal_constants[&#39;constant_value&#39;] = values

        logging.info(&#34;The intertemporal constants have been calibrated for the relinearised model.&#34;)



    @property
    def x1_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to X1 to ensure projections equal observed values.
        Add any intertemporal constant values to the X1R difference to SSF equation 
        results with zero constants to get the combined set of constants.
        &#34;&#34;&#34;

        if hasattr(self, &#34;_x1_constants&#34;):
            return self._x1_constants

        result: np.ndarray = self.x1r_difference_from_ssf.copy()
        if not hasattr(self, &#34;intertemporal_constants&#34;):
            return result

        i = 0
        for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
            if variable_details[&#39;var_type&#39;] == &#39;x1l&#39;:
                result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
            i = i + 1

        self._x1_constants: np.ndarray = result
        return self._x1_constants

    @property
    def j1_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to J1 to ensure projections equal observed values.
        Add any intertemporal constant values to the X1R difference to SSF equation 
        results with zero constants to get the combined set of constants.
        &#34;&#34;&#34;

        if hasattr(self, &#34;_j1_constants&#34;):
            return self._j1_constants

        result: np.ndarray = self.j1r_difference_from_ssf.copy()
        if not hasattr(self, &#34;intertemporal_constants&#34;):
            return result
        i = 0
        for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
            if variable_details[&#39;var_type&#39;] == &#39;j1l&#39;:
                result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
            i = i + 1

        self._j1_constants: np.ndarray = result
        return self._j1_constants

    @property
    def ze_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to ZE to ensure projections equal observed values.
        Add any intertemporal constant values to the X1R difference to SSF equation 
        results with zero constants to get the combined set of constants.
        &#34;&#34;&#34;

        if hasattr(self, &#34;_ze_constants&#34;):
            return self._ze_constants

        result: np.ndarray = self.zer_difference_from_ssf.copy()
        if not hasattr(self, &#34;intertemporal_constants&#34;):
            return result

        i = 0
        for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
            if variable_details[&#39;var_type&#39;] == &#39;zel&#39;:
                logging.debug(
                    f&#34;At index {i} intertemporal constant is {self.intertemporal_constants.loc[variable_details[&#39;name&#39;],&#39;constant_value&#39;]} : shape is {self.intertemporal_constants.shape}&#34;)
                result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
            i = i + 1

        self._ze_constants: np.ndarray = result
        return self._ze_constants

    @property
    def z1_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to Z1 to ensure projections equal observed values.
        Add any intertemporal constant values to the X1R difference to SSF equation 
        results with zero constants to get the combined set of constants.
        &#34;&#34;&#34;

        if hasattr(self, &#34;_z1_constants&#34;):
            return self._z1_constants

        result: np.ndarray = self.z1r_difference_from_ssf.copy()
        if not hasattr(self, &#34;intertemporal_constants&#34;):
            return result
        i = 0
        for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
            if variable_details[&#39;var_type&#39;] == &#39;z1l&#39;:
                result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
            i = i + 1

        self._z1_constants: np.ndarray = result
        return self._z1_constants</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gcubed.projections.projections.Projections" href="projections.html#gcubed.projections.projections.Projections">Projections</a></li>
<li><a title="gcubed.base.Base" href="../base.html#gcubed.base.Base">Base</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.baseline_projections"><code class="name">var <span class="ident">baseline_projections</span> : <a title="gcubed.projections.baseline_projections.BaselineProjections" href="baseline_projections.html#gcubed.projections.baseline_projections.BaselineProjections">BaselineProjections</a></code></dt>
<dd>
<div class="desc"><p>The baseline projections that this relinearisation projections builds upon.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def baseline_projections(self) -&gt; BaselineProjections:
    &#34;&#34;&#34;
    The baseline projections that this relinearisation projections builds upon.
    &#34;&#34;&#34;
    return self._baseline_projections</code></pre>
</details>
</dd>
<dt id="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.database"><code class="name">var <span class="ident">database</span> : <a title="gcubed.data.gdp_scaled_database.GDPScaledDatabase" href="../data/gdp_scaled_database.html#gcubed.data.gdp_scaled_database.GDPScaledDatabase">GDPScaledDatabase</a></code></dt>
<dd>
<div class="desc"><p>The database used for the relinearisation and projections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def database(self) -&gt; GDPScaledDatabase:
    &#34;&#34;&#34;
    The database used for the relinearisation and projections.
    &#34;&#34;&#34;
    return self._database</code></pre>
</details>
</dd>
<dt id="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.exo_first_year_projections"><code class="name">var <span class="ident">exo_first_year_projections</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Projections of EXO_t in the first projection year</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def exo_first_year_projections(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Projections of EXO_t in the first projection year
    &#34;&#34;&#34;
    return self._exo_first_year_projections</code></pre>
</details>
</dd>
<dt id="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.exz_first_year_projections"><code class="name">var <span class="ident">exz_first_year_projections</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Projections of ZE_t (exz) in the first projection year</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def exz_first_year_projections(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Projections of ZE_t (exz) in the first projection year
    &#34;&#34;&#34;
    return self._exz_first_year_projections</code></pre>
</details>
</dd>
<dt id="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.first_year_original_projections_of_variables_adjusted_by_intertemporal_constants"><code class="name">var <span class="ident">first_year_original_projections_of_variables_adjusted_by_intertemporal_constants</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The first year projected values for the variables that are being
adjusted by the intertemporal constants.</p>
<p>The values are those for the projection that is not adjusted by intertemporal constants.</p>
<p>It is used in the calculation of the intertemporal constants but it is only preserved
as a property to facilitate benchmarking against Ox.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def first_year_original_projections_of_variables_adjusted_by_intertemporal_constants(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The first year projected values for the variables that are being
    adjusted by the intertemporal constants.

    The values are those for the projection that is not adjusted by intertemporal constants.

    It is used in the calculation of the intertemporal constants but it is only preserved
    as a property to facilitate benchmarking against Ox.
    &#34;&#34;&#34;
    return self._first_year_original_projections_of_variables_adjusted_by_intertemporal_constants</code></pre>
</details>
</dd>
<dt id="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.first_year_projections_of_variables_adjusted_by_intertemporal_constants"><code class="name">var <span class="ident">first_year_projections_of_variables_adjusted_by_intertemporal_constants</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>An column vector of first year projection values for those variables that are adjusted
by intertemporal constants.</p>
<p>The vector is populated from the vectors of first year projections for
each of <code>x1l</code>, <code>j1l</code>, <code>zel</code>,
and <code>z1l</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def first_year_projections_of_variables_adjusted_by_intertemporal_constants(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    An column vector of first year projection values for those variables that are adjusted
    by intertemporal constants.

    The vector is populated from the vectors of first year projections for 
    each of `x1l`, `j1l`, `zel`,  and `z1l`.
    &#34;&#34;&#34;
    result = np.zeros(shape=(len(self.sym_data.variables_adjusted_by_intertemporal_constants), 1))
    i = 0
    for index, adjusted_variable_details in self.sym_data.variables_adjusted_by_intertemporal_constants.iterrows():
        sequence = adjusted_variable_details[&#39;sequence&#39;]
        match adjusted_variable_details[&#39;var_type&#39;]:
            case &#39;x1l&#39;:
                result[i, 0] = self.yxr_first_year_projections[[sequence]]
            case &#39;j1l&#39;:
                result[i, 0] = self.yjr_first_year_projections[[sequence]]
            case &#39;zel&#39;:
                result[i, 0] = self.exz_first_year_projections[[sequence]]
            case &#39;z1l&#39;:
                result[i, 0] = self.z1l_first_year_projections[[sequence]]
        i += 1
    return result</code></pre>
</details>
</dd>
<dt id="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.intertemporal_constants"><code class="name">var <span class="ident">intertemporal_constants</span> : pandas.core.frame.DataFrame</code></dt>
<dd>
<div class="desc"><p>The data frame of intertemporal constants information
obtained from SYM but augmented with the values of the
intertemporal constants.</p>
<p>The dataframe is indexed by the variable names.</p>
<p>The constant values are stored in a column called <code>constant_value</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def intertemporal_constants(self) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    The data frame of intertemporal constants information
    obtained from SYM but augmented with the values of the
    intertemporal constants.

    The dataframe is indexed by the variable names.

    The constant values are stored in a column called `constant_value`.
    &#34;&#34;&#34;
    return self._intertemporal_constants</code></pre>
</details>
</dd>
<dt id="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.j1_constants"><code class="name">var <span class="ident">j1_constants</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The constant adjustments to J1 to ensure projections equal observed values.
Add any intertemporal constant values to the X1R difference to SSF equation
results with zero constants to get the combined set of constants.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def j1_constants(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The constant adjustments to J1 to ensure projections equal observed values.
    Add any intertemporal constant values to the X1R difference to SSF equation 
    results with zero constants to get the combined set of constants.
    &#34;&#34;&#34;

    if hasattr(self, &#34;_j1_constants&#34;):
        return self._j1_constants

    result: np.ndarray = self.j1r_difference_from_ssf.copy()
    if not hasattr(self, &#34;intertemporal_constants&#34;):
        return result
    i = 0
    for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
        if variable_details[&#39;var_type&#39;] == &#39;j1l&#39;:
            result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
        i = i + 1

    self._j1_constants: np.ndarray = result
    return self._j1_constants</code></pre>
</details>
</dd>
<dt id="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.j1r_difference_from_ssf"><code class="name">var <span class="ident">j1r_difference_from_ssf</span></code></dt>
<dd>
<div class="desc"><p>The original first projection year
difference between the database values of <code>j1r</code>
and the raw baseline projections of those values,
without making any constant adjustments at all.</p>
<p>These differences are added to the constants that
are used in the baseline projections to ensure that
the projections in the first projection year match
the database values in that year.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def j1r_difference_from_ssf(self):
    &#34;&#34;&#34;
    The original first projection year 
    difference between the database values of `j1r`
    and the raw baseline projections of those values,
    without making any constant adjustments at all.

    These differences are added to the constants that
    are used in the baseline projections to ensure that
    the projections in the first projection year match
    the database values in that year.

    &#34;&#34;&#34;
    return self._j1r_difference_from_ssf</code></pre>
</details>
</dd>
<dt id="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.model"><code class="name">var <span class="ident">model</span> : <a title="gcubed.model.Model" href="../model.html#gcubed.model.Model">Model</a></code></dt>
<dd>
<div class="desc"><p>The model to relinearise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def model(self) -&gt; Model:
    &#34;&#34;&#34;
    The model to relinearise.
    &#34;&#34;&#34;
    return self.state_space_form.model</code></pre>
</details>
</dd>
<dt id="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.parameters"><code class="name">var <span class="ident">parameters</span> : <a title="gcubed.model_parameters.parameters.Parameters" href="../model_parameters/parameters.html#gcubed.model_parameters.parameters.Parameters">Parameters</a></code></dt>
<dd>
<div class="desc"><p>The calibrated model parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def parameters(self) -&gt; Parameters:
    &#34;&#34;&#34;
    The calibrated model parameters.
    &#34;&#34;&#34;
    return self.model.parameters</code></pre>
</details>
</dd>
<dt id="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.partial_derivatives_wrt_intertemporal_constants"><code class="name">var <span class="ident">partial_derivatives_wrt_intertemporal_constants</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The matrix of partial derivatives used in Newton's method to
compute the intertemporal constants.</p>
<p>This is a property of the class just to support benchmarking against Ox.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def partial_derivatives_wrt_intertemporal_constants(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The matrix of partial derivatives used in Newton&#39;s method to
    compute the intertemporal constants.

    This is a property of the class just to support benchmarking against Ox.
    &#34;&#34;&#34;
    return self._partial_derivatives</code></pre>
</details>
</dd>
<dt id="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.perturbed_variable_details"><code class="name">var <span class="ident">perturbed_variable_details</span> : pandas.core.series.Series</code></dt>
<dd>
<div class="desc"><p>If computing intertemporal constants,
the var_map details (the row of the SYM var_map dataframe)
for the variable being perturbed as part of computing
derivatives needed to set intertemporal constants. Otherwise, this returns
<code>None</code> if just producing the baseline projections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def perturbed_variable_details(self) -&gt; pd.Series:
    &#34;&#34;&#34;
    If computing intertemporal constants, 
    the var_map details (the row of the SYM var_map dataframe)
    for the variable being perturbed as part of computing
    derivatives needed to set intertemporal constants. Otherwise, this returns
    `None` if just producing the baseline projections.
    &#34;&#34;&#34;
    if hasattr(self, &#39;_perturbed_variable_details&#39;):
        return self._perturbed_variable_details
    return None</code></pre>
</details>
</dd>
<dt id="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.relinearise_around_the_neutral_real_interest_rate"><code class="name">var <span class="ident">relinearise_around_the_neutral_real_interest_rate</span> : bool</code></dt>
<dd>
<div class="desc"><p><code>True</code> if
relinearisations are around the neutral real interest rate
and <code>False</code> if they are around previous projection values
in the relinearisation year.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def relinearise_around_the_neutral_real_interest_rate(self) -&gt; bool:
    &#34;&#34;&#34;
    `True` if  relinearisations are around the neutral real interest rate
    and `False` if they are around previous projection values
    in the relinearisation year.
    &#34;&#34;&#34;
    return self._relinearise_around_the_neutral_real_interest_rate</code></pre>
</details>
</dd>
<dt id="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.simulation_layer_definitions"><code class="name">var <span class="ident">simulation_layer_definitions</span> : <a title="gcubed.projections.simulation_layer_definitions.SimulationLayerDefinitions" href="simulation_layer_definitions.html#gcubed.projections.simulation_layer_definitions.SimulationLayerDefinitions">SimulationLayerDefinitions</a></code></dt>
<dd>
<div class="desc"><p>The list of simulation layer definitions, in their appropriate order
from the first to be applied to the last to be applied.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def simulation_layer_definitions(self) -&gt; SimulationLayerDefinitions:
    &#34;&#34;&#34;
    The list of simulation layer definitions, in their appropriate order
    from the first to be applied to the last to be applied.
    &#34;&#34;&#34;
    return self._simulation_layer_definitions</code></pre>
</details>
</dd>
<dt id="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.stable_manifold"><code class="name">var <span class="ident">stable_manifold</span> : <a title="gcubed.linearisation.stable_manifold.StableManifold" href="../linearisation/stable_manifold.html#gcubed.linearisation.stable_manifold.StableManifold">StableManifold</a></code></dt>
<dd>
<div class="desc"><p>The stable manifold after doing the relinearisation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def stable_manifold(self) -&gt; StableManifold:
    &#34;&#34;&#34;
    The stable manifold after doing the relinearisation.
    &#34;&#34;&#34;
    return self._stable_manifold</code></pre>
</details>
</dd>
<dt id="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.state_space_form"><code class="name">var <span class="ident">state_space_form</span> : <a title="gcubed.linearisation.state_space_form.StateSpaceForm" href="../linearisation/state_space_form.html#gcubed.linearisation.state_space_form.StateSpaceForm">StateSpaceForm</a></code></dt>
<dd>
<div class="desc"><p>The state-space form after doing the relinearisation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def state_space_form(self) -&gt; StateSpaceForm:
    &#34;&#34;&#34;
    The state-space form after doing the relinearisation.
    &#34;&#34;&#34;
    return self.stable_manifold.ssf</code></pre>
</details>
</dd>
<dt id="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.sym_data"><code class="name">var <span class="ident">sym_data</span> : <a title="gcubed.sym_data.SymData" href="../sym_data.html#gcubed.sym_data.SymData">SymData</a></code></dt>
<dd>
<div class="desc"><p>The SYM generated data about the model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sym_data(self) -&gt; SymData:
    &#34;&#34;&#34;
    The SYM generated data about the model.
    &#34;&#34;&#34;
    return self.model.sym_data</code></pre>
</details>
</dd>
<dt id="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.x1_constants"><code class="name">var <span class="ident">x1_constants</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The constant adjustments to X1 to ensure projections equal observed values.
Add any intertemporal constant values to the X1R difference to SSF equation
results with zero constants to get the combined set of constants.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def x1_constants(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The constant adjustments to X1 to ensure projections equal observed values.
    Add any intertemporal constant values to the X1R difference to SSF equation 
    results with zero constants to get the combined set of constants.
    &#34;&#34;&#34;

    if hasattr(self, &#34;_x1_constants&#34;):
        return self._x1_constants

    result: np.ndarray = self.x1r_difference_from_ssf.copy()
    if not hasattr(self, &#34;intertemporal_constants&#34;):
        return result

    i = 0
    for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
        if variable_details[&#39;var_type&#39;] == &#39;x1l&#39;:
            result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
        i = i + 1

    self._x1_constants: np.ndarray = result
    return self._x1_constants</code></pre>
</details>
</dd>
<dt id="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.x1r_difference_from_ssf"><code class="name">var <span class="ident">x1r_difference_from_ssf</span></code></dt>
<dd>
<div class="desc"><p>The original first projection year
difference between the database values of <code>x1r</code>
and the raw baseline projections of those values,
without making any constant adjustments at all.</p>
<p>These differences are added to the constants that
are used in the baseline projections to ensure that
the projections in the first projection year match
the database values in that year.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def x1r_difference_from_ssf(self):
    &#34;&#34;&#34;
    The original first projection year 
    difference between the database values of `x1r`
    and the raw baseline projections of those values,
    without making any constant adjustments at all.

    These differences are added to the constants that
    are used in the baseline projections to ensure that
    the projections in the first projection year match
    the database values in that year.
    &#34;&#34;&#34;
    return self._x1r_difference_from_ssf</code></pre>
</details>
</dd>
<dt id="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.yjr_first_year_projections"><code class="name">var <span class="ident">yjr_first_year_projections</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Projections of J1_t (yjr) in the first projection year</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def yjr_first_year_projections(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Projections of J1_t (yjr) in the first projection year
    &#34;&#34;&#34;
    return self._yjr_first_year_projections</code></pre>
</details>
</dd>
<dt id="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.yxr_first_year_projections"><code class="name">var <span class="ident">yxr_first_year_projections</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Projections of X1_t (yxr) in the first projection year</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def yxr_first_year_projections(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Projections of X1_t (yxr) in the first projection year
    &#34;&#34;&#34;
    return self._yxr_first_year_projections</code></pre>
</details>
</dd>
<dt id="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.z1_constants"><code class="name">var <span class="ident">z1_constants</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The constant adjustments to Z1 to ensure projections equal observed values.
Add any intertemporal constant values to the X1R difference to SSF equation
results with zero constants to get the combined set of constants.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def z1_constants(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The constant adjustments to Z1 to ensure projections equal observed values.
    Add any intertemporal constant values to the X1R difference to SSF equation 
    results with zero constants to get the combined set of constants.
    &#34;&#34;&#34;

    if hasattr(self, &#34;_z1_constants&#34;):
        return self._z1_constants

    result: np.ndarray = self.z1r_difference_from_ssf.copy()
    if not hasattr(self, &#34;intertemporal_constants&#34;):
        return result
    i = 0
    for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
        if variable_details[&#39;var_type&#39;] == &#39;z1l&#39;:
            result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
        i = i + 1

    self._z1_constants: np.ndarray = result
    return self._z1_constants</code></pre>
</details>
</dd>
<dt id="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.z1l_first_year_projections"><code class="name">var <span class="ident">z1l_first_year_projections</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Projections of Z1_t (z1l=z1r) in the first projection year</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def z1l_first_year_projections(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Projections of Z1_t (z1l=z1r) in the first projection year
    &#34;&#34;&#34;
    return self._z1l_first_year_projections</code></pre>
</details>
</dd>
<dt id="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.z1r_difference_from_ssf"><code class="name">var <span class="ident">z1r_difference_from_ssf</span></code></dt>
<dd>
<div class="desc"><p>The original first projection year
difference between the database values of <code>z1r</code>
and the raw projections of those values,
without making any constant adjustments at all.</p>
<p>These differences are added to the constants that
are used in the baseline projections to ensure that
the projections in the first projection year match
the database values in that year.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def z1r_difference_from_ssf(self):
    &#34;&#34;&#34;
    The original first projection year 
    difference between the database values of `z1r`
    and the raw projections of those values,
    without making any constant adjustments at all.

    These differences are added to the constants that
    are used in the baseline projections to ensure that
    the projections in the first projection year match
    the database values in that year.
    &#34;&#34;&#34;
    return self._z1r_difference_from_ssf</code></pre>
</details>
</dd>
<dt id="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.ze_constants"><code class="name">var <span class="ident">ze_constants</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The constant adjustments to ZE to ensure projections equal observed values.
Add any intertemporal constant values to the X1R difference to SSF equation
results with zero constants to get the combined set of constants.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ze_constants(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The constant adjustments to ZE to ensure projections equal observed values.
    Add any intertemporal constant values to the X1R difference to SSF equation 
    results with zero constants to get the combined set of constants.
    &#34;&#34;&#34;

    if hasattr(self, &#34;_ze_constants&#34;):
        return self._ze_constants

    result: np.ndarray = self.zer_difference_from_ssf.copy()
    if not hasattr(self, &#34;intertemporal_constants&#34;):
        return result

    i = 0
    for index, variable_details in self.sym_data.intertemporal_constant_variables.iterrows():
        if variable_details[&#39;var_type&#39;] == &#39;zel&#39;:
            logging.debug(
                f&#34;At index {i} intertemporal constant is {self.intertemporal_constants.loc[variable_details[&#39;name&#39;],&#39;constant_value&#39;]} : shape is {self.intertemporal_constants.shape}&#34;)
            result[variable_details[&#39;sequence&#39;], 0] += self.intertemporal_constants.loc[variable_details[&#39;name&#39;], &#39;constant_value&#39;]
        i = i + 1

    self._ze_constants: np.ndarray = result
    return self._ze_constants</code></pre>
</details>
</dd>
<dt id="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.zer_difference_from_ssf"><code class="name">var <span class="ident">zer_difference_from_ssf</span></code></dt>
<dd>
<div class="desc"><p>The original first projection year
difference between the database values of <code>zer</code>
and the raw baseline projections of those values,
without making any constant adjustments at all.</p>
<p>These differences are added to the constants that
are used in the baseline projections to ensure that
the projections in the first projection year match
the database values in that year.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def zer_difference_from_ssf(self):
    &#34;&#34;&#34;
    The original first projection year 
    difference between the database values of `zer`
    and the raw baseline projections of those values,
    without making any constant adjustments at all.

    These differences are added to the constants that
    are used in the baseline projections to ensure that
    the projections in the first projection year match
    the database values in that year.
    &#34;&#34;&#34;
    return self._zer_difference_from_ssf</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.populate_exogenous_projections_and_initial_state_vector"><code class="name flex">
<span>def <span class="ident">populate_exogenous_projections_and_initial_state_vector</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="overview">Overview</h3>
<p>Load exogenous variable projections and initial state vector values
from the previous projections.</p>
<p>For any simulation layer definition with its event year equal to the base
year for this projections, augment the exogenous variables and state
vector with supplied simulation layer data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def populate_exogenous_projections_and_initial_state_vector(self):
    &#34;&#34;&#34;

    ### Overview

    Load exogenous variable projections and initial state vector values
    from the previous projections.

    For any simulation layer definition with its event year equal to the base
    year for this projections, augment the exogenous variables and state
    vector with supplied simulation layer data.
    &#34;&#34;&#34;

    self._exo_projections = self.previous_projections.exo_projections.copy()

    self._yxr_initial_values: pd.DataFrame = self.previous_projections.yxr_projections_as_dataframe.loc[:, [str(self.first_projection_year)]].copy()

    for simulation_layer_definition in self.simulation_layer_definitions:
        self.__apply_simulation_layer(simulation_layer_definition=simulation_layer_definition)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gcubed.projections.projections.Projections" href="projections.html#gcubed.projections.projections.Projections">Projections</a></b></code>:
<ul class="hlist">
<li><code><a title="gcubed.projections.projections.Projections.annotated_database_projections" href="projections.html#gcubed.projections.projections.Projections.annotated_database_projections">annotated_database_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.annotated_projections" href="projections.html#gcubed.projections.projections.Projections.annotated_projections">annotated_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.annotated_publishable_projections" href="projections.html#gcubed.projections.projections.Projections.annotated_publishable_projections">annotated_publishable_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.c4t" href="projections.html#gcubed.projections.projections.Projections.c4t">c4t</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.c4t_as_dataframe" href="projections.html#gcubed.projections.projections.Projections.c4t_as_dataframe">c4t_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.configuration" href="projections.html#gcubed.projections.projections.Projections.configuration">configuration</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.database_projections" href="projections.html#gcubed.projections.projections.Projections.database_projections">database_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.exo_projections" href="projections.html#gcubed.projections.projections.Projections.exo_projections">exo_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.exz_projections" href="projections.html#gcubed.projections.projections.Projections.exz_projections">exz_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.exz_projections_as_dataframe" href="projections.html#gcubed.projections.projections.Projections.exz_projections_as_dataframe">exz_projections_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.first_projection_year" href="projections.html#gcubed.projections.projections.Projections.first_projection_year">first_projection_year</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.get_differences_between_projections" href="projections.html#gcubed.projections.projections.Projections.get_differences_between_projections">get_differences_between_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.get_year_labels" href="../base.html#gcubed.base.Base.get_year_labels">get_year_labels</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.h3t" href="projections.html#gcubed.projections.projections.Projections.h3t">h3t</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.h3t_as_dataframe" href="projections.html#gcubed.projections.projections.Projections.h3t_as_dataframe">h3t_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.is_baseline_projections" href="projections.html#gcubed.projections.projections.Projections.is_baseline_projections">is_baseline_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.last_projection_year" href="projections.html#gcubed.projections.projections.Projections.last_projection_year">last_projection_year</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.load_data" href="../base.html#gcubed.base.Base.load_data">load_data</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.long_rate_constants" href="projections.html#gcubed.projections.projections.Projections.long_rate_constants">long_rate_constants</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.now" href="../base.html#gcubed.base.Base.now">now</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.previous_projections" href="projections.html#gcubed.projections.projections.Projections.previous_projections">previous_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.projection_years" href="projections.html#gcubed.projections.projections.Projections.projection_years">projection_years</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.projection_years_column_labels" href="projections.html#gcubed.projections.projections.Projections.projection_years_column_labels">projection_years_column_labels</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.projections" href="projections.html#gcubed.projections.projections.Projections.projections">projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.publishable_projections" href="projections.html#gcubed.projections.projections.Projections.publishable_projections">publishable_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.yjr_projections" href="projections.html#gcubed.projections.projections.Projections.yjr_projections">yjr_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.yjr_projections_as_dataframe" href="projections.html#gcubed.projections.projections.Projections.yjr_projections_as_dataframe">yjr_projections_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.yxr_initial_values" href="projections.html#gcubed.projections.projections.Projections.yxr_initial_values">yxr_initial_values</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.yxr_projections" href="projections.html#gcubed.projections.projections.Projections.yxr_projections">yxr_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.yxr_projections_as_dataframe" href="projections.html#gcubed.projections.projections.Projections.yxr_projections_as_dataframe">yxr_projections_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.z1l_projections" href="projections.html#gcubed.projections.projections.Projections.z1l_projections">z1l_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.z1l_projections_as_dataframe" href="projections.html#gcubed.projections.projections.Projections.z1l_projections_as_dataframe">z1l_projections_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.zel_projections" href="projections.html#gcubed.projections.projections.Projections.zel_projections">zel_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.zel_projections_as_dataframe" href="projections.html#gcubed.projections.projections.Projections.zel_projections_as_dataframe">zel_projections_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.zeros" href="../base.html#gcubed.base.Base.zeros">zeros</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gcubed.projections" href="index.html">gcubed.projections</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gcubed.projections.relinearisation_projections copy.RelinearisationProjections" href="#gcubed.projections.relinearisation_projections copy.RelinearisationProjections">RelinearisationProjections</a></code></h4>
<ul class="">
<li><code><a title="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.baseline_projections" href="#gcubed.projections.relinearisation_projections copy.RelinearisationProjections.baseline_projections">baseline_projections</a></code></li>
<li><code><a title="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.database" href="#gcubed.projections.relinearisation_projections copy.RelinearisationProjections.database">database</a></code></li>
<li><code><a title="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.exo_first_year_projections" href="#gcubed.projections.relinearisation_projections copy.RelinearisationProjections.exo_first_year_projections">exo_first_year_projections</a></code></li>
<li><code><a title="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.exz_first_year_projections" href="#gcubed.projections.relinearisation_projections copy.RelinearisationProjections.exz_first_year_projections">exz_first_year_projections</a></code></li>
<li><code><a title="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.first_year_original_projections_of_variables_adjusted_by_intertemporal_constants" href="#gcubed.projections.relinearisation_projections copy.RelinearisationProjections.first_year_original_projections_of_variables_adjusted_by_intertemporal_constants">first_year_original_projections_of_variables_adjusted_by_intertemporal_constants</a></code></li>
<li><code><a title="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.first_year_projections_of_variables_adjusted_by_intertemporal_constants" href="#gcubed.projections.relinearisation_projections copy.RelinearisationProjections.first_year_projections_of_variables_adjusted_by_intertemporal_constants">first_year_projections_of_variables_adjusted_by_intertemporal_constants</a></code></li>
<li><code><a title="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.intertemporal_constants" href="#gcubed.projections.relinearisation_projections copy.RelinearisationProjections.intertemporal_constants">intertemporal_constants</a></code></li>
<li><code><a title="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.j1_constants" href="#gcubed.projections.relinearisation_projections copy.RelinearisationProjections.j1_constants">j1_constants</a></code></li>
<li><code><a title="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.j1r_difference_from_ssf" href="#gcubed.projections.relinearisation_projections copy.RelinearisationProjections.j1r_difference_from_ssf">j1r_difference_from_ssf</a></code></li>
<li><code><a title="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.model" href="#gcubed.projections.relinearisation_projections copy.RelinearisationProjections.model">model</a></code></li>
<li><code><a title="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.parameters" href="#gcubed.projections.relinearisation_projections copy.RelinearisationProjections.parameters">parameters</a></code></li>
<li><code><a title="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.partial_derivatives_wrt_intertemporal_constants" href="#gcubed.projections.relinearisation_projections copy.RelinearisationProjections.partial_derivatives_wrt_intertemporal_constants">partial_derivatives_wrt_intertemporal_constants</a></code></li>
<li><code><a title="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.perturbed_variable_details" href="#gcubed.projections.relinearisation_projections copy.RelinearisationProjections.perturbed_variable_details">perturbed_variable_details</a></code></li>
<li><code><a title="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.populate_exogenous_projections_and_initial_state_vector" href="#gcubed.projections.relinearisation_projections copy.RelinearisationProjections.populate_exogenous_projections_and_initial_state_vector">populate_exogenous_projections_and_initial_state_vector</a></code></li>
<li><code><a title="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.relinearise_around_the_neutral_real_interest_rate" href="#gcubed.projections.relinearisation_projections copy.RelinearisationProjections.relinearise_around_the_neutral_real_interest_rate">relinearise_around_the_neutral_real_interest_rate</a></code></li>
<li><code><a title="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.simulation_layer_definitions" href="#gcubed.projections.relinearisation_projections copy.RelinearisationProjections.simulation_layer_definitions">simulation_layer_definitions</a></code></li>
<li><code><a title="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.stable_manifold" href="#gcubed.projections.relinearisation_projections copy.RelinearisationProjections.stable_manifold">stable_manifold</a></code></li>
<li><code><a title="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.state_space_form" href="#gcubed.projections.relinearisation_projections copy.RelinearisationProjections.state_space_form">state_space_form</a></code></li>
<li><code><a title="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.sym_data" href="#gcubed.projections.relinearisation_projections copy.RelinearisationProjections.sym_data">sym_data</a></code></li>
<li><code><a title="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.x1_constants" href="#gcubed.projections.relinearisation_projections copy.RelinearisationProjections.x1_constants">x1_constants</a></code></li>
<li><code><a title="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.x1r_difference_from_ssf" href="#gcubed.projections.relinearisation_projections copy.RelinearisationProjections.x1r_difference_from_ssf">x1r_difference_from_ssf</a></code></li>
<li><code><a title="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.yjr_first_year_projections" href="#gcubed.projections.relinearisation_projections copy.RelinearisationProjections.yjr_first_year_projections">yjr_first_year_projections</a></code></li>
<li><code><a title="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.yxr_first_year_projections" href="#gcubed.projections.relinearisation_projections copy.RelinearisationProjections.yxr_first_year_projections">yxr_first_year_projections</a></code></li>
<li><code><a title="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.z1_constants" href="#gcubed.projections.relinearisation_projections copy.RelinearisationProjections.z1_constants">z1_constants</a></code></li>
<li><code><a title="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.z1l_first_year_projections" href="#gcubed.projections.relinearisation_projections copy.RelinearisationProjections.z1l_first_year_projections">z1l_first_year_projections</a></code></li>
<li><code><a title="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.z1r_difference_from_ssf" href="#gcubed.projections.relinearisation_projections copy.RelinearisationProjections.z1r_difference_from_ssf">z1r_difference_from_ssf</a></code></li>
<li><code><a title="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.ze_constants" href="#gcubed.projections.relinearisation_projections copy.RelinearisationProjections.ze_constants">ze_constants</a></code></li>
<li><code><a title="gcubed.projections.relinearisation_projections copy.RelinearisationProjections.zer_difference_from_ssf" href="#gcubed.projections.relinearisation_projections copy.RelinearisationProjections.zer_difference_from_ssf">zer_difference_from_ssf</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
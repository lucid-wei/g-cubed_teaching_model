<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gcubed.projections.mock_relinearisation_projections API documentation</title>
<meta name="description" content="Mock relinearisation projections …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gcubed.projections.mock_relinearisation_projections</code></h1>
</header>
<section id="section-intro">
<h3 id="mock-relinearisation-projections">Mock relinearisation projections</h3>
<p>Do not use this class for actual work. It is just part of unit testing.</p>
<p>Contains the MockRelinearisationProjections class, used for unit
testing experiments in relation to relinearisation.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># ------------------------------------------------------------------
# Purpose: Compute and provide access to relinearisation projections.
# Author: Geoff Shuetrim
# ------------------------------------------------------------------
&#34;&#34;&#34;

### Mock relinearisation projections

Do not use this class for actual work. It is just part of unit testing.

Contains the MockRelinearisationProjections class, used for unit
testing experiments in relation to relinearisation.
&#34;&#34;&#34;
import logging
import os
from gcubed import baseline
import pandas as pd
import numpy as np
from gcubed.constants import Constants
from gcubed.sym_data import SymData
from gcubed.model_parameters.parameters import Parameters
from gcubed.model_configuration import ModelConfiguration
from gcubed.model import Model
from gcubed.linearisation.linear_model import LinearModel
from gcubed.linearisation.stable_manifold import StableManifold
from gcubed.linearisation.state_space_form import StateSpaceForm
from gcubed.data.gdp_scaled_database import GDPScaledDatabase
from gcubed.projections.model_updater import ModelUpdater
from gcubed.projections.projections import Projections
from gcubed.projections.baseline_projections import BaselineProjections
from gcubed.projections.simulation_layer_definitions import SimulationLayerDefinitions
from gcubed.projections.simulation_layer_definition import SimulationLayerDefinition

class MockRelinearisationProjections(Projections):
    &#34;&#34;&#34;
    Compute the relinearisation model projections over the projection horizon 
    from the base projection year (the last year with available data)
    through to the last projection year.
    &#34;&#34;&#34;

    def __init__(self, baseline_projections: BaselineProjections, previous_projections: Projections, relinearisation_year: int, simulation_layer_definitions: SimulationLayerDefinitions = []) -&gt; None:
        &#34;&#34;&#34;

        ### Constructor

        Creates relinearisation projections for the specified new base year.

        ### Arguments

        baseline_projections: The baseline projections.

        previous_projections: The previous projections.

        relinearisation_year: The year that the relinearisation is being done.

        simulation_layer_definitions: 
        An optional input that provides an ordered list of simulation layer 
        definitions that can be used to augment the initial state vector and 
        the exogenous variable projections that underpin the projections. 
        The simulation layers are ignored if they have an event year that 
        is not equal to the base projection year.
        &#34;&#34;&#34;

        # Store the baseline projections
        assert baseline_projections is not None
        self._baseline_projections = baseline_projections

        # Store the simulation layer definitions (if any were provided.)
        self._simulation_layer_definitions = simulation_layer_definitions

        # Update the model from the old projections, changing the model configuration&#39;s projection base year.
        # and augmenting the database for the model to include values from the old projections for each 
        # of the projection years.
        my_previous_projections: Projections = previous_projections if previous_projections is not None else baseline_projections
        new_model: Model = ModelUpdater.get_updated_model(projections=my_previous_projections, new_first_projection_year=relinearisation_year)

        assert new_model.configuration.first_projection_year == relinearisation_year
        assert new_model.configuration.linearisation_year == relinearisation_year

        self._long_rate_constants: pd.DataFrame = self.baseline_projections.long_rate_constants

        # Relinearise the updated model around the new projection base year to get the revised stable manifold.
        
        # The following two lines are where we switch out the new linearisations with the old ones.
        linear_model: LinearModel = previous_projections.state_space_form.linear_model
        linear_model.model = new_model

        state_space_form: StateSpaceForm = StateSpaceForm(linear_model=linear_model)
        stable_manifold: StableManifold = StableManifold(state_space_form=state_space_form)
        super().__init__(stable_manifold=stable_manifold)
        self._is_baseline_projections = False
        self._previous_projections: Projections = my_previous_projections

        self._database = GDPScaledDatabase(database=new_model.database, base_year=self.configuration.base_year)

        self.populate_exogenous_projections_and_initial_state_vector()

        self._generate_projections()

        self._generate_database_projections()

        self._generate_publishable_projections()

        self.__validate()

    def __validate(self):
        &#34;&#34;&#34;
        TODO:  Validate the relinearised projections
        &#34;&#34;&#34;
        logging.info(f&#34;The {self.first_projection_year} relinearised projections have been generated.&#34;)
    
    @property
    def stable_manifold(self) -&gt; StableManifold:
        &#34;&#34;&#34;
        The stable manifold after doing the relinearisation.
        &#34;&#34;&#34;
        return self._stable_manifold

    @property
    def state_space_form(self) -&gt; StateSpaceForm:
        &#34;&#34;&#34;
        The state-space form after doing the relinearisation.
        &#34;&#34;&#34;
        return self.stable_manifold.ssf

    @property
    def model(self) -&gt; Model:
        &#34;&#34;&#34;
        The model to relinearise.
        &#34;&#34;&#34;
        return self.state_space_form.model

    @property
    def sym_data(self) -&gt; SymData:
        &#34;&#34;&#34;
        The SYM generated data about the model.
        &#34;&#34;&#34;
        return self.model.sym_data

    @property
    def parameters(self) -&gt; Parameters:
        &#34;&#34;&#34;
        The calibrated model parameters.
        &#34;&#34;&#34;
        return self.model.parameters

    @property
    def configuration(self) -&gt; ModelConfiguration:
        &#34;&#34;&#34;
        The model configuration.
        &#34;&#34;&#34;
        return self.sym_data.configuration

    @property
    def database(self) -&gt; GDPScaledDatabase:
        &#34;&#34;&#34;
        The database used for the relinearisation and projections.
        &#34;&#34;&#34;
        return self._database

    @property
    def baseline_projections(self) -&gt; BaselineProjections:
        &#34;&#34;&#34;
        The baseline projections that this relinearisation projections builds upon.
        &#34;&#34;&#34;
        return self._baseline_projections

    @property
    def simulation_layer_definitions(self) -&gt; SimulationLayerDefinitions:
        &#34;&#34;&#34;
        The list of simulation layer definitions, in their appropriate order
        from the first to be applied to the last to be applied.
        &#34;&#34;&#34;
        return self._simulation_layer_definitions

    def populate_exogenous_projections_and_initial_state_vector(self):
        &#34;&#34;&#34;

        ### Overview

        Load exogenous variable projections and initial state vector values
        from the previous projections.

        For any simulation layer definition with its event year equal to the base
        year for this projections, augment the exogenous variables and state
        vector with supplied simulation layer data.
        &#34;&#34;&#34;

        self._exo_projections = self.previous_projections.exo_projections_as_dataframe.loc[:, self.projection_years_column_labels]

        self._yxr_initial_values: pd.DataFrame = self.previous_projections.yxr_projections_as_dataframe.loc[:, [str(self.first_projection_year)]].copy()

        for simulation_layer_definition in self.simulation_layer_definitions:
            self.__apply_simulation_layer(simulation_layer_definition=simulation_layer_definition)

    def __apply_simulation_layer(self, simulation_layer_definition: SimulationLayerDefinition):
        &#34;&#34;&#34;
        ### Overview

        Applies adjustments to exogenous variables and any state 
        variables for the given simulation layer.
        &#34;&#34;&#34;
        if simulation_layer_definition.event_year != self.first_projection_year:
            return

        filename: str = simulation_layer_definition.data_filename
        assert os.path.isfile(filename)
        (simulation_variables, simulation_data) = self.load_data(filename)
        simulation_data = simulation_data.astype(float)
        simulation_variables.columns = [&#39;name&#39;]
        simulation_variables.index = simulation_variables.name
        simulation_data.index = simulation_variables.name
        try:
            simulation_data = simulation_data.loc[:, self.configuration.projection_years_column_labels]
        except:
            raise Exception(f&#34;The simulation data in {self.simulation_file} should have data from {self.first_projection_year} to {self.last_projection_year}&#34;)
        yratr: pd.DataFrame = self.baseline_projections.database.get_data(name_regular_expression=f&#34;^{Constants().US_REAL_GDP_RATIO_PREFIX}\(&#34;, years=[self.configuration.original_first_projection_year])
        yratr.index = self.sym_data.regions_members

        for variable_name in self._simulation_variables.index:
            variable_region: str = str(self.database.variables.loc[variable_name, &#39;region&#39;])
            units_for_variables_with_given_name_prefix: str = str(self.sym_data.combined_variable_summary.loc[variable_name, &#39;units&#39;])
            data: pd.DataFrame = simulation_data.loc[[variable_name], :] / 100
            vector_name = self.sym_data.projection_vector_for_variable(variable_name=variable_name)
            yratr_for_region: float = float(yratr.loc[variable_region, :].values[0])
            match units_for_variables_with_given_name_prefix:
                case &#39;gdp&#39; | &#39;mmgdp&#39; | &#39;btugdp&#39; | &#39;gwhgdp&#39;:
                    data *= yratr_for_region
                case _:
                    pass

            match vector_name:
                case &#39;exo&#39;:
                    self._exo_projections.loc[[variable_name], self.projection_years_column_labels] += data
                    pass

                case &#39;x1l&#39;:
                    self._yxr_initial_values.loc[[variable_name], [str(self.first_projection_year)]] += float(data[0])
                    pass

    @property
    def x1_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to X1 to ensure projections equal observed values
        in the original base projection year.
        &#34;&#34;&#34;
        return self.baseline_projections.x1_constants

    @property
    def j1_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to J1 to ensure projections equal observed values
        in the original base projection year.
        &#34;&#34;&#34;
        return self.baseline_projections.j1_constants

    @property
    def ze_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to ZE to ensure projections equal observed values
        in the original base projection year.
        &#34;&#34;&#34;
        return self.baseline_projections.ze_constants

    @property
    def z1_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to Z1 to ensure projections equal observed values
        in the original base projection year.
        &#34;&#34;&#34;
        return self.baseline_projections.z1_constants</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gcubed.projections.mock_relinearisation_projections.MockRelinearisationProjections"><code class="flex name class">
<span>class <span class="ident">MockRelinearisationProjections</span></span>
<span>(</span><span>baseline_projections: <a title="gcubed.projections.baseline_projections.BaselineProjections" href="baseline_projections.html#gcubed.projections.baseline_projections.BaselineProjections">BaselineProjections</a>, previous_projections: <a title="gcubed.projections.projections.Projections" href="projections.html#gcubed.projections.projections.Projections">Projections</a>, relinearisation_year: int, simulation_layer_definitions: <a title="gcubed.projections.simulation_layer_definitions.SimulationLayerDefinitions" href="simulation_layer_definitions.html#gcubed.projections.simulation_layer_definitions.SimulationLayerDefinitions">SimulationLayerDefinitions</a> = [])</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the relinearisation model projections over the projection horizon
from the base projection year (the last year with available data)
through to the last projection year.</p>
<h3 id="constructor">Constructor</h3>
<p>Creates relinearisation projections for the specified new base year.</p>
<h3 id="arguments">Arguments</h3>
<p>baseline_projections: The baseline projections.</p>
<p>previous_projections: The previous projections.</p>
<p>relinearisation_year: The year that the relinearisation is being done.</p>
<p>simulation_layer_definitions:
An optional input that provides an ordered list of simulation layer
definitions that can be used to augment the initial state vector and
the exogenous variable projections that underpin the projections.
The simulation layers are ignored if they have an event year that
is not equal to the base projection year.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MockRelinearisationProjections(Projections):
    &#34;&#34;&#34;
    Compute the relinearisation model projections over the projection horizon 
    from the base projection year (the last year with available data)
    through to the last projection year.
    &#34;&#34;&#34;

    def __init__(self, baseline_projections: BaselineProjections, previous_projections: Projections, relinearisation_year: int, simulation_layer_definitions: SimulationLayerDefinitions = []) -&gt; None:
        &#34;&#34;&#34;

        ### Constructor

        Creates relinearisation projections for the specified new base year.

        ### Arguments

        baseline_projections: The baseline projections.

        previous_projections: The previous projections.

        relinearisation_year: The year that the relinearisation is being done.

        simulation_layer_definitions: 
        An optional input that provides an ordered list of simulation layer 
        definitions that can be used to augment the initial state vector and 
        the exogenous variable projections that underpin the projections. 
        The simulation layers are ignored if they have an event year that 
        is not equal to the base projection year.
        &#34;&#34;&#34;

        # Store the baseline projections
        assert baseline_projections is not None
        self._baseline_projections = baseline_projections

        # Store the simulation layer definitions (if any were provided.)
        self._simulation_layer_definitions = simulation_layer_definitions

        # Update the model from the old projections, changing the model configuration&#39;s projection base year.
        # and augmenting the database for the model to include values from the old projections for each 
        # of the projection years.
        my_previous_projections: Projections = previous_projections if previous_projections is not None else baseline_projections
        new_model: Model = ModelUpdater.get_updated_model(projections=my_previous_projections, new_first_projection_year=relinearisation_year)

        assert new_model.configuration.first_projection_year == relinearisation_year
        assert new_model.configuration.linearisation_year == relinearisation_year

        self._long_rate_constants: pd.DataFrame = self.baseline_projections.long_rate_constants

        # Relinearise the updated model around the new projection base year to get the revised stable manifold.
        
        # The following two lines are where we switch out the new linearisations with the old ones.
        linear_model: LinearModel = previous_projections.state_space_form.linear_model
        linear_model.model = new_model

        state_space_form: StateSpaceForm = StateSpaceForm(linear_model=linear_model)
        stable_manifold: StableManifold = StableManifold(state_space_form=state_space_form)
        super().__init__(stable_manifold=stable_manifold)
        self._is_baseline_projections = False
        self._previous_projections: Projections = my_previous_projections

        self._database = GDPScaledDatabase(database=new_model.database, base_year=self.configuration.base_year)

        self.populate_exogenous_projections_and_initial_state_vector()

        self._generate_projections()

        self._generate_database_projections()

        self._generate_publishable_projections()

        self.__validate()

    def __validate(self):
        &#34;&#34;&#34;
        TODO:  Validate the relinearised projections
        &#34;&#34;&#34;
        logging.info(f&#34;The {self.first_projection_year} relinearised projections have been generated.&#34;)
    
    @property
    def stable_manifold(self) -&gt; StableManifold:
        &#34;&#34;&#34;
        The stable manifold after doing the relinearisation.
        &#34;&#34;&#34;
        return self._stable_manifold

    @property
    def state_space_form(self) -&gt; StateSpaceForm:
        &#34;&#34;&#34;
        The state-space form after doing the relinearisation.
        &#34;&#34;&#34;
        return self.stable_manifold.ssf

    @property
    def model(self) -&gt; Model:
        &#34;&#34;&#34;
        The model to relinearise.
        &#34;&#34;&#34;
        return self.state_space_form.model

    @property
    def sym_data(self) -&gt; SymData:
        &#34;&#34;&#34;
        The SYM generated data about the model.
        &#34;&#34;&#34;
        return self.model.sym_data

    @property
    def parameters(self) -&gt; Parameters:
        &#34;&#34;&#34;
        The calibrated model parameters.
        &#34;&#34;&#34;
        return self.model.parameters

    @property
    def configuration(self) -&gt; ModelConfiguration:
        &#34;&#34;&#34;
        The model configuration.
        &#34;&#34;&#34;
        return self.sym_data.configuration

    @property
    def database(self) -&gt; GDPScaledDatabase:
        &#34;&#34;&#34;
        The database used for the relinearisation and projections.
        &#34;&#34;&#34;
        return self._database

    @property
    def baseline_projections(self) -&gt; BaselineProjections:
        &#34;&#34;&#34;
        The baseline projections that this relinearisation projections builds upon.
        &#34;&#34;&#34;
        return self._baseline_projections

    @property
    def simulation_layer_definitions(self) -&gt; SimulationLayerDefinitions:
        &#34;&#34;&#34;
        The list of simulation layer definitions, in their appropriate order
        from the first to be applied to the last to be applied.
        &#34;&#34;&#34;
        return self._simulation_layer_definitions

    def populate_exogenous_projections_and_initial_state_vector(self):
        &#34;&#34;&#34;

        ### Overview

        Load exogenous variable projections and initial state vector values
        from the previous projections.

        For any simulation layer definition with its event year equal to the base
        year for this projections, augment the exogenous variables and state
        vector with supplied simulation layer data.
        &#34;&#34;&#34;

        self._exo_projections = self.previous_projections.exo_projections_as_dataframe.loc[:, self.projection_years_column_labels]

        self._yxr_initial_values: pd.DataFrame = self.previous_projections.yxr_projections_as_dataframe.loc[:, [str(self.first_projection_year)]].copy()

        for simulation_layer_definition in self.simulation_layer_definitions:
            self.__apply_simulation_layer(simulation_layer_definition=simulation_layer_definition)

    def __apply_simulation_layer(self, simulation_layer_definition: SimulationLayerDefinition):
        &#34;&#34;&#34;
        ### Overview

        Applies adjustments to exogenous variables and any state 
        variables for the given simulation layer.
        &#34;&#34;&#34;
        if simulation_layer_definition.event_year != self.first_projection_year:
            return

        filename: str = simulation_layer_definition.data_filename
        assert os.path.isfile(filename)
        (simulation_variables, simulation_data) = self.load_data(filename)
        simulation_data = simulation_data.astype(float)
        simulation_variables.columns = [&#39;name&#39;]
        simulation_variables.index = simulation_variables.name
        simulation_data.index = simulation_variables.name
        try:
            simulation_data = simulation_data.loc[:, self.configuration.projection_years_column_labels]
        except:
            raise Exception(f&#34;The simulation data in {self.simulation_file} should have data from {self.first_projection_year} to {self.last_projection_year}&#34;)
        yratr: pd.DataFrame = self.baseline_projections.database.get_data(name_regular_expression=f&#34;^{Constants().US_REAL_GDP_RATIO_PREFIX}\(&#34;, years=[self.configuration.original_first_projection_year])
        yratr.index = self.sym_data.regions_members

        for variable_name in self._simulation_variables.index:
            variable_region: str = str(self.database.variables.loc[variable_name, &#39;region&#39;])
            units_for_variables_with_given_name_prefix: str = str(self.sym_data.combined_variable_summary.loc[variable_name, &#39;units&#39;])
            data: pd.DataFrame = simulation_data.loc[[variable_name], :] / 100
            vector_name = self.sym_data.projection_vector_for_variable(variable_name=variable_name)
            yratr_for_region: float = float(yratr.loc[variable_region, :].values[0])
            match units_for_variables_with_given_name_prefix:
                case &#39;gdp&#39; | &#39;mmgdp&#39; | &#39;btugdp&#39; | &#39;gwhgdp&#39;:
                    data *= yratr_for_region
                case _:
                    pass

            match vector_name:
                case &#39;exo&#39;:
                    self._exo_projections.loc[[variable_name], self.projection_years_column_labels] += data
                    pass

                case &#39;x1l&#39;:
                    self._yxr_initial_values.loc[[variable_name], [str(self.first_projection_year)]] += float(data[0])
                    pass

    @property
    def x1_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to X1 to ensure projections equal observed values
        in the original base projection year.
        &#34;&#34;&#34;
        return self.baseline_projections.x1_constants

    @property
    def j1_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to J1 to ensure projections equal observed values
        in the original base projection year.
        &#34;&#34;&#34;
        return self.baseline_projections.j1_constants

    @property
    def ze_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to ZE to ensure projections equal observed values
        in the original base projection year.
        &#34;&#34;&#34;
        return self.baseline_projections.ze_constants

    @property
    def z1_constants(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        The constant adjustments to Z1 to ensure projections equal observed values
        in the original base projection year.
        &#34;&#34;&#34;
        return self.baseline_projections.z1_constants</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gcubed.projections.projections.Projections" href="projections.html#gcubed.projections.projections.Projections">Projections</a></li>
<li><a title="gcubed.base.Base" href="../base.html#gcubed.base.Base">Base</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="gcubed.projections.mock_relinearisation_projections.MockRelinearisationProjections.baseline_projections"><code class="name">var <span class="ident">baseline_projections</span> : <a title="gcubed.projections.baseline_projections.BaselineProjections" href="baseline_projections.html#gcubed.projections.baseline_projections.BaselineProjections">BaselineProjections</a></code></dt>
<dd>
<div class="desc"><p>The baseline projections that this relinearisation projections builds upon.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def baseline_projections(self) -&gt; BaselineProjections:
    &#34;&#34;&#34;
    The baseline projections that this relinearisation projections builds upon.
    &#34;&#34;&#34;
    return self._baseline_projections</code></pre>
</details>
</dd>
<dt id="gcubed.projections.mock_relinearisation_projections.MockRelinearisationProjections.database"><code class="name">var <span class="ident">database</span> : <a title="gcubed.data.gdp_scaled_database.GDPScaledDatabase" href="../data/gdp_scaled_database.html#gcubed.data.gdp_scaled_database.GDPScaledDatabase">GDPScaledDatabase</a></code></dt>
<dd>
<div class="desc"><p>The database used for the relinearisation and projections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def database(self) -&gt; GDPScaledDatabase:
    &#34;&#34;&#34;
    The database used for the relinearisation and projections.
    &#34;&#34;&#34;
    return self._database</code></pre>
</details>
</dd>
<dt id="gcubed.projections.mock_relinearisation_projections.MockRelinearisationProjections.j1_constants"><code class="name">var <span class="ident">j1_constants</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The constant adjustments to J1 to ensure projections equal observed values
in the original base projection year.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def j1_constants(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The constant adjustments to J1 to ensure projections equal observed values
    in the original base projection year.
    &#34;&#34;&#34;
    return self.baseline_projections.j1_constants</code></pre>
</details>
</dd>
<dt id="gcubed.projections.mock_relinearisation_projections.MockRelinearisationProjections.model"><code class="name">var <span class="ident">model</span> : <a title="gcubed.model.Model" href="../model.html#gcubed.model.Model">Model</a></code></dt>
<dd>
<div class="desc"><p>The model to relinearise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def model(self) -&gt; Model:
    &#34;&#34;&#34;
    The model to relinearise.
    &#34;&#34;&#34;
    return self.state_space_form.model</code></pre>
</details>
</dd>
<dt id="gcubed.projections.mock_relinearisation_projections.MockRelinearisationProjections.parameters"><code class="name">var <span class="ident">parameters</span> : <a title="gcubed.model_parameters.parameters.Parameters" href="../model_parameters/parameters.html#gcubed.model_parameters.parameters.Parameters">Parameters</a></code></dt>
<dd>
<div class="desc"><p>The calibrated model parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def parameters(self) -&gt; Parameters:
    &#34;&#34;&#34;
    The calibrated model parameters.
    &#34;&#34;&#34;
    return self.model.parameters</code></pre>
</details>
</dd>
<dt id="gcubed.projections.mock_relinearisation_projections.MockRelinearisationProjections.simulation_layer_definitions"><code class="name">var <span class="ident">simulation_layer_definitions</span> : <a title="gcubed.projections.simulation_layer_definitions.SimulationLayerDefinitions" href="simulation_layer_definitions.html#gcubed.projections.simulation_layer_definitions.SimulationLayerDefinitions">SimulationLayerDefinitions</a></code></dt>
<dd>
<div class="desc"><p>The list of simulation layer definitions, in their appropriate order
from the first to be applied to the last to be applied.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def simulation_layer_definitions(self) -&gt; SimulationLayerDefinitions:
    &#34;&#34;&#34;
    The list of simulation layer definitions, in their appropriate order
    from the first to be applied to the last to be applied.
    &#34;&#34;&#34;
    return self._simulation_layer_definitions</code></pre>
</details>
</dd>
<dt id="gcubed.projections.mock_relinearisation_projections.MockRelinearisationProjections.stable_manifold"><code class="name">var <span class="ident">stable_manifold</span> : <a title="gcubed.linearisation.stable_manifold.StableManifold" href="../linearisation/stable_manifold.html#gcubed.linearisation.stable_manifold.StableManifold">StableManifold</a></code></dt>
<dd>
<div class="desc"><p>The stable manifold after doing the relinearisation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def stable_manifold(self) -&gt; StableManifold:
    &#34;&#34;&#34;
    The stable manifold after doing the relinearisation.
    &#34;&#34;&#34;
    return self._stable_manifold</code></pre>
</details>
</dd>
<dt id="gcubed.projections.mock_relinearisation_projections.MockRelinearisationProjections.state_space_form"><code class="name">var <span class="ident">state_space_form</span> : <a title="gcubed.linearisation.state_space_form.StateSpaceForm" href="../linearisation/state_space_form.html#gcubed.linearisation.state_space_form.StateSpaceForm">StateSpaceForm</a></code></dt>
<dd>
<div class="desc"><p>The state-space form after doing the relinearisation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def state_space_form(self) -&gt; StateSpaceForm:
    &#34;&#34;&#34;
    The state-space form after doing the relinearisation.
    &#34;&#34;&#34;
    return self.stable_manifold.ssf</code></pre>
</details>
</dd>
<dt id="gcubed.projections.mock_relinearisation_projections.MockRelinearisationProjections.sym_data"><code class="name">var <span class="ident">sym_data</span> : <a title="gcubed.sym_data.SymData" href="../sym_data.html#gcubed.sym_data.SymData">SymData</a></code></dt>
<dd>
<div class="desc"><p>The SYM generated data about the model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sym_data(self) -&gt; SymData:
    &#34;&#34;&#34;
    The SYM generated data about the model.
    &#34;&#34;&#34;
    return self.model.sym_data</code></pre>
</details>
</dd>
<dt id="gcubed.projections.mock_relinearisation_projections.MockRelinearisationProjections.x1_constants"><code class="name">var <span class="ident">x1_constants</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The constant adjustments to X1 to ensure projections equal observed values
in the original base projection year.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def x1_constants(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The constant adjustments to X1 to ensure projections equal observed values
    in the original base projection year.
    &#34;&#34;&#34;
    return self.baseline_projections.x1_constants</code></pre>
</details>
</dd>
<dt id="gcubed.projections.mock_relinearisation_projections.MockRelinearisationProjections.z1_constants"><code class="name">var <span class="ident">z1_constants</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The constant adjustments to Z1 to ensure projections equal observed values
in the original base projection year.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def z1_constants(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The constant adjustments to Z1 to ensure projections equal observed values
    in the original base projection year.
    &#34;&#34;&#34;
    return self.baseline_projections.z1_constants</code></pre>
</details>
</dd>
<dt id="gcubed.projections.mock_relinearisation_projections.MockRelinearisationProjections.ze_constants"><code class="name">var <span class="ident">ze_constants</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The constant adjustments to ZE to ensure projections equal observed values
in the original base projection year.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ze_constants(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    The constant adjustments to ZE to ensure projections equal observed values
    in the original base projection year.
    &#34;&#34;&#34;
    return self.baseline_projections.ze_constants</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="gcubed.projections.mock_relinearisation_projections.MockRelinearisationProjections.populate_exogenous_projections_and_initial_state_vector"><code class="name flex">
<span>def <span class="ident">populate_exogenous_projections_and_initial_state_vector</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="overview">Overview</h3>
<p>Load exogenous variable projections and initial state vector values
from the previous projections.</p>
<p>For any simulation layer definition with its event year equal to the base
year for this projections, augment the exogenous variables and state
vector with supplied simulation layer data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def populate_exogenous_projections_and_initial_state_vector(self):
    &#34;&#34;&#34;

    ### Overview

    Load exogenous variable projections and initial state vector values
    from the previous projections.

    For any simulation layer definition with its event year equal to the base
    year for this projections, augment the exogenous variables and state
    vector with supplied simulation layer data.
    &#34;&#34;&#34;

    self._exo_projections = self.previous_projections.exo_projections_as_dataframe.loc[:, self.projection_years_column_labels]

    self._yxr_initial_values: pd.DataFrame = self.previous_projections.yxr_projections_as_dataframe.loc[:, [str(self.first_projection_year)]].copy()

    for simulation_layer_definition in self.simulation_layer_definitions:
        self.__apply_simulation_layer(simulation_layer_definition=simulation_layer_definition)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gcubed.projections.projections.Projections" href="projections.html#gcubed.projections.projections.Projections">Projections</a></b></code>:
<ul class="hlist">
<li><code><a title="gcubed.projections.projections.Projections.c4t" href="projections.html#gcubed.projections.projections.Projections.c4t">c4t</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.c4t_as_dataframe" href="projections.html#gcubed.projections.projections.Projections.c4t_as_dataframe">c4t_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.configuration" href="projections.html#gcubed.projections.projections.Projections.configuration">configuration</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.database_projections" href="projections.html#gcubed.projections.projections.Projections.database_projections">database_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.exo_projections" href="projections.html#gcubed.projections.projections.Projections.exo_projections">exo_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.exo_projections_as_dataframe" href="projections.html#gcubed.projections.projections.Projections.exo_projections_as_dataframe">exo_projections_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.exz_projections" href="projections.html#gcubed.projections.projections.Projections.exz_projections">exz_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.exz_projections_as_dataframe" href="projections.html#gcubed.projections.projections.Projections.exz_projections_as_dataframe">exz_projections_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.first_projection_year" href="projections.html#gcubed.projections.projections.Projections.first_projection_year">first_projection_year</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.get_differences_between_projections" href="projections.html#gcubed.projections.projections.Projections.get_differences_between_projections">get_differences_between_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.get_year_labels" href="../base.html#gcubed.base.Base.get_year_labels">get_year_labels</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.graphable_projections" href="projections.html#gcubed.projections.projections.Projections.graphable_projections">graphable_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.h3t" href="projections.html#gcubed.projections.projections.Projections.h3t">h3t</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.h3t_as_dataframe" href="projections.html#gcubed.projections.projections.Projections.h3t_as_dataframe">h3t_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.is_baseline_projections" href="projections.html#gcubed.projections.projections.Projections.is_baseline_projections">is_baseline_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.last_projection_year" href="projections.html#gcubed.projections.projections.Projections.last_projection_year">last_projection_year</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.load_data" href="../base.html#gcubed.base.Base.load_data">load_data</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.long_rate_constants" href="projections.html#gcubed.projections.projections.Projections.long_rate_constants">long_rate_constants</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.previous_projections" href="projections.html#gcubed.projections.projections.Projections.previous_projections">previous_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.projection_years" href="projections.html#gcubed.projections.projections.Projections.projection_years">projection_years</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.projection_years_column_labels" href="projections.html#gcubed.projections.projections.Projections.projection_years_column_labels">projection_years_column_labels</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.projections" href="projections.html#gcubed.projections.projections.Projections.projections">projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.publishable_projections" href="projections.html#gcubed.projections.projections.Projections.publishable_projections">publishable_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.yjr_projections" href="projections.html#gcubed.projections.projections.Projections.yjr_projections">yjr_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.yjr_projections_as_dataframe" href="projections.html#gcubed.projections.projections.Projections.yjr_projections_as_dataframe">yjr_projections_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.yxr_initial_values" href="projections.html#gcubed.projections.projections.Projections.yxr_initial_values">yxr_initial_values</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.yxr_projections" href="projections.html#gcubed.projections.projections.Projections.yxr_projections">yxr_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.yxr_projections_as_dataframe" href="projections.html#gcubed.projections.projections.Projections.yxr_projections_as_dataframe">yxr_projections_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.z1l_projections" href="projections.html#gcubed.projections.projections.Projections.z1l_projections">z1l_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.z1l_projections_as_dataframe" href="projections.html#gcubed.projections.projections.Projections.z1l_projections_as_dataframe">z1l_projections_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.zel_projections" href="projections.html#gcubed.projections.projections.Projections.zel_projections">zel_projections</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.zel_projections_as_dataframe" href="projections.html#gcubed.projections.projections.Projections.zel_projections_as_dataframe">zel_projections_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.projections.Projections.zeros" href="../base.html#gcubed.base.Base.zeros">zeros</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#mock-relinearisation-projections">Mock relinearisation projections</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gcubed.projections" href="index.html">gcubed.projections</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gcubed.projections.mock_relinearisation_projections.MockRelinearisationProjections" href="#gcubed.projections.mock_relinearisation_projections.MockRelinearisationProjections">MockRelinearisationProjections</a></code></h4>
<ul class="">
<li><code><a title="gcubed.projections.mock_relinearisation_projections.MockRelinearisationProjections.baseline_projections" href="#gcubed.projections.mock_relinearisation_projections.MockRelinearisationProjections.baseline_projections">baseline_projections</a></code></li>
<li><code><a title="gcubed.projections.mock_relinearisation_projections.MockRelinearisationProjections.database" href="#gcubed.projections.mock_relinearisation_projections.MockRelinearisationProjections.database">database</a></code></li>
<li><code><a title="gcubed.projections.mock_relinearisation_projections.MockRelinearisationProjections.j1_constants" href="#gcubed.projections.mock_relinearisation_projections.MockRelinearisationProjections.j1_constants">j1_constants</a></code></li>
<li><code><a title="gcubed.projections.mock_relinearisation_projections.MockRelinearisationProjections.model" href="#gcubed.projections.mock_relinearisation_projections.MockRelinearisationProjections.model">model</a></code></li>
<li><code><a title="gcubed.projections.mock_relinearisation_projections.MockRelinearisationProjections.parameters" href="#gcubed.projections.mock_relinearisation_projections.MockRelinearisationProjections.parameters">parameters</a></code></li>
<li><code><a title="gcubed.projections.mock_relinearisation_projections.MockRelinearisationProjections.populate_exogenous_projections_and_initial_state_vector" href="#gcubed.projections.mock_relinearisation_projections.MockRelinearisationProjections.populate_exogenous_projections_and_initial_state_vector">populate_exogenous_projections_and_initial_state_vector</a></code></li>
<li><code><a title="gcubed.projections.mock_relinearisation_projections.MockRelinearisationProjections.simulation_layer_definitions" href="#gcubed.projections.mock_relinearisation_projections.MockRelinearisationProjections.simulation_layer_definitions">simulation_layer_definitions</a></code></li>
<li><code><a title="gcubed.projections.mock_relinearisation_projections.MockRelinearisationProjections.stable_manifold" href="#gcubed.projections.mock_relinearisation_projections.MockRelinearisationProjections.stable_manifold">stable_manifold</a></code></li>
<li><code><a title="gcubed.projections.mock_relinearisation_projections.MockRelinearisationProjections.state_space_form" href="#gcubed.projections.mock_relinearisation_projections.MockRelinearisationProjections.state_space_form">state_space_form</a></code></li>
<li><code><a title="gcubed.projections.mock_relinearisation_projections.MockRelinearisationProjections.sym_data" href="#gcubed.projections.mock_relinearisation_projections.MockRelinearisationProjections.sym_data">sym_data</a></code></li>
<li><code><a title="gcubed.projections.mock_relinearisation_projections.MockRelinearisationProjections.x1_constants" href="#gcubed.projections.mock_relinearisation_projections.MockRelinearisationProjections.x1_constants">x1_constants</a></code></li>
<li><code><a title="gcubed.projections.mock_relinearisation_projections.MockRelinearisationProjections.z1_constants" href="#gcubed.projections.mock_relinearisation_projections.MockRelinearisationProjections.z1_constants">z1_constants</a></code></li>
<li><code><a title="gcubed.projections.mock_relinearisation_projections.MockRelinearisationProjections.ze_constants" href="#gcubed.projections.mock_relinearisation_projections.MockRelinearisationProjections.ze_constants">ze_constants</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gcubed.projections.base_projections API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gcubed.projections.base_projections</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># ------------------------------------------------------------------
# Purpose: Base class for baseline projections and simulations
# Author: Geoff Shuetrim
# ------------------------------------------------------------------
import logging
import pandas as pd
import numpy as np
import gcubed.constants as CONSTANTS
from gcubed.base import Base
from gcubed.model_configuration import ModelConfiguration
from gcubed.sym_data import SymData
from gcubed.model import Model
from gcubed.model_parameters.parameters import Parameters
from gcubed.state_space_form import StateSpaceForm
from gcubed.stable_manifold import StableManifold

class BaseProjections(Base):
    &#34;&#34;&#34;
    Base class for simulations and for Baseline Projections.
    &#34;&#34;&#34;

    @classmethod
    def get_deviations_between_projections(cls, new_projections:pd.DataFrame, original_projections:pd.DataFrame) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Arguments:

        new_projections: A dataframe of projections

        original_projections: A second dataframe of projections

        Produce a dataframe of differences between two projections (new_projections - original_projections).

        Note that this can be used for raw, database, publishable and graphable projection types. However, the new 
        and original projections must be the same type for the results to be meaningful.

        Raises exceptions if the dataframes have different indexes or different columns.
        &#34;&#34;&#34;

        if not new_projections.index.equals(original_projections.index):
            raise Exception(&#34;The two sets of projections are not for identical lists of variables. Make sure they are both for the same model.&#34;)
        if not new_projections.columns.equals(original_projections.columns):
            raise Exception(&#34;The two sets of projections are not for identical years so differences between them cannot be calculated.&#34;)
        
        return (new_projections - original_projections)

    def __init__(self, stable_manifold: StableManifold) -&gt; None:

        assert stable_manifold is not None
        assert stable_manifold.converged
        self._stable_manifold = stable_manifold
        self._event_year = self.base_year # gets overridden by subclasses.
        self.__validate()

    def __validate(self):
        &#34;&#34;&#34;
        TODO:  Validate the projections: 
        1. check that they are available for the expected projection years.
        2. Check that the base year projections are equal to the base year data values.
        &#34;&#34;&#34;
        pass

    @property
    def stable_manifold(self) -&gt; StableManifold:
        return self._stable_manifold

    @property
    def state_space_form(self) -&gt; StateSpaceForm:
        return self.stable_manifold.ssf

    @property
    def model(self) -&gt; Model:
        return self.state_space_form.model

    @property
    def sym_data(self) -&gt; SymData:
        return self.model.sym_data

    @property
    def parameters(self) -&gt; Parameters:
        return self.model.parameters

    @property
    def configuration(self) -&gt; ModelConfiguration:
        return self.sym_data.configuration

    @property
    def base_year(self) -&gt; int:
        return self.configuration.projection_base_year

    @property
    def end_year(self) -&gt; int:
        return self.configuration.end_year

    @property
    def event_year(self) -&gt; int:
        return self._event_year

    @property
    def projection_years(self) -&gt; list[int]:
        &#34;&#34;&#34;
        Returns the list of years for projections from the event year through to 
        and including the projection end year.
        &#34;&#34;&#34;
        return range(self.event_year, self.end_year+1)

    @property
    def projection_years_count(self) -&gt; list[int]:
        return (self.end_year - self.event_year + 1)

    @property
    def projection_years_column_labels(self) -&gt; list[str]:
        return [str(x) for x in self.projection_years]

    @property
    def preceding_projection_years(self) -&gt; list[int]:
        &#34;&#34;&#34;
        Returns the list of years for projections from the base year through to but
        not including the event year for this baseline projection or simulation layer.
        &#34;&#34;&#34;
        return range(self.base_year, self.event_year)

    @property
    def preceding_projection_years_count(self) -&gt; list[int]:
        return (self.event_year - self.base_year)

    @property
    def preceding_projection_years_column_labels(self) -&gt; list[str]:
        return [str(x) for x in self.preceding_projection_years]

    @property
    def simulation_data_columns(self) -&gt; list[str]:
        &#34;&#34;&#34;
        Returns the list of years (YYYY format) as strings from the event year to the
        end year in the projections.
        &#34;&#34;&#34;
        return [str(x) for x in range(self.event_year, self.configuration.end_year+1)]

    @property
    def projections(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Returns the dataframe of projections for all variables in the model that are part of the 
        4 vectors specified. There still need to be additional variable projected that are computed
        outside of the system to take non-linearity into account (eg long-term interest rates.)
        &#34;&#34;&#34;
        if hasattr(self, &#39;_projections&#39;):
            return self._projections
        raise Exception(f&#34;The projections for all variables are not yet available for this {type(self)}.&#34;)

    @property
    def database_projections(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Returns the dataframe of projections for all variables in the model in forms that are consistent with
        the values contained in the original model database.
        &#34;&#34;&#34;
        if hasattr(self, &#39;_database_projections&#39;):
            return self._database_projections
        raise Exception(f&#34;The database projections for all variables are not yet available for this {type(self)}.&#34;)

    @property
    def publishable_projections(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Returns the dataframe of projections for all variables in the model.
        &#34;&#34;&#34;
        if hasattr(self, &#39;_publishable_projections&#39;):
            return self._publishable_projections
        raise Exception(f&#34;The publishable projections for all variables are not yet available for this {type(self)}.&#34;)

    @property
    def yxr_projections_as_dataframe(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Get yxr variable projection values
        of the projection years as a dataframe.
        &#34;&#34;&#34;
        if hasattr(self, &#39;_yxr_projections&#39;):
            return self._yxr_projections
        raise Exception(f&#34;The period t state variable projections (yxr) are not yet available for this {type(self)}.&#34;)

    @property
    def yxr_projections(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Get yxr variable projection values
        of the projection years.
        &#34;&#34;&#34;
        if hasattr(self, &#39;_yxr_projections&#39;):
            return self._yxr_projections.to_numpy()
        raise Exception(f&#34;The period t state variable projections are not yet available for this {type(self)}.&#34;)

    @property
    def yjr_projections_as_dataframe(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Get yjr variable projection values
        of the projection years as a dataframe.
        &#34;&#34;&#34;
        if hasattr(self, &#39;_yjr_projections&#39;):
            return self._yjr_projections
        raise Exception(f&#34;The period t costate variable projections (yjr) are not yet available for this {type(self)}.&#34;)

    @property
    def yjr_projections(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Get yjr variable projection values
        of the projection years.
        &#34;&#34;&#34;
        if hasattr(self, &#39;_yjr_projections&#39;):
            return self._yjr_projections.to_numpy()
        raise Exception(f&#34;The period t costate variable projections (yjr) are not yet available for this {type(self)}.&#34;)

    @property
    def exz_projections_as_dataframe(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Get exz variable projection values
        of the projection years as a dataframe.
        &#34;&#34;&#34;
        if hasattr(self, &#39;_exz_projections&#39;):
            return self._exz_projections
        raise Exception(f&#34;The period t expected values for t+1 variables projections (exz) are not yet available for this {type(self)}.&#34;)

    @property
    def exz_projections(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Get exz variable projection values
        of the projection years.
        &#34;&#34;&#34;
        if hasattr(self, &#39;_exz_projections&#39;):
            return self._exz_projections.to_numpy()
        raise Exception(f&#34;The period t expected values for t+1 variables projections (exz) are not yet available for this {type(self)}.&#34;)

    @property
    def zel_projections_as_dataframe(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Get zel variable projection values
        of the projection years as a dataframe.
        &#34;&#34;&#34;
        if hasattr(self, &#39;_zel_projections&#39;):
            return self._zel_projections
        raise Exception(f&#34;The period t ZEL projections are not yet available for this {type(self)}.&#34;)

    @property
    def zel_projections(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Get zel variable projection values
        of the projection years.
        &#34;&#34;&#34;
        if hasattr(self, &#39;_zel_projections&#39;):
            return self._zel_projections.to_numpy()
        raise Exception(f&#34;The period t ZEL projections are not yet available for this {type(self)}.&#34;)

    @property
    def z1l_projections_as_dataframe(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Get z1l variable projection values
        of the projection years as a dataframe.
        &#34;&#34;&#34;
        if hasattr(self, &#39;_z1l_projections&#39;):
            return self._z1l_projections
        raise Exception(f&#34;The period t Z1L projections are not yet available for this {type(self)}.&#34;)

    @property
    def z1l_projections(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Get z1l variable projection values
        of the projection years.
        &#34;&#34;&#34;
        if hasattr(self, &#39;_z1l_projections&#39;):
            return self._z1l_projections.to_numpy()
        raise Exception(f&#34;The period t Z1L projections are not yet available for this {type(self)}.&#34;)

    @property
    def exo_projections_as_dataframe(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Get exogenous variable projection values
        of the projection years as a dataframe.
        &#34;&#34;&#34;
        if hasattr(self, &#39;_exo_projections&#39;):
            return self._exo_projections
        raise Exception(f&#34;The exogenous variable projections are not yet available for this {type(self)}.&#34;)

    @property
    def exo_projections(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Get exogenous variable projection values
        of the projection years.
        &#34;&#34;&#34;
        if hasattr(self, &#39;_exo_projections&#39;):
            return self._exo_projections.to_numpy()
        raise Exception(f&#34;The exogenous variable projections are not yet available for this {type(self)}.&#34;)

    def longrate_calculation(self, term: int, rates: pd.DataFrame) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Utility method that returns the compounding long rates given the yearly rates.

        Rates are provided as decimal values so 1% is 0.01.
 
        Arguments:

        term: the number of years of the term of the instrument. 2 for a 2 year bond.

        rates: the projections of the 1 year interest rates, (nominal or real).

        Returns the long rates that can be computed from the one year rates. This series is shorter
        than the series of one year rates because the required data is not available for 
        the last (term-1) observations. It is padded with NaN values in the returned projection.
        &#34;&#34;&#34;
        shortrates = rates.copy()
        name_suffix = str(shortrates.index[0]).split(&#39;(&#39;)[1]
        longrates_columns = shortrates.iloc[:, 0:(len(shortrates.columns)-term+1)].columns
        preceding_year: int = int(shortrates.columns[0])-1
        shortrates = shortrates + 1

        shortrates = shortrates.cumprod(axis=&#39;columns&#39;)
        shortrates.insert(0, str(preceding_year), 1.0)

        longrates: pd.DataFrame = pd.DataFrame(np.power(shortrates.iloc[:, term:].to_numpy() / shortrates.iloc[:, 0:-term:1].to_numpy(), 1/term) - 1.0)
        longrates.columns = longrates_columns
        match str(rates.index[0]).split(&#39;(&#39;)[0]:
            case &#39;INTN&#39;:
                match term:
                    case 2:
                        long_rate_name = &#39;NB02&#39;
                    case 5:
                        long_rate_name = &#39;NB05&#39;
                    case 10:
                        long_rate_name = &#39;NB10&#39;
                    case _:
                        raise Exception(f&#34;Invalid nominal bond term specified: {term}&#34;)
            case &#34;INTR&#34;:
                match term:
                    case 2:
                        long_rate_name = &#39;RB02&#39;
                    case 5:
                        long_rate_name = &#39;RB05&#39;
                    case 10:
                        long_rate_name = &#39;RB10&#39;
                    case _:
                        raise Exception(f&#34;Invalid real bond term specified: {term}&#34;)
            case _:
                raise Exception(f&#34;Invalid variable used to compute bond rates: {str(rates.index[0])}. Use a 1 year interest rate.&#34;)
        longrates.index = [ f&#34;{long_rate_name}({name_suffix}&#34; ]
        return longrates.astype(float)

    @property
    def long_rate_constants(self):
        &#34;&#34;&#34;
        The constant adjustments to long bond rates 
        (real and nominal) in the base projection year 
        to ensure projections equal observed values.
        &#34;&#34;&#34;
        return self._long_rate_constants

    def generate_database_projections(self):
        &#34;&#34;&#34;
        Converts the raw projections into projections that are consistent with the database being used
        by the model. These projections can be spliced on to the original database (as opposed to the
        GDP scaled database) that was loaded with the model used to produce the projections.

        Implements the first parts of the projection conversion logic in datamsymbl.ox.

        Step 1.
        Get a copy of the raw projections.

        Step 2b.
        Divide the projections by YRATR in the projection base year for every variable that has units of:
            gdp
            mmtgdp
            btugdp
            gwhgdp
        This ensures that the resulting values are comparable to the original database aside from scaling by 100.

        # Step 3.
        At this stage the interest rates are expressed as decimals so 0.02 is a 2% interest rate.
        Adjust the interest rate variables using the intcons adjustment, adding the difference between 
        the base-projection year interest rate and the assumed neutral real interest rate to each of the interest 
        rate variables.
        This ensures that the result short interest rates are comparable to the original database, aside from scaling by 100.

        # Step 4.
        Generate long rates from short rates
        This ensures that the long interest rates are derived from the short rates.
         
        # Step 5.
        Adjust long rate projections by adding long rate constants that
        are calculated to ensure that the long rates are equal to the 
        observed values in the base projection year.
        This ensures that the long interest rates are comparable to the original database aside from scaling by 100.

        Step 6.
        Multiply projection values by 100
        This ensures that the projections are scaled in the same way as the original database.

        Step 7.
        Get LGDPR (real GDP level) data in the projection base year for each 
        region and grow over projection years at rate given by &#39;labgrow&#39; parameter.
        Store the LGDPR projections in the publishable projections dataset.

        Saves the result in the _database_projections property.

        These database projections should be associated with the publication_units of measurement
        available from the sym_data variable summary.

        &#34;&#34;&#34;

        # Step 1.
        database_projections: pd.DataFrame = self.projections.copy()

        # Step 2.
        yratr_data: pd.DataFrame = self.database.data.loc[self.database.variables.name.str.startswith(&#34;YRATR(&#34;), str(self.base_year)].copy()
        yratr_data.index = self.sym_data.regions_members
        for variable_name, variable_projection in database_projections.iterrows():
            units: str = str(self.database.variables.loc[variable_name,&#39;units&#39;])
            match units:
                case &#39;gdp&#39; | &#39;btugdp&#39; | &#39;mmtgdp&#39; | &#39;gwhgdp&#39;:
                    variable_region: str = str(self.database.variables.loc[variable_name, &#39;region&#39;])
                    factor: float = yratr_data.loc[variable_region]
                    database_projections.loc[[variable_name], :] /= factor

        # Step 3.
        # Make the adjustment for the neutral real interest rate.
        for prefix in CONSTANTS.INTEREST_RATE_PREFIXES:
            variable_names = self.database.variables.loc[self.database.variables.name.str.startswith(f&#34;{prefix}(&#34;), &#39;name&#39;]
            for variable_name in variable_names:
                database_projections.loc[[variable_name], :] += (float(self.database.data.loc[variable_name, str(self.base_year)] - self.configuration.neutral_real_interest_rate))

        # Step 4.
        # Calculate the long rates.
        real_interest_rates: pd.DataFrame = database_projections.loc[database_projections.index.str.startswith(&#34;INTR(&#34;), str(self.base_year):].copy()
        for variable_name in real_interest_rates.index:
            rb10: pd.DataFrame = self.longrate_calculation(term=10, rates=real_interest_rates.loc[[variable_name], :])
            database_projections.loc[[str(rb10.index[0])], :] = rb10
        nominal_interest_rates: pd.DataFrame = database_projections.loc[database_projections.index.str.startswith(&#34;INTN(&#34;), str(self.base_year):].copy()
        for variable_name in nominal_interest_rates.index:
            nb02: pd.DataFrame = self.longrate_calculation(term=2, rates=nominal_interest_rates.loc[[variable_name], :])
            database_projections.loc[[str(nb02.index[0])], :] = nb02
            nb05: pd.DataFrame = self.longrate_calculation(term=5, rates=nominal_interest_rates.loc[[variable_name], :])
            database_projections.loc[[str(nb05.index[0])], :] = nb05
            nb10: pd.DataFrame = self.longrate_calculation(term=10, rates=nominal_interest_rates.loc[[variable_name], :])
            database_projections.loc[[str(nb10.index[0])], :] = nb10

        # Step 5.
        # Determine the constants to add to the long rates to match base projection year observed and projected values.
        self._long_rate_constants: pd.DataFrame = None
        for prefix in CONSTANTS.BOND_RATE_PREFIXES:
            observed_values: pd.DataFrame = self.database.data.loc[self.database.variables.name.str.startswith(f&#34;{prefix}(&#34;), [str(self.base_year)]].copy()
            projected_values: pd.DataFrame = database_projections.loc[database_projections.index.str.startswith(f&#34;{prefix}(&#34;), [
                str(self.base_year)]].copy()
            constants: pd.DataFrame = observed_values - projected_values
            constants.columns = [str(self.base_year)]
            constants.index = observed_values.index
            if self._long_rate_constants is None:
                self._long_rate_constants = constants
            else:
                self._long_rate_constants = pd.concat([self._long_rate_constants, constants], axis=0)

        # Add the long rate constants to the long rate projections to line the long rate projections
        # up with observed data in the base projection year.
        for variable_name in self.long_rate_constants.index:
            database_projections.loc[[variable_name], :] += self.long_rate_constants.loc[variable_name, str(self.base_year)]

        # Step 6.
        database_projections *= 100.0

        # Step 7.
        rows_containing_LGDPR_data = self.database.variables.name.str.startswith(&#34;LGDPR(&#34;)
        lgdpr_data: pd.DataFrame = self.database.data.loc[rows_containing_LGDPR_data, [str(self.base_year)]].copy() / 100
        us_longrun_effective_labour_productivity_index: pd.DataFrame = self.model.effective_labour_productivity.us_longrun_effective_labour_index.loc[:,self.configuration.base_and_projection_years_column_labels]
        lgdpr_longrun_projections: pd.DataFrame = pd.DataFrame(lgdpr_data.values * us_longrun_effective_labour_productivity_index.values)
        lgdpr_longrun_projections.columns = self.configuration.base_and_projection_years_column_labels
        lgdpr_longrun_projections.index = lgdpr_data.index # Index with the LGDPR full variable names
        database_projections.loc[rows_containing_LGDPR_data, :] = lgdpr_longrun_projections.copy()

        # Splice on the actual data from the model database
        for column in self.model.database.data.columns[::-1]:
            if not (column in database_projections.columns):
                if int(column) &lt; int(database_projections.columns[0]):
                    database_projections.insert(0, column, self.model.database.data.loc[:,column], True)
                else:
                    break

        # Save the results for use later.
        self._database_projections = database_projections.astype(float)

    def generate_publishable_projections(self):
        &#34;&#34;&#34;

        Uses the real GDP trend growth projections to adjust 
        the projections of all variables with units equal to 
        &#39;usgdp&#39; or &#39;gdp&#39;.

        Implements the real GDP scaling part of the projection conversion logic in datamsymbl.ox.

        Step 1.
        For all projections with units equal to usgdp, multiply the projection 
        by the US LGDPR projection computed in step 4 when producing the database projections.

        Step 2.
        For all projections with units equal to &#39;gdp&#39;, multiply the projection by the associated
        region&#39;s LGDPR projection computed in step 4 when producing the database projections.

        These publishable projections should be associated with the publication_units of measurement
        available from the sym_data variable summary.

        Saves the result in the _publishable_projections property.
        &#34;&#34;&#34;

        publication_projections: pd.DataFrame = self.database_projections.copy()

        # Real GDP scaling
        lgdpr_database_projections: pd.DataFrame = self.database_projections.loc[self.database_projections.index.str.startswith(&#34;LGDPR(&#34;), :].copy()
        lgdpr_database_projections.index = self.model.sym_data.regions_members
        for variable_name in publication_projections.index:
            variable_units: str = str(self.database.variables.loc[variable_name,&#39;units&#39;])
            match variable_units:
                case &#39;usgdp&#39; | &#39;mmtusgdp&#39; | &#39;btuusgdp&#39;:
                    publication_projections.loc[[variable_name], :] *= lgdpr_database_projections.loc[[CONSTANTS.USA_REGION_CODE],:].values
                case &#39;gdp&#39; | &#39;mmtgdp&#39; | &#39;btugdp&#39; | &#39;gwhgdp&#39;:
                    variable_region: str = str(self.database.variables.loc[variable_name, &#39;region&#39;])
                    publication_projections.loc[[variable_name], :] *= lgdpr_database_projections.loc[[variable_region],:].values

        # Save the results for use later.
        self._publishable_projections = publication_projections.astype(float)

    @property
    def graphable_projections(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Produces publishable projections in a format suitable 
        for loading into graphing systems such as R.

        The publishable projections are transposed so there is 
        a column for each variable and a row for each year.
        &#34;&#34;&#34;
        result: pd.DataFrame = self.publishable_projections.copy().transpose()
        result.index = self.model.configuration.all_years
        return result</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gcubed.projections.base_projections.BaseProjections"><code class="flex name class">
<span>class <span class="ident">BaseProjections</span></span>
<span>(</span><span>stable_manifold: <a title="gcubed.stable_manifold.StableManifold" href="../stable_manifold.html#gcubed.stable_manifold.StableManifold">StableManifold</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for simulations and for Baseline Projections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseProjections(Base):
    &#34;&#34;&#34;
    Base class for simulations and for Baseline Projections.
    &#34;&#34;&#34;

    @classmethod
    def get_deviations_between_projections(cls, new_projections:pd.DataFrame, original_projections:pd.DataFrame) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Arguments:

        new_projections: A dataframe of projections

        original_projections: A second dataframe of projections

        Produce a dataframe of differences between two projections (new_projections - original_projections).

        Note that this can be used for raw, database, publishable and graphable projection types. However, the new 
        and original projections must be the same type for the results to be meaningful.

        Raises exceptions if the dataframes have different indexes or different columns.
        &#34;&#34;&#34;

        if not new_projections.index.equals(original_projections.index):
            raise Exception(&#34;The two sets of projections are not for identical lists of variables. Make sure they are both for the same model.&#34;)
        if not new_projections.columns.equals(original_projections.columns):
            raise Exception(&#34;The two sets of projections are not for identical years so differences between them cannot be calculated.&#34;)
        
        return (new_projections - original_projections)

    def __init__(self, stable_manifold: StableManifold) -&gt; None:

        assert stable_manifold is not None
        assert stable_manifold.converged
        self._stable_manifold = stable_manifold
        self._event_year = self.base_year # gets overridden by subclasses.
        self.__validate()

    def __validate(self):
        &#34;&#34;&#34;
        TODO:  Validate the projections: 
        1. check that they are available for the expected projection years.
        2. Check that the base year projections are equal to the base year data values.
        &#34;&#34;&#34;
        pass

    @property
    def stable_manifold(self) -&gt; StableManifold:
        return self._stable_manifold

    @property
    def state_space_form(self) -&gt; StateSpaceForm:
        return self.stable_manifold.ssf

    @property
    def model(self) -&gt; Model:
        return self.state_space_form.model

    @property
    def sym_data(self) -&gt; SymData:
        return self.model.sym_data

    @property
    def parameters(self) -&gt; Parameters:
        return self.model.parameters

    @property
    def configuration(self) -&gt; ModelConfiguration:
        return self.sym_data.configuration

    @property
    def base_year(self) -&gt; int:
        return self.configuration.projection_base_year

    @property
    def end_year(self) -&gt; int:
        return self.configuration.end_year

    @property
    def event_year(self) -&gt; int:
        return self._event_year

    @property
    def projection_years(self) -&gt; list[int]:
        &#34;&#34;&#34;
        Returns the list of years for projections from the event year through to 
        and including the projection end year.
        &#34;&#34;&#34;
        return range(self.event_year, self.end_year+1)

    @property
    def projection_years_count(self) -&gt; list[int]:
        return (self.end_year - self.event_year + 1)

    @property
    def projection_years_column_labels(self) -&gt; list[str]:
        return [str(x) for x in self.projection_years]

    @property
    def preceding_projection_years(self) -&gt; list[int]:
        &#34;&#34;&#34;
        Returns the list of years for projections from the base year through to but
        not including the event year for this baseline projection or simulation layer.
        &#34;&#34;&#34;
        return range(self.base_year, self.event_year)

    @property
    def preceding_projection_years_count(self) -&gt; list[int]:
        return (self.event_year - self.base_year)

    @property
    def preceding_projection_years_column_labels(self) -&gt; list[str]:
        return [str(x) for x in self.preceding_projection_years]

    @property
    def simulation_data_columns(self) -&gt; list[str]:
        &#34;&#34;&#34;
        Returns the list of years (YYYY format) as strings from the event year to the
        end year in the projections.
        &#34;&#34;&#34;
        return [str(x) for x in range(self.event_year, self.configuration.end_year+1)]

    @property
    def projections(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Returns the dataframe of projections for all variables in the model that are part of the 
        4 vectors specified. There still need to be additional variable projected that are computed
        outside of the system to take non-linearity into account (eg long-term interest rates.)
        &#34;&#34;&#34;
        if hasattr(self, &#39;_projections&#39;):
            return self._projections
        raise Exception(f&#34;The projections for all variables are not yet available for this {type(self)}.&#34;)

    @property
    def database_projections(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Returns the dataframe of projections for all variables in the model in forms that are consistent with
        the values contained in the original model database.
        &#34;&#34;&#34;
        if hasattr(self, &#39;_database_projections&#39;):
            return self._database_projections
        raise Exception(f&#34;The database projections for all variables are not yet available for this {type(self)}.&#34;)

    @property
    def publishable_projections(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Returns the dataframe of projections for all variables in the model.
        &#34;&#34;&#34;
        if hasattr(self, &#39;_publishable_projections&#39;):
            return self._publishable_projections
        raise Exception(f&#34;The publishable projections for all variables are not yet available for this {type(self)}.&#34;)

    @property
    def yxr_projections_as_dataframe(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Get yxr variable projection values
        of the projection years as a dataframe.
        &#34;&#34;&#34;
        if hasattr(self, &#39;_yxr_projections&#39;):
            return self._yxr_projections
        raise Exception(f&#34;The period t state variable projections (yxr) are not yet available for this {type(self)}.&#34;)

    @property
    def yxr_projections(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Get yxr variable projection values
        of the projection years.
        &#34;&#34;&#34;
        if hasattr(self, &#39;_yxr_projections&#39;):
            return self._yxr_projections.to_numpy()
        raise Exception(f&#34;The period t state variable projections are not yet available for this {type(self)}.&#34;)

    @property
    def yjr_projections_as_dataframe(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Get yjr variable projection values
        of the projection years as a dataframe.
        &#34;&#34;&#34;
        if hasattr(self, &#39;_yjr_projections&#39;):
            return self._yjr_projections
        raise Exception(f&#34;The period t costate variable projections (yjr) are not yet available for this {type(self)}.&#34;)

    @property
    def yjr_projections(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Get yjr variable projection values
        of the projection years.
        &#34;&#34;&#34;
        if hasattr(self, &#39;_yjr_projections&#39;):
            return self._yjr_projections.to_numpy()
        raise Exception(f&#34;The period t costate variable projections (yjr) are not yet available for this {type(self)}.&#34;)

    @property
    def exz_projections_as_dataframe(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Get exz variable projection values
        of the projection years as a dataframe.
        &#34;&#34;&#34;
        if hasattr(self, &#39;_exz_projections&#39;):
            return self._exz_projections
        raise Exception(f&#34;The period t expected values for t+1 variables projections (exz) are not yet available for this {type(self)}.&#34;)

    @property
    def exz_projections(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Get exz variable projection values
        of the projection years.
        &#34;&#34;&#34;
        if hasattr(self, &#39;_exz_projections&#39;):
            return self._exz_projections.to_numpy()
        raise Exception(f&#34;The period t expected values for t+1 variables projections (exz) are not yet available for this {type(self)}.&#34;)

    @property
    def zel_projections_as_dataframe(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Get zel variable projection values
        of the projection years as a dataframe.
        &#34;&#34;&#34;
        if hasattr(self, &#39;_zel_projections&#39;):
            return self._zel_projections
        raise Exception(f&#34;The period t ZEL projections are not yet available for this {type(self)}.&#34;)

    @property
    def zel_projections(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Get zel variable projection values
        of the projection years.
        &#34;&#34;&#34;
        if hasattr(self, &#39;_zel_projections&#39;):
            return self._zel_projections.to_numpy()
        raise Exception(f&#34;The period t ZEL projections are not yet available for this {type(self)}.&#34;)

    @property
    def z1l_projections_as_dataframe(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Get z1l variable projection values
        of the projection years as a dataframe.
        &#34;&#34;&#34;
        if hasattr(self, &#39;_z1l_projections&#39;):
            return self._z1l_projections
        raise Exception(f&#34;The period t Z1L projections are not yet available for this {type(self)}.&#34;)

    @property
    def z1l_projections(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Get z1l variable projection values
        of the projection years.
        &#34;&#34;&#34;
        if hasattr(self, &#39;_z1l_projections&#39;):
            return self._z1l_projections.to_numpy()
        raise Exception(f&#34;The period t Z1L projections are not yet available for this {type(self)}.&#34;)

    @property
    def exo_projections_as_dataframe(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Get exogenous variable projection values
        of the projection years as a dataframe.
        &#34;&#34;&#34;
        if hasattr(self, &#39;_exo_projections&#39;):
            return self._exo_projections
        raise Exception(f&#34;The exogenous variable projections are not yet available for this {type(self)}.&#34;)

    @property
    def exo_projections(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Get exogenous variable projection values
        of the projection years.
        &#34;&#34;&#34;
        if hasattr(self, &#39;_exo_projections&#39;):
            return self._exo_projections.to_numpy()
        raise Exception(f&#34;The exogenous variable projections are not yet available for this {type(self)}.&#34;)

    def longrate_calculation(self, term: int, rates: pd.DataFrame) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Utility method that returns the compounding long rates given the yearly rates.

        Rates are provided as decimal values so 1% is 0.01.
 
        Arguments:

        term: the number of years of the term of the instrument. 2 for a 2 year bond.

        rates: the projections of the 1 year interest rates, (nominal or real).

        Returns the long rates that can be computed from the one year rates. This series is shorter
        than the series of one year rates because the required data is not available for 
        the last (term-1) observations. It is padded with NaN values in the returned projection.
        &#34;&#34;&#34;
        shortrates = rates.copy()
        name_suffix = str(shortrates.index[0]).split(&#39;(&#39;)[1]
        longrates_columns = shortrates.iloc[:, 0:(len(shortrates.columns)-term+1)].columns
        preceding_year: int = int(shortrates.columns[0])-1
        shortrates = shortrates + 1

        shortrates = shortrates.cumprod(axis=&#39;columns&#39;)
        shortrates.insert(0, str(preceding_year), 1.0)

        longrates: pd.DataFrame = pd.DataFrame(np.power(shortrates.iloc[:, term:].to_numpy() / shortrates.iloc[:, 0:-term:1].to_numpy(), 1/term) - 1.0)
        longrates.columns = longrates_columns
        match str(rates.index[0]).split(&#39;(&#39;)[0]:
            case &#39;INTN&#39;:
                match term:
                    case 2:
                        long_rate_name = &#39;NB02&#39;
                    case 5:
                        long_rate_name = &#39;NB05&#39;
                    case 10:
                        long_rate_name = &#39;NB10&#39;
                    case _:
                        raise Exception(f&#34;Invalid nominal bond term specified: {term}&#34;)
            case &#34;INTR&#34;:
                match term:
                    case 2:
                        long_rate_name = &#39;RB02&#39;
                    case 5:
                        long_rate_name = &#39;RB05&#39;
                    case 10:
                        long_rate_name = &#39;RB10&#39;
                    case _:
                        raise Exception(f&#34;Invalid real bond term specified: {term}&#34;)
            case _:
                raise Exception(f&#34;Invalid variable used to compute bond rates: {str(rates.index[0])}. Use a 1 year interest rate.&#34;)
        longrates.index = [ f&#34;{long_rate_name}({name_suffix}&#34; ]
        return longrates.astype(float)

    @property
    def long_rate_constants(self):
        &#34;&#34;&#34;
        The constant adjustments to long bond rates 
        (real and nominal) in the base projection year 
        to ensure projections equal observed values.
        &#34;&#34;&#34;
        return self._long_rate_constants

    def generate_database_projections(self):
        &#34;&#34;&#34;
        Converts the raw projections into projections that are consistent with the database being used
        by the model. These projections can be spliced on to the original database (as opposed to the
        GDP scaled database) that was loaded with the model used to produce the projections.

        Implements the first parts of the projection conversion logic in datamsymbl.ox.

        Step 1.
        Get a copy of the raw projections.

        Step 2b.
        Divide the projections by YRATR in the projection base year for every variable that has units of:
            gdp
            mmtgdp
            btugdp
            gwhgdp
        This ensures that the resulting values are comparable to the original database aside from scaling by 100.

        # Step 3.
        At this stage the interest rates are expressed as decimals so 0.02 is a 2% interest rate.
        Adjust the interest rate variables using the intcons adjustment, adding the difference between 
        the base-projection year interest rate and the assumed neutral real interest rate to each of the interest 
        rate variables.
        This ensures that the result short interest rates are comparable to the original database, aside from scaling by 100.

        # Step 4.
        Generate long rates from short rates
        This ensures that the long interest rates are derived from the short rates.
         
        # Step 5.
        Adjust long rate projections by adding long rate constants that
        are calculated to ensure that the long rates are equal to the 
        observed values in the base projection year.
        This ensures that the long interest rates are comparable to the original database aside from scaling by 100.

        Step 6.
        Multiply projection values by 100
        This ensures that the projections are scaled in the same way as the original database.

        Step 7.
        Get LGDPR (real GDP level) data in the projection base year for each 
        region and grow over projection years at rate given by &#39;labgrow&#39; parameter.
        Store the LGDPR projections in the publishable projections dataset.

        Saves the result in the _database_projections property.

        These database projections should be associated with the publication_units of measurement
        available from the sym_data variable summary.

        &#34;&#34;&#34;

        # Step 1.
        database_projections: pd.DataFrame = self.projections.copy()

        # Step 2.
        yratr_data: pd.DataFrame = self.database.data.loc[self.database.variables.name.str.startswith(&#34;YRATR(&#34;), str(self.base_year)].copy()
        yratr_data.index = self.sym_data.regions_members
        for variable_name, variable_projection in database_projections.iterrows():
            units: str = str(self.database.variables.loc[variable_name,&#39;units&#39;])
            match units:
                case &#39;gdp&#39; | &#39;btugdp&#39; | &#39;mmtgdp&#39; | &#39;gwhgdp&#39;:
                    variable_region: str = str(self.database.variables.loc[variable_name, &#39;region&#39;])
                    factor: float = yratr_data.loc[variable_region]
                    database_projections.loc[[variable_name], :] /= factor

        # Step 3.
        # Make the adjustment for the neutral real interest rate.
        for prefix in CONSTANTS.INTEREST_RATE_PREFIXES:
            variable_names = self.database.variables.loc[self.database.variables.name.str.startswith(f&#34;{prefix}(&#34;), &#39;name&#39;]
            for variable_name in variable_names:
                database_projections.loc[[variable_name], :] += (float(self.database.data.loc[variable_name, str(self.base_year)] - self.configuration.neutral_real_interest_rate))

        # Step 4.
        # Calculate the long rates.
        real_interest_rates: pd.DataFrame = database_projections.loc[database_projections.index.str.startswith(&#34;INTR(&#34;), str(self.base_year):].copy()
        for variable_name in real_interest_rates.index:
            rb10: pd.DataFrame = self.longrate_calculation(term=10, rates=real_interest_rates.loc[[variable_name], :])
            database_projections.loc[[str(rb10.index[0])], :] = rb10
        nominal_interest_rates: pd.DataFrame = database_projections.loc[database_projections.index.str.startswith(&#34;INTN(&#34;), str(self.base_year):].copy()
        for variable_name in nominal_interest_rates.index:
            nb02: pd.DataFrame = self.longrate_calculation(term=2, rates=nominal_interest_rates.loc[[variable_name], :])
            database_projections.loc[[str(nb02.index[0])], :] = nb02
            nb05: pd.DataFrame = self.longrate_calculation(term=5, rates=nominal_interest_rates.loc[[variable_name], :])
            database_projections.loc[[str(nb05.index[0])], :] = nb05
            nb10: pd.DataFrame = self.longrate_calculation(term=10, rates=nominal_interest_rates.loc[[variable_name], :])
            database_projections.loc[[str(nb10.index[0])], :] = nb10

        # Step 5.
        # Determine the constants to add to the long rates to match base projection year observed and projected values.
        self._long_rate_constants: pd.DataFrame = None
        for prefix in CONSTANTS.BOND_RATE_PREFIXES:
            observed_values: pd.DataFrame = self.database.data.loc[self.database.variables.name.str.startswith(f&#34;{prefix}(&#34;), [str(self.base_year)]].copy()
            projected_values: pd.DataFrame = database_projections.loc[database_projections.index.str.startswith(f&#34;{prefix}(&#34;), [
                str(self.base_year)]].copy()
            constants: pd.DataFrame = observed_values - projected_values
            constants.columns = [str(self.base_year)]
            constants.index = observed_values.index
            if self._long_rate_constants is None:
                self._long_rate_constants = constants
            else:
                self._long_rate_constants = pd.concat([self._long_rate_constants, constants], axis=0)

        # Add the long rate constants to the long rate projections to line the long rate projections
        # up with observed data in the base projection year.
        for variable_name in self.long_rate_constants.index:
            database_projections.loc[[variable_name], :] += self.long_rate_constants.loc[variable_name, str(self.base_year)]

        # Step 6.
        database_projections *= 100.0

        # Step 7.
        rows_containing_LGDPR_data = self.database.variables.name.str.startswith(&#34;LGDPR(&#34;)
        lgdpr_data: pd.DataFrame = self.database.data.loc[rows_containing_LGDPR_data, [str(self.base_year)]].copy() / 100
        us_longrun_effective_labour_productivity_index: pd.DataFrame = self.model.effective_labour_productivity.us_longrun_effective_labour_index.loc[:,self.configuration.base_and_projection_years_column_labels]
        lgdpr_longrun_projections: pd.DataFrame = pd.DataFrame(lgdpr_data.values * us_longrun_effective_labour_productivity_index.values)
        lgdpr_longrun_projections.columns = self.configuration.base_and_projection_years_column_labels
        lgdpr_longrun_projections.index = lgdpr_data.index # Index with the LGDPR full variable names
        database_projections.loc[rows_containing_LGDPR_data, :] = lgdpr_longrun_projections.copy()

        # Splice on the actual data from the model database
        for column in self.model.database.data.columns[::-1]:
            if not (column in database_projections.columns):
                if int(column) &lt; int(database_projections.columns[0]):
                    database_projections.insert(0, column, self.model.database.data.loc[:,column], True)
                else:
                    break

        # Save the results for use later.
        self._database_projections = database_projections.astype(float)

    def generate_publishable_projections(self):
        &#34;&#34;&#34;

        Uses the real GDP trend growth projections to adjust 
        the projections of all variables with units equal to 
        &#39;usgdp&#39; or &#39;gdp&#39;.

        Implements the real GDP scaling part of the projection conversion logic in datamsymbl.ox.

        Step 1.
        For all projections with units equal to usgdp, multiply the projection 
        by the US LGDPR projection computed in step 4 when producing the database projections.

        Step 2.
        For all projections with units equal to &#39;gdp&#39;, multiply the projection by the associated
        region&#39;s LGDPR projection computed in step 4 when producing the database projections.

        These publishable projections should be associated with the publication_units of measurement
        available from the sym_data variable summary.

        Saves the result in the _publishable_projections property.
        &#34;&#34;&#34;

        publication_projections: pd.DataFrame = self.database_projections.copy()

        # Real GDP scaling
        lgdpr_database_projections: pd.DataFrame = self.database_projections.loc[self.database_projections.index.str.startswith(&#34;LGDPR(&#34;), :].copy()
        lgdpr_database_projections.index = self.model.sym_data.regions_members
        for variable_name in publication_projections.index:
            variable_units: str = str(self.database.variables.loc[variable_name,&#39;units&#39;])
            match variable_units:
                case &#39;usgdp&#39; | &#39;mmtusgdp&#39; | &#39;btuusgdp&#39;:
                    publication_projections.loc[[variable_name], :] *= lgdpr_database_projections.loc[[CONSTANTS.USA_REGION_CODE],:].values
                case &#39;gdp&#39; | &#39;mmtgdp&#39; | &#39;btugdp&#39; | &#39;gwhgdp&#39;:
                    variable_region: str = str(self.database.variables.loc[variable_name, &#39;region&#39;])
                    publication_projections.loc[[variable_name], :] *= lgdpr_database_projections.loc[[variable_region],:].values

        # Save the results for use later.
        self._publishable_projections = publication_projections.astype(float)

    @property
    def graphable_projections(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Produces publishable projections in a format suitable 
        for loading into graphing systems such as R.

        The publishable projections are transposed so there is 
        a column for each variable and a row for each year.
        &#34;&#34;&#34;
        result: pd.DataFrame = self.publishable_projections.copy().transpose()
        result.index = self.model.configuration.all_years
        return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gcubed.base.Base" href="../base.html#gcubed.base.Base">Base</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="gcubed.projections.baseline_projections.BaselineProjections" href="baseline_projections.html#gcubed.projections.baseline_projections.BaselineProjections">BaselineProjections</a></li>
<li><a title="gcubed.projections.simulation_layer.SimulationLayer" href="simulation_layer.html#gcubed.projections.simulation_layer.SimulationLayer">SimulationLayer</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="gcubed.projections.base_projections.BaseProjections.get_deviations_between_projections"><code class="name flex">
<span>def <span class="ident">get_deviations_between_projections</span></span>(<span>new_projections: pandas.core.frame.DataFrame, original_projections: pandas.core.frame.DataFrame) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Arguments:</p>
<p>new_projections: A dataframe of projections</p>
<p>original_projections: A second dataframe of projections</p>
<p>Produce a dataframe of differences between two projections (new_projections - original_projections).</p>
<p>Note that this can be used for raw, database, publishable and graphable projection types. However, the new
and original projections must be the same type for the results to be meaningful.</p>
<p>Raises exceptions if the dataframes have different indexes or different columns.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_deviations_between_projections(cls, new_projections:pd.DataFrame, original_projections:pd.DataFrame) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Arguments:

    new_projections: A dataframe of projections

    original_projections: A second dataframe of projections

    Produce a dataframe of differences between two projections (new_projections - original_projections).

    Note that this can be used for raw, database, publishable and graphable projection types. However, the new 
    and original projections must be the same type for the results to be meaningful.

    Raises exceptions if the dataframes have different indexes or different columns.
    &#34;&#34;&#34;

    if not new_projections.index.equals(original_projections.index):
        raise Exception(&#34;The two sets of projections are not for identical lists of variables. Make sure they are both for the same model.&#34;)
    if not new_projections.columns.equals(original_projections.columns):
        raise Exception(&#34;The two sets of projections are not for identical years so differences between them cannot be calculated.&#34;)
    
    return (new_projections - original_projections)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="gcubed.projections.base_projections.BaseProjections.base_year"><code class="name">var <span class="ident">base_year</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def base_year(self) -&gt; int:
    return self.configuration.projection_base_year</code></pre>
</details>
</dd>
<dt id="gcubed.projections.base_projections.BaseProjections.configuration"><code class="name">var <span class="ident">configuration</span> : <a title="gcubed.model_configuration.ModelConfiguration" href="../model_configuration.html#gcubed.model_configuration.ModelConfiguration">ModelConfiguration</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def configuration(self) -&gt; ModelConfiguration:
    return self.sym_data.configuration</code></pre>
</details>
</dd>
<dt id="gcubed.projections.base_projections.BaseProjections.database_projections"><code class="name">var <span class="ident">database_projections</span> : pandas.core.frame.DataFrame</code></dt>
<dd>
<div class="desc"><p>Returns the dataframe of projections for all variables in the model in forms that are consistent with
the values contained in the original model database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def database_projections(self) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Returns the dataframe of projections for all variables in the model in forms that are consistent with
    the values contained in the original model database.
    &#34;&#34;&#34;
    if hasattr(self, &#39;_database_projections&#39;):
        return self._database_projections
    raise Exception(f&#34;The database projections for all variables are not yet available for this {type(self)}.&#34;)</code></pre>
</details>
</dd>
<dt id="gcubed.projections.base_projections.BaseProjections.end_year"><code class="name">var <span class="ident">end_year</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def end_year(self) -&gt; int:
    return self.configuration.end_year</code></pre>
</details>
</dd>
<dt id="gcubed.projections.base_projections.BaseProjections.event_year"><code class="name">var <span class="ident">event_year</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def event_year(self) -&gt; int:
    return self._event_year</code></pre>
</details>
</dd>
<dt id="gcubed.projections.base_projections.BaseProjections.exo_projections"><code class="name">var <span class="ident">exo_projections</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Get exogenous variable projection values
of the projection years.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def exo_projections(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Get exogenous variable projection values
    of the projection years.
    &#34;&#34;&#34;
    if hasattr(self, &#39;_exo_projections&#39;):
        return self._exo_projections.to_numpy()
    raise Exception(f&#34;The exogenous variable projections are not yet available for this {type(self)}.&#34;)</code></pre>
</details>
</dd>
<dt id="gcubed.projections.base_projections.BaseProjections.exo_projections_as_dataframe"><code class="name">var <span class="ident">exo_projections_as_dataframe</span> : pandas.core.frame.DataFrame</code></dt>
<dd>
<div class="desc"><p>Get exogenous variable projection values
of the projection years as a dataframe.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def exo_projections_as_dataframe(self) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Get exogenous variable projection values
    of the projection years as a dataframe.
    &#34;&#34;&#34;
    if hasattr(self, &#39;_exo_projections&#39;):
        return self._exo_projections
    raise Exception(f&#34;The exogenous variable projections are not yet available for this {type(self)}.&#34;)</code></pre>
</details>
</dd>
<dt id="gcubed.projections.base_projections.BaseProjections.exz_projections"><code class="name">var <span class="ident">exz_projections</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Get exz variable projection values
of the projection years.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def exz_projections(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Get exz variable projection values
    of the projection years.
    &#34;&#34;&#34;
    if hasattr(self, &#39;_exz_projections&#39;):
        return self._exz_projections.to_numpy()
    raise Exception(f&#34;The period t expected values for t+1 variables projections (exz) are not yet available for this {type(self)}.&#34;)</code></pre>
</details>
</dd>
<dt id="gcubed.projections.base_projections.BaseProjections.exz_projections_as_dataframe"><code class="name">var <span class="ident">exz_projections_as_dataframe</span> : pandas.core.frame.DataFrame</code></dt>
<dd>
<div class="desc"><p>Get exz variable projection values
of the projection years as a dataframe.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def exz_projections_as_dataframe(self) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Get exz variable projection values
    of the projection years as a dataframe.
    &#34;&#34;&#34;
    if hasattr(self, &#39;_exz_projections&#39;):
        return self._exz_projections
    raise Exception(f&#34;The period t expected values for t+1 variables projections (exz) are not yet available for this {type(self)}.&#34;)</code></pre>
</details>
</dd>
<dt id="gcubed.projections.base_projections.BaseProjections.graphable_projections"><code class="name">var <span class="ident">graphable_projections</span> : pandas.core.frame.DataFrame</code></dt>
<dd>
<div class="desc"><p>Produces publishable projections in a format suitable
for loading into graphing systems such as R.</p>
<p>The publishable projections are transposed so there is
a column for each variable and a row for each year.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def graphable_projections(self) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Produces publishable projections in a format suitable 
    for loading into graphing systems such as R.

    The publishable projections are transposed so there is 
    a column for each variable and a row for each year.
    &#34;&#34;&#34;
    result: pd.DataFrame = self.publishable_projections.copy().transpose()
    result.index = self.model.configuration.all_years
    return result</code></pre>
</details>
</dd>
<dt id="gcubed.projections.base_projections.BaseProjections.long_rate_constants"><code class="name">var <span class="ident">long_rate_constants</span></code></dt>
<dd>
<div class="desc"><p>The constant adjustments to long bond rates
(real and nominal) in the base projection year
to ensure projections equal observed values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def long_rate_constants(self):
    &#34;&#34;&#34;
    The constant adjustments to long bond rates 
    (real and nominal) in the base projection year 
    to ensure projections equal observed values.
    &#34;&#34;&#34;
    return self._long_rate_constants</code></pre>
</details>
</dd>
<dt id="gcubed.projections.base_projections.BaseProjections.model"><code class="name">var <span class="ident">model</span> : <a title="gcubed.model.Model" href="../model.html#gcubed.model.Model">Model</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def model(self) -&gt; Model:
    return self.state_space_form.model</code></pre>
</details>
</dd>
<dt id="gcubed.projections.base_projections.BaseProjections.parameters"><code class="name">var <span class="ident">parameters</span> : <a title="gcubed.model_parameters.parameters.Parameters" href="../model_parameters/parameters.html#gcubed.model_parameters.parameters.Parameters">Parameters</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def parameters(self) -&gt; Parameters:
    return self.model.parameters</code></pre>
</details>
</dd>
<dt id="gcubed.projections.base_projections.BaseProjections.preceding_projection_years"><code class="name">var <span class="ident">preceding_projection_years</span> : list[int]</code></dt>
<dd>
<div class="desc"><p>Returns the list of years for projections from the base year through to but
not including the event year for this baseline projection or simulation layer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def preceding_projection_years(self) -&gt; list[int]:
    &#34;&#34;&#34;
    Returns the list of years for projections from the base year through to but
    not including the event year for this baseline projection or simulation layer.
    &#34;&#34;&#34;
    return range(self.base_year, self.event_year)</code></pre>
</details>
</dd>
<dt id="gcubed.projections.base_projections.BaseProjections.preceding_projection_years_column_labels"><code class="name">var <span class="ident">preceding_projection_years_column_labels</span> : list[str]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def preceding_projection_years_column_labels(self) -&gt; list[str]:
    return [str(x) for x in self.preceding_projection_years]</code></pre>
</details>
</dd>
<dt id="gcubed.projections.base_projections.BaseProjections.preceding_projection_years_count"><code class="name">var <span class="ident">preceding_projection_years_count</span> : list[int]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def preceding_projection_years_count(self) -&gt; list[int]:
    return (self.event_year - self.base_year)</code></pre>
</details>
</dd>
<dt id="gcubed.projections.base_projections.BaseProjections.projection_years"><code class="name">var <span class="ident">projection_years</span> : list[int]</code></dt>
<dd>
<div class="desc"><p>Returns the list of years for projections from the event year through to
and including the projection end year.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def projection_years(self) -&gt; list[int]:
    &#34;&#34;&#34;
    Returns the list of years for projections from the event year through to 
    and including the projection end year.
    &#34;&#34;&#34;
    return range(self.event_year, self.end_year+1)</code></pre>
</details>
</dd>
<dt id="gcubed.projections.base_projections.BaseProjections.projection_years_column_labels"><code class="name">var <span class="ident">projection_years_column_labels</span> : list[str]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def projection_years_column_labels(self) -&gt; list[str]:
    return [str(x) for x in self.projection_years]</code></pre>
</details>
</dd>
<dt id="gcubed.projections.base_projections.BaseProjections.projection_years_count"><code class="name">var <span class="ident">projection_years_count</span> : list[int]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def projection_years_count(self) -&gt; list[int]:
    return (self.end_year - self.event_year + 1)</code></pre>
</details>
</dd>
<dt id="gcubed.projections.base_projections.BaseProjections.projections"><code class="name">var <span class="ident">projections</span> : pandas.core.frame.DataFrame</code></dt>
<dd>
<div class="desc"><p>Returns the dataframe of projections for all variables in the model that are part of the
4 vectors specified. There still need to be additional variable projected that are computed
outside of the system to take non-linearity into account (eg long-term interest rates.)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def projections(self) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Returns the dataframe of projections for all variables in the model that are part of the 
    4 vectors specified. There still need to be additional variable projected that are computed
    outside of the system to take non-linearity into account (eg long-term interest rates.)
    &#34;&#34;&#34;
    if hasattr(self, &#39;_projections&#39;):
        return self._projections
    raise Exception(f&#34;The projections for all variables are not yet available for this {type(self)}.&#34;)</code></pre>
</details>
</dd>
<dt id="gcubed.projections.base_projections.BaseProjections.publishable_projections"><code class="name">var <span class="ident">publishable_projections</span> : pandas.core.frame.DataFrame</code></dt>
<dd>
<div class="desc"><p>Returns the dataframe of projections for all variables in the model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def publishable_projections(self) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Returns the dataframe of projections for all variables in the model.
    &#34;&#34;&#34;
    if hasattr(self, &#39;_publishable_projections&#39;):
        return self._publishable_projections
    raise Exception(f&#34;The publishable projections for all variables are not yet available for this {type(self)}.&#34;)</code></pre>
</details>
</dd>
<dt id="gcubed.projections.base_projections.BaseProjections.simulation_data_columns"><code class="name">var <span class="ident">simulation_data_columns</span> : list[str]</code></dt>
<dd>
<div class="desc"><p>Returns the list of years (YYYY format) as strings from the event year to the
end year in the projections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def simulation_data_columns(self) -&gt; list[str]:
    &#34;&#34;&#34;
    Returns the list of years (YYYY format) as strings from the event year to the
    end year in the projections.
    &#34;&#34;&#34;
    return [str(x) for x in range(self.event_year, self.configuration.end_year+1)]</code></pre>
</details>
</dd>
<dt id="gcubed.projections.base_projections.BaseProjections.stable_manifold"><code class="name">var <span class="ident">stable_manifold</span> : <a title="gcubed.stable_manifold.StableManifold" href="../stable_manifold.html#gcubed.stable_manifold.StableManifold">StableManifold</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def stable_manifold(self) -&gt; StableManifold:
    return self._stable_manifold</code></pre>
</details>
</dd>
<dt id="gcubed.projections.base_projections.BaseProjections.state_space_form"><code class="name">var <span class="ident">state_space_form</span> : <a title="gcubed.state_space_form.StateSpaceForm" href="../state_space_form.html#gcubed.state_space_form.StateSpaceForm">StateSpaceForm</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def state_space_form(self) -&gt; StateSpaceForm:
    return self.stable_manifold.ssf</code></pre>
</details>
</dd>
<dt id="gcubed.projections.base_projections.BaseProjections.sym_data"><code class="name">var <span class="ident">sym_data</span> : <a title="gcubed.sym_data.SymData" href="../sym_data.html#gcubed.sym_data.SymData">SymData</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sym_data(self) -&gt; SymData:
    return self.model.sym_data</code></pre>
</details>
</dd>
<dt id="gcubed.projections.base_projections.BaseProjections.yjr_projections"><code class="name">var <span class="ident">yjr_projections</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Get yjr variable projection values
of the projection years.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def yjr_projections(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Get yjr variable projection values
    of the projection years.
    &#34;&#34;&#34;
    if hasattr(self, &#39;_yjr_projections&#39;):
        return self._yjr_projections.to_numpy()
    raise Exception(f&#34;The period t costate variable projections (yjr) are not yet available for this {type(self)}.&#34;)</code></pre>
</details>
</dd>
<dt id="gcubed.projections.base_projections.BaseProjections.yjr_projections_as_dataframe"><code class="name">var <span class="ident">yjr_projections_as_dataframe</span> : pandas.core.frame.DataFrame</code></dt>
<dd>
<div class="desc"><p>Get yjr variable projection values
of the projection years as a dataframe.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def yjr_projections_as_dataframe(self) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Get yjr variable projection values
    of the projection years as a dataframe.
    &#34;&#34;&#34;
    if hasattr(self, &#39;_yjr_projections&#39;):
        return self._yjr_projections
    raise Exception(f&#34;The period t costate variable projections (yjr) are not yet available for this {type(self)}.&#34;)</code></pre>
</details>
</dd>
<dt id="gcubed.projections.base_projections.BaseProjections.yxr_projections"><code class="name">var <span class="ident">yxr_projections</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Get yxr variable projection values
of the projection years.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def yxr_projections(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Get yxr variable projection values
    of the projection years.
    &#34;&#34;&#34;
    if hasattr(self, &#39;_yxr_projections&#39;):
        return self._yxr_projections.to_numpy()
    raise Exception(f&#34;The period t state variable projections are not yet available for this {type(self)}.&#34;)</code></pre>
</details>
</dd>
<dt id="gcubed.projections.base_projections.BaseProjections.yxr_projections_as_dataframe"><code class="name">var <span class="ident">yxr_projections_as_dataframe</span> : pandas.core.frame.DataFrame</code></dt>
<dd>
<div class="desc"><p>Get yxr variable projection values
of the projection years as a dataframe.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def yxr_projections_as_dataframe(self) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Get yxr variable projection values
    of the projection years as a dataframe.
    &#34;&#34;&#34;
    if hasattr(self, &#39;_yxr_projections&#39;):
        return self._yxr_projections
    raise Exception(f&#34;The period t state variable projections (yxr) are not yet available for this {type(self)}.&#34;)</code></pre>
</details>
</dd>
<dt id="gcubed.projections.base_projections.BaseProjections.z1l_projections"><code class="name">var <span class="ident">z1l_projections</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Get z1l variable projection values
of the projection years.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def z1l_projections(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Get z1l variable projection values
    of the projection years.
    &#34;&#34;&#34;
    if hasattr(self, &#39;_z1l_projections&#39;):
        return self._z1l_projections.to_numpy()
    raise Exception(f&#34;The period t Z1L projections are not yet available for this {type(self)}.&#34;)</code></pre>
</details>
</dd>
<dt id="gcubed.projections.base_projections.BaseProjections.z1l_projections_as_dataframe"><code class="name">var <span class="ident">z1l_projections_as_dataframe</span> : pandas.core.frame.DataFrame</code></dt>
<dd>
<div class="desc"><p>Get z1l variable projection values
of the projection years as a dataframe.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def z1l_projections_as_dataframe(self) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Get z1l variable projection values
    of the projection years as a dataframe.
    &#34;&#34;&#34;
    if hasattr(self, &#39;_z1l_projections&#39;):
        return self._z1l_projections
    raise Exception(f&#34;The period t Z1L projections are not yet available for this {type(self)}.&#34;)</code></pre>
</details>
</dd>
<dt id="gcubed.projections.base_projections.BaseProjections.zel_projections"><code class="name">var <span class="ident">zel_projections</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Get zel variable projection values
of the projection years.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def zel_projections(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Get zel variable projection values
    of the projection years.
    &#34;&#34;&#34;
    if hasattr(self, &#39;_zel_projections&#39;):
        return self._zel_projections.to_numpy()
    raise Exception(f&#34;The period t ZEL projections are not yet available for this {type(self)}.&#34;)</code></pre>
</details>
</dd>
<dt id="gcubed.projections.base_projections.BaseProjections.zel_projections_as_dataframe"><code class="name">var <span class="ident">zel_projections_as_dataframe</span> : pandas.core.frame.DataFrame</code></dt>
<dd>
<div class="desc"><p>Get zel variable projection values
of the projection years as a dataframe.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def zel_projections_as_dataframe(self) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Get zel variable projection values
    of the projection years as a dataframe.
    &#34;&#34;&#34;
    if hasattr(self, &#39;_zel_projections&#39;):
        return self._zel_projections
    raise Exception(f&#34;The period t ZEL projections are not yet available for this {type(self)}.&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="gcubed.projections.base_projections.BaseProjections.generate_database_projections"><code class="name flex">
<span>def <span class="ident">generate_database_projections</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts the raw projections into projections that are consistent with the database being used
by the model. These projections can be spliced on to the original database (as opposed to the
GDP scaled database) that was loaded with the model used to produce the projections.</p>
<p>Implements the first parts of the projection conversion logic in datamsymbl.ox.</p>
<p>Step 1.
Get a copy of the raw projections.</p>
<p>Step 2b.
Divide the projections by YRATR in the projection base year for every variable that has units of:
gdp
mmtgdp
btugdp
gwhgdp
This ensures that the resulting values are comparable to the original database aside from scaling by 100.</p>
<h1 id="step-3">Step 3.</h1>
<p>At this stage the interest rates are expressed as decimals so 0.02 is a 2% interest rate.
Adjust the interest rate variables using the intcons adjustment, adding the difference between
the base-projection year interest rate and the assumed neutral real interest rate to each of the interest
rate variables.
This ensures that the result short interest rates are comparable to the original database, aside from scaling by 100.</p>
<h1 id="step-4">Step 4.</h1>
<p>Generate long rates from short rates
This ensures that the long interest rates are derived from the short rates.</p>
<h1 id="step-5">Step 5.</h1>
<p>Adjust long rate projections by adding long rate constants that
are calculated to ensure that the long rates are equal to the
observed values in the base projection year.
This ensures that the long interest rates are comparable to the original database aside from scaling by 100.</p>
<p>Step 6.
Multiply projection values by 100
This ensures that the projections are scaled in the same way as the original database.</p>
<p>Step 7.
Get LGDPR (real GDP level) data in the projection base year for each
region and grow over projection years at rate given by 'labgrow' parameter.
Store the LGDPR projections in the publishable projections dataset.</p>
<p>Saves the result in the _database_projections property.</p>
<p>These database projections should be associated with the publication_units of measurement
available from the sym_data variable summary.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_database_projections(self):
    &#34;&#34;&#34;
    Converts the raw projections into projections that are consistent with the database being used
    by the model. These projections can be spliced on to the original database (as opposed to the
    GDP scaled database) that was loaded with the model used to produce the projections.

    Implements the first parts of the projection conversion logic in datamsymbl.ox.

    Step 1.
    Get a copy of the raw projections.

    Step 2b.
    Divide the projections by YRATR in the projection base year for every variable that has units of:
        gdp
        mmtgdp
        btugdp
        gwhgdp
    This ensures that the resulting values are comparable to the original database aside from scaling by 100.

    # Step 3.
    At this stage the interest rates are expressed as decimals so 0.02 is a 2% interest rate.
    Adjust the interest rate variables using the intcons adjustment, adding the difference between 
    the base-projection year interest rate and the assumed neutral real interest rate to each of the interest 
    rate variables.
    This ensures that the result short interest rates are comparable to the original database, aside from scaling by 100.

    # Step 4.
    Generate long rates from short rates
    This ensures that the long interest rates are derived from the short rates.
     
    # Step 5.
    Adjust long rate projections by adding long rate constants that
    are calculated to ensure that the long rates are equal to the 
    observed values in the base projection year.
    This ensures that the long interest rates are comparable to the original database aside from scaling by 100.

    Step 6.
    Multiply projection values by 100
    This ensures that the projections are scaled in the same way as the original database.

    Step 7.
    Get LGDPR (real GDP level) data in the projection base year for each 
    region and grow over projection years at rate given by &#39;labgrow&#39; parameter.
    Store the LGDPR projections in the publishable projections dataset.

    Saves the result in the _database_projections property.

    These database projections should be associated with the publication_units of measurement
    available from the sym_data variable summary.

    &#34;&#34;&#34;

    # Step 1.
    database_projections: pd.DataFrame = self.projections.copy()

    # Step 2.
    yratr_data: pd.DataFrame = self.database.data.loc[self.database.variables.name.str.startswith(&#34;YRATR(&#34;), str(self.base_year)].copy()
    yratr_data.index = self.sym_data.regions_members
    for variable_name, variable_projection in database_projections.iterrows():
        units: str = str(self.database.variables.loc[variable_name,&#39;units&#39;])
        match units:
            case &#39;gdp&#39; | &#39;btugdp&#39; | &#39;mmtgdp&#39; | &#39;gwhgdp&#39;:
                variable_region: str = str(self.database.variables.loc[variable_name, &#39;region&#39;])
                factor: float = yratr_data.loc[variable_region]
                database_projections.loc[[variable_name], :] /= factor

    # Step 3.
    # Make the adjustment for the neutral real interest rate.
    for prefix in CONSTANTS.INTEREST_RATE_PREFIXES:
        variable_names = self.database.variables.loc[self.database.variables.name.str.startswith(f&#34;{prefix}(&#34;), &#39;name&#39;]
        for variable_name in variable_names:
            database_projections.loc[[variable_name], :] += (float(self.database.data.loc[variable_name, str(self.base_year)] - self.configuration.neutral_real_interest_rate))

    # Step 4.
    # Calculate the long rates.
    real_interest_rates: pd.DataFrame = database_projections.loc[database_projections.index.str.startswith(&#34;INTR(&#34;), str(self.base_year):].copy()
    for variable_name in real_interest_rates.index:
        rb10: pd.DataFrame = self.longrate_calculation(term=10, rates=real_interest_rates.loc[[variable_name], :])
        database_projections.loc[[str(rb10.index[0])], :] = rb10
    nominal_interest_rates: pd.DataFrame = database_projections.loc[database_projections.index.str.startswith(&#34;INTN(&#34;), str(self.base_year):].copy()
    for variable_name in nominal_interest_rates.index:
        nb02: pd.DataFrame = self.longrate_calculation(term=2, rates=nominal_interest_rates.loc[[variable_name], :])
        database_projections.loc[[str(nb02.index[0])], :] = nb02
        nb05: pd.DataFrame = self.longrate_calculation(term=5, rates=nominal_interest_rates.loc[[variable_name], :])
        database_projections.loc[[str(nb05.index[0])], :] = nb05
        nb10: pd.DataFrame = self.longrate_calculation(term=10, rates=nominal_interest_rates.loc[[variable_name], :])
        database_projections.loc[[str(nb10.index[0])], :] = nb10

    # Step 5.
    # Determine the constants to add to the long rates to match base projection year observed and projected values.
    self._long_rate_constants: pd.DataFrame = None
    for prefix in CONSTANTS.BOND_RATE_PREFIXES:
        observed_values: pd.DataFrame = self.database.data.loc[self.database.variables.name.str.startswith(f&#34;{prefix}(&#34;), [str(self.base_year)]].copy()
        projected_values: pd.DataFrame = database_projections.loc[database_projections.index.str.startswith(f&#34;{prefix}(&#34;), [
            str(self.base_year)]].copy()
        constants: pd.DataFrame = observed_values - projected_values
        constants.columns = [str(self.base_year)]
        constants.index = observed_values.index
        if self._long_rate_constants is None:
            self._long_rate_constants = constants
        else:
            self._long_rate_constants = pd.concat([self._long_rate_constants, constants], axis=0)

    # Add the long rate constants to the long rate projections to line the long rate projections
    # up with observed data in the base projection year.
    for variable_name in self.long_rate_constants.index:
        database_projections.loc[[variable_name], :] += self.long_rate_constants.loc[variable_name, str(self.base_year)]

    # Step 6.
    database_projections *= 100.0

    # Step 7.
    rows_containing_LGDPR_data = self.database.variables.name.str.startswith(&#34;LGDPR(&#34;)
    lgdpr_data: pd.DataFrame = self.database.data.loc[rows_containing_LGDPR_data, [str(self.base_year)]].copy() / 100
    us_longrun_effective_labour_productivity_index: pd.DataFrame = self.model.effective_labour_productivity.us_longrun_effective_labour_index.loc[:,self.configuration.base_and_projection_years_column_labels]
    lgdpr_longrun_projections: pd.DataFrame = pd.DataFrame(lgdpr_data.values * us_longrun_effective_labour_productivity_index.values)
    lgdpr_longrun_projections.columns = self.configuration.base_and_projection_years_column_labels
    lgdpr_longrun_projections.index = lgdpr_data.index # Index with the LGDPR full variable names
    database_projections.loc[rows_containing_LGDPR_data, :] = lgdpr_longrun_projections.copy()

    # Splice on the actual data from the model database
    for column in self.model.database.data.columns[::-1]:
        if not (column in database_projections.columns):
            if int(column) &lt; int(database_projections.columns[0]):
                database_projections.insert(0, column, self.model.database.data.loc[:,column], True)
            else:
                break

    # Save the results for use later.
    self._database_projections = database_projections.astype(float)</code></pre>
</details>
</dd>
<dt id="gcubed.projections.base_projections.BaseProjections.generate_publishable_projections"><code class="name flex">
<span>def <span class="ident">generate_publishable_projections</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Uses the real GDP trend growth projections to adjust
the projections of all variables with units equal to
'usgdp' or 'gdp'.</p>
<p>Implements the real GDP scaling part of the projection conversion logic in datamsymbl.ox.</p>
<p>Step 1.
For all projections with units equal to usgdp, multiply the projection
by the US LGDPR projection computed in step 4 when producing the database projections.</p>
<p>Step 2.
For all projections with units equal to 'gdp', multiply the projection by the associated
region's LGDPR projection computed in step 4 when producing the database projections.</p>
<p>These publishable projections should be associated with the publication_units of measurement
available from the sym_data variable summary.</p>
<p>Saves the result in the _publishable_projections property.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_publishable_projections(self):
    &#34;&#34;&#34;

    Uses the real GDP trend growth projections to adjust 
    the projections of all variables with units equal to 
    &#39;usgdp&#39; or &#39;gdp&#39;.

    Implements the real GDP scaling part of the projection conversion logic in datamsymbl.ox.

    Step 1.
    For all projections with units equal to usgdp, multiply the projection 
    by the US LGDPR projection computed in step 4 when producing the database projections.

    Step 2.
    For all projections with units equal to &#39;gdp&#39;, multiply the projection by the associated
    region&#39;s LGDPR projection computed in step 4 when producing the database projections.

    These publishable projections should be associated with the publication_units of measurement
    available from the sym_data variable summary.

    Saves the result in the _publishable_projections property.
    &#34;&#34;&#34;

    publication_projections: pd.DataFrame = self.database_projections.copy()

    # Real GDP scaling
    lgdpr_database_projections: pd.DataFrame = self.database_projections.loc[self.database_projections.index.str.startswith(&#34;LGDPR(&#34;), :].copy()
    lgdpr_database_projections.index = self.model.sym_data.regions_members
    for variable_name in publication_projections.index:
        variable_units: str = str(self.database.variables.loc[variable_name,&#39;units&#39;])
        match variable_units:
            case &#39;usgdp&#39; | &#39;mmtusgdp&#39; | &#39;btuusgdp&#39;:
                publication_projections.loc[[variable_name], :] *= lgdpr_database_projections.loc[[CONSTANTS.USA_REGION_CODE],:].values
            case &#39;gdp&#39; | &#39;mmtgdp&#39; | &#39;btugdp&#39; | &#39;gwhgdp&#39;:
                variable_region: str = str(self.database.variables.loc[variable_name, &#39;region&#39;])
                publication_projections.loc[[variable_name], :] *= lgdpr_database_projections.loc[[variable_region],:].values

    # Save the results for use later.
    self._publishable_projections = publication_projections.astype(float)</code></pre>
</details>
</dd>
<dt id="gcubed.projections.base_projections.BaseProjections.longrate_calculation"><code class="name flex">
<span>def <span class="ident">longrate_calculation</span></span>(<span>self, term: int, rates: pandas.core.frame.DataFrame) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Utility method that returns the compounding long rates given the yearly rates.</p>
<p>Rates are provided as decimal values so 1% is 0.01.</p>
<p>Arguments:</p>
<p>term: the number of years of the term of the instrument. 2 for a 2 year bond.</p>
<p>rates: the projections of the 1 year interest rates, (nominal or real).</p>
<p>Returns the long rates that can be computed from the one year rates. This series is shorter
than the series of one year rates because the required data is not available for
the last (term-1) observations. It is padded with NaN values in the returned projection.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def longrate_calculation(self, term: int, rates: pd.DataFrame) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Utility method that returns the compounding long rates given the yearly rates.

    Rates are provided as decimal values so 1% is 0.01.

    Arguments:

    term: the number of years of the term of the instrument. 2 for a 2 year bond.

    rates: the projections of the 1 year interest rates, (nominal or real).

    Returns the long rates that can be computed from the one year rates. This series is shorter
    than the series of one year rates because the required data is not available for 
    the last (term-1) observations. It is padded with NaN values in the returned projection.
    &#34;&#34;&#34;
    shortrates = rates.copy()
    name_suffix = str(shortrates.index[0]).split(&#39;(&#39;)[1]
    longrates_columns = shortrates.iloc[:, 0:(len(shortrates.columns)-term+1)].columns
    preceding_year: int = int(shortrates.columns[0])-1
    shortrates = shortrates + 1

    shortrates = shortrates.cumprod(axis=&#39;columns&#39;)
    shortrates.insert(0, str(preceding_year), 1.0)

    longrates: pd.DataFrame = pd.DataFrame(np.power(shortrates.iloc[:, term:].to_numpy() / shortrates.iloc[:, 0:-term:1].to_numpy(), 1/term) - 1.0)
    longrates.columns = longrates_columns
    match str(rates.index[0]).split(&#39;(&#39;)[0]:
        case &#39;INTN&#39;:
            match term:
                case 2:
                    long_rate_name = &#39;NB02&#39;
                case 5:
                    long_rate_name = &#39;NB05&#39;
                case 10:
                    long_rate_name = &#39;NB10&#39;
                case _:
                    raise Exception(f&#34;Invalid nominal bond term specified: {term}&#34;)
        case &#34;INTR&#34;:
            match term:
                case 2:
                    long_rate_name = &#39;RB02&#39;
                case 5:
                    long_rate_name = &#39;RB05&#39;
                case 10:
                    long_rate_name = &#39;RB10&#39;
                case _:
                    raise Exception(f&#34;Invalid real bond term specified: {term}&#34;)
        case _:
            raise Exception(f&#34;Invalid variable used to compute bond rates: {str(rates.index[0])}. Use a 1 year interest rate.&#34;)
    longrates.index = [ f&#34;{long_rate_name}({name_suffix}&#34; ]
    return longrates.astype(float)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gcubed.base.Base" href="../base.html#gcubed.base.Base">Base</a></b></code>:
<ul class="hlist">
<li><code><a title="gcubed.base.Base.get_year_labels" href="../base.html#gcubed.base.Base.get_year_labels">get_year_labels</a></code></li>
<li><code><a title="gcubed.base.Base.load_data" href="../base.html#gcubed.base.Base.load_data">load_data</a></code></li>
<li><code><a title="gcubed.base.Base.zeros" href="../base.html#gcubed.base.Base.zeros">zeros</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gcubed.projections" href="index.html">gcubed.projections</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gcubed.projections.base_projections.BaseProjections" href="#gcubed.projections.base_projections.BaseProjections">BaseProjections</a></code></h4>
<ul class="">
<li><code><a title="gcubed.projections.base_projections.BaseProjections.base_year" href="#gcubed.projections.base_projections.BaseProjections.base_year">base_year</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.configuration" href="#gcubed.projections.base_projections.BaseProjections.configuration">configuration</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.database_projections" href="#gcubed.projections.base_projections.BaseProjections.database_projections">database_projections</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.end_year" href="#gcubed.projections.base_projections.BaseProjections.end_year">end_year</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.event_year" href="#gcubed.projections.base_projections.BaseProjections.event_year">event_year</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.exo_projections" href="#gcubed.projections.base_projections.BaseProjections.exo_projections">exo_projections</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.exo_projections_as_dataframe" href="#gcubed.projections.base_projections.BaseProjections.exo_projections_as_dataframe">exo_projections_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.exz_projections" href="#gcubed.projections.base_projections.BaseProjections.exz_projections">exz_projections</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.exz_projections_as_dataframe" href="#gcubed.projections.base_projections.BaseProjections.exz_projections_as_dataframe">exz_projections_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.generate_database_projections" href="#gcubed.projections.base_projections.BaseProjections.generate_database_projections">generate_database_projections</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.generate_publishable_projections" href="#gcubed.projections.base_projections.BaseProjections.generate_publishable_projections">generate_publishable_projections</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.get_deviations_between_projections" href="#gcubed.projections.base_projections.BaseProjections.get_deviations_between_projections">get_deviations_between_projections</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.graphable_projections" href="#gcubed.projections.base_projections.BaseProjections.graphable_projections">graphable_projections</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.long_rate_constants" href="#gcubed.projections.base_projections.BaseProjections.long_rate_constants">long_rate_constants</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.longrate_calculation" href="#gcubed.projections.base_projections.BaseProjections.longrate_calculation">longrate_calculation</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.model" href="#gcubed.projections.base_projections.BaseProjections.model">model</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.parameters" href="#gcubed.projections.base_projections.BaseProjections.parameters">parameters</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.preceding_projection_years" href="#gcubed.projections.base_projections.BaseProjections.preceding_projection_years">preceding_projection_years</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.preceding_projection_years_column_labels" href="#gcubed.projections.base_projections.BaseProjections.preceding_projection_years_column_labels">preceding_projection_years_column_labels</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.preceding_projection_years_count" href="#gcubed.projections.base_projections.BaseProjections.preceding_projection_years_count">preceding_projection_years_count</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.projection_years" href="#gcubed.projections.base_projections.BaseProjections.projection_years">projection_years</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.projection_years_column_labels" href="#gcubed.projections.base_projections.BaseProjections.projection_years_column_labels">projection_years_column_labels</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.projection_years_count" href="#gcubed.projections.base_projections.BaseProjections.projection_years_count">projection_years_count</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.projections" href="#gcubed.projections.base_projections.BaseProjections.projections">projections</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.publishable_projections" href="#gcubed.projections.base_projections.BaseProjections.publishable_projections">publishable_projections</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.simulation_data_columns" href="#gcubed.projections.base_projections.BaseProjections.simulation_data_columns">simulation_data_columns</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.stable_manifold" href="#gcubed.projections.base_projections.BaseProjections.stable_manifold">stable_manifold</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.state_space_form" href="#gcubed.projections.base_projections.BaseProjections.state_space_form">state_space_form</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.sym_data" href="#gcubed.projections.base_projections.BaseProjections.sym_data">sym_data</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.yjr_projections" href="#gcubed.projections.base_projections.BaseProjections.yjr_projections">yjr_projections</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.yjr_projections_as_dataframe" href="#gcubed.projections.base_projections.BaseProjections.yjr_projections_as_dataframe">yjr_projections_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.yxr_projections" href="#gcubed.projections.base_projections.BaseProjections.yxr_projections">yxr_projections</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.yxr_projections_as_dataframe" href="#gcubed.projections.base_projections.BaseProjections.yxr_projections_as_dataframe">yxr_projections_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.z1l_projections" href="#gcubed.projections.base_projections.BaseProjections.z1l_projections">z1l_projections</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.z1l_projections_as_dataframe" href="#gcubed.projections.base_projections.BaseProjections.z1l_projections_as_dataframe">z1l_projections_as_dataframe</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.zel_projections" href="#gcubed.projections.base_projections.BaseProjections.zel_projections">zel_projections</a></code></li>
<li><code><a title="gcubed.projections.base_projections.BaseProjections.zel_projections_as_dataframe" href="#gcubed.projections.base_projections.BaseProjections.zel_projections_as_dataframe">zel_projections_as_dataframe</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>